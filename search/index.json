[{"content":"PREPARATION git download hugo download Check git \u0026amp; hugo added in the environment variables (Windows).\nThe following steps are in Bash.\n1 2 git version hugo version ON PREMISES 1 2 3 4 5 6 hugo new site blog cd blog git clone https://themeName themes/themeName cp themes/themeName/exampleSite/* ./ -r rm hugo.toml hugo server FIRST COMMIT Github Create Repositoriy: username.github.io\n1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master LATER COMMIT 1 2 3 4 5 6 hugo cd public git add . git status git commit -m \u0026#34;add blog post\u0026#34; git push KATEX CONFUSION display obsidian hugo newline \\\\ \\\\\\ % \\% \\\\% suffix { }_ { }\\_ * * \\* ","date":"2023-09-14T00:00:00Z","permalink":"https://example.com/p/hugo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"hugo快速入门"},{"content":"文中所有C代码均编译通过并得到正确结果! (C11 - GCC8.1.0)\n整除 性质: $c|a$, $c|b \\Longrightarrow$ $c|ax+by$, $\\forall x,y\\in\\mathbb{Z}$. 最大公因数: ${\\rm gcd}(a,b)={\\rm sub}_{\\geq 0}{sa+tb|s,t\\in\\mathbb{Z}}$.\n辗转相除求${\\rm gcd}$: $$\\begin{align} \u0026amp;a=q_1b+r_1\\\\ \u0026amp;b=q_2r_1+r_2\\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;r_{n-2}=q_nr_{n-1}+r_n \\end{align}$$ 当 $r_n=0$ 时, 有 $r_{n-1}={\\rm gcd}(a,b)$.\n对序列中被除数与除数从$1$开始编号, 进而有递归: $$\\begin{align} \u0026amp;a_i=(a_i/b_i)b_i+(a_i\\%b_i)\\\\ \u0026amp;a_i=b_{i-1}\\\\ \u0026amp;b_i=a_{i-1}\\%b_{i-1} \\end{align}$$ 并约定 ${\\rm gcd}(a,0)=a$.\n1 2 3 int Euclid(int a, int b){ return b==0? a : Euclid(b,a%b); } Bezout定理: 给定 $a,b\\in\\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\\Longleftrightarrow$ ${\\rm gcd}(a,b)|m$.\n可仅考查 $m={\\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. 在递归中, 显然有 ${\\rm gcd}(a,b)={\\rm gcd}(a_i,b_i)$, 即 $\\exists x_i,y_i\\in\\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$. $$\\begin{align} m\u0026amp;=a_ix_i+b_iy_i\\\\ \u0026amp;=b_{i-1}x_i+(a_{i-1}\\%b_{i-1})y_i\\\\ \u0026amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\\\ \u0026amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\\\ \u0026amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1} \\end{align}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 int extEuclid(int a, int b, int* x, int* y){ if (b==0){ *x = 1; *y = 0; return a; } else { int tempX,tempY; int gcd = extEuclid(b,a%b,\u0026amp;tempX,\u0026amp;tempY); *y = tempX-(a/b)*tempY; *x = tempY; return gcd; } } 而使用CPP元组写法上更优雅些:\n1 2 3 4 5 6 7 8 9 tuple\u0026lt;int,int,int\u0026gt;extEuclidCpp(int a, int b){ if (b==0){ return make_tuple(a,1,0); } else { int x,y,gcd; tie(x,y,gcd) = extEuclidCpp(b,a%b); return make_tuple(gcd,y,x-(a/b)*y); } } 定理: 素数i $p$ 及 $a,b\\in\\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.\n设 $p\\nmid a$ 且 $p\\nmid b$, 则 $\\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.\n唯一分解: $\\forall n\\in\\mathbb{Z}$, $n=\\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\\in\\mathbb{Z}_+$, 形式唯一.\n同余 性质: $\\forall m\\in\\mathbb{Z}_+$, $a\\equiv b({\\rm mod}\\ m) \\Longleftrightarrow m|a-b$.\n$a\\equiv b({\\rm mod}\\ m)$, $c\\equiv d({\\rm mod}\\ m) \\Longrightarrow a+c\\equiv b+d({\\rm mod}\\ m)$, $ac\\equiv bd({\\rm mod}\\ m)$, $a^n\\equiv b^n({\\rm mod}\\ m)$. $ak\\equiv bk({\\rm mod}\\ m) \\Longrightarrow a\\equiv b({\\rm mod}\\ \\frac{m}{{\\rm gcd}(m,k)})$. 模 $m$ 剩余类: $\\mathbb{Z}/m\\mathbb{Z}$. 最小非负完全剩余系: $\\mathbb{Z}_m={0,1\u0026hellip;,m-1}$, 显然 $\\forall x\\neq y\\in\\mathbb{Z}_m$ s.t. $x\\not\\equiv y({\\rm mod}\\ m)$. 既约剩余系: $\\mathbb{Z}_m^*={a\\in\\mathbb{Z}_m|{\\rm gcd}(a,m)=1}$. Euler $\\varphi$ 函数: $$m=\\prod_{i=1}^r p_i^{k_i}, |\\mathbb{Z}_m^*|=\\varphi(m)=\\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\\prod_{p|m}(1-\\frac{1}{p})$$\n当 $m=p$ 为素数时, 有 $\\varphi(p)=p-1$; $\\mathbb{Z}_p^*={1,2,\u0026hellip;,p-1}$ 为循环群, 生成元个数为$\\varphi(p-1)$.\n考察函数性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // O(n), 每个数均只遍历一次 void phiEulerLinerSieve(int n){ int phi[n+1], prime[n+1]; bool isSieved[n+1]; int count = 1; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[count++] = i; phi[i] = i-1; } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ int composite = i*prime[j]; isSieved[composite] = 1; if (i%prime[j] == 0){ phi[composite] = primep[j]*phi[i]; break; } else { phi[composite] = (prime[j]-1)*phi[i]; } } } } 定理: 若 ${\\rm \\gcd}(a,m)=1$, $x$ 遍历 $\\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\\mathbb{Z}_m^*$.\n考虑 ${\\rm gcd}(ax,m)=1$ 及 $ax_i\\not\\equiv ax_j({\\rm mod}\\ m)$, $i\\neq j$.\n逆元: 若 ${\\rm gcd}(a,m)=1$, 则 $\\exists ! x\\in\\mathbb{Z}_m^*$ s.t. $ax\\equiv 1({\\rm mod}\\ m)$. Euler: 若 ${\\rm gcd}(a,m)=1$, 则 $a^{\\varphi(m)}\\equiv 1({\\rm mod}\\ m)$.\n$\\mathbb{Z}_m^*={x_1,\u0026hellip;,x_{\\varphi(m)}}={ax_1,\u0026hellip;,a_{\\varphi(m)}}$, 故 $\\prod x_i\\equiv\\prod ax_i({\\rm mod}\\ m)$, 已知 ${\\rm gcd}(x_i,m)=1$, 得 $m|a^{\\varphi(m)}-1$.\n特别 $m=p$ 为素数时, Fermat: 若 $p\\nmid a$, 则 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 有 $a^{-1}\\equiv a^{p-2}({\\rm mod}\\ p)$. 由扩展Euclid, ${\\rm gcd}(a,m)=1$, $\\exists s,t\\in\\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\\equiv s({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 int inverseExtEuclid(int a, int m){ int s,t; int gcd = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (gcd == 1){ return s; } else { return 0; } } wilson: 素数 $p$ 有 $(p-1)!\\equiv -1({\\rm mod}\\ p)$.\n$\\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; ${2,3,\u0026hellip;,p-2}$ 中两两配对互逆.\n1 2 3 4 5 6 7 bool wilson(int p){ int factMod = 1; for (int i = p-1; i \u0026gt;= 1; --i){ factMod = (factMod*i)%p; } return (factMod+1)%p == 0; } 仿射: ${\\rm gcd}(a,26)=1$, 密钥对数量 $26\\varphi(26)-1=311$.\n加密 $c=E_{a,b}(m)=am+b({\\rm mod}\\ 26)$. 解密 $m=D_{a,b}(c)=a^{-1}(c-b)({\\rm mod}\\ 26)$. 同余式 同余式 $f(x)\\equiv a_nx^n+\u0026hellip;+a_1x+a_0({\\rm mod}\\ m)$, $a_i\\in\\mathbb{z}$, $m\\in\\mathbb{Z}_+$. 同余方程 $f(x)\\equiv 0({\\rm mod}\\ m)$ 至多有 $m$ 个解(剩余类).\n一次同余 $ax\\equiv b({\\rm mod}\\ m)$, $a,b\\in\\mathbb{Z}$, $m\\in\\mathbb{Z}_+$ 有解 $\\iff {\\rm gcd}(a,m)|b$.\n$ax\\equiv b({\\rm mod}\\ m)$ 在 ${\\rm gcd}(a,m)=1$ 时有唯一解 $x\\equiv a^{-1}b({\\rm mod}\\ m)$. 记 $d={\\rm gcd}(a,m)$, 有 $\\frac{a}{d}x\\equiv \\frac{b}{d}({\\rm mod}\\ \\frac{m}{d})$, 即 $x=\\frac{b}{d}(\\frac{a}{d})^{-1}+k\\frac{m}{d}$, $k\\in\\mathbb{Z}$. 考虑 $k=qd+r$, $q,r\\in\\mathbb{Z}$, $0\\leq r\u0026lt; d$, $x=[\\frac{b}{d}(\\frac{a}{d})^{-1}({\\rm mod}\\frac{m}{d})+r\\frac{m}{d}]({\\rm mod\\ m})$.\n求解步骤:\n扩展Euclid求 $d={\\rm gcd}(a,m)$, 记 $sa+tm=d$; $b\\%d=0$ 判断有无解; 设 $b\u0026rsquo;=b/d$, $m\u0026rsquo;=m/d$, $s\u0026rsquo;\\equiv s({\\rm mod}\\ m\u0026rsquo;)$; 得 $x\\equiv s\u0026rsquo;b\u0026rsquo;+rm\u0026rsquo;\\ ({\\rm mod}\\ m)$, $r=0,1,\u0026hellip;,d-1$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int linearCongEq (int a, int b, int m, int ansX[]){ a %= m; b %= m; int s,t; int origM = m; int d = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (b%d == 0){ b /= d; m /= d; s %= m; for (int r = 0; r \u0026lt;= d-1; ++r){ ansX[r] = ((s*b+r*m)%(origM)+origM)%origM; } return d; } else { return 0; } } 一次同余组(CRT): $m_{i{1\\leq i \\leq k}}$ 两两互素, 同余组 $x\\equiv a_i({\\rm mod\\ m_i})_{{1\\leq i\\leq k}}$ 有唯一解 $x=\\sum M_i M_i^{-1} a_i \\ ({\\rm mod}\\ m)$. 其中, $m=\\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 long crt (int a[],int m[],int n){ int modSepM[n]; int modIevM[n]; long modM[n]; long prodM = 1; long x = 0; for (int i = 0; i \u0026lt; n; ++i){ prodM *= m[i]*1L; } for (int i = 0; i \u0026lt; n; ++i){ modM[i] = 1L*prodM/m[i]; modSepM[i] = (1L*modM[i])%m[i]; modIevM[i] = inverseExtEuclid(modSepM[i],m[i]); if (!modIevM[i]){ return 0; } } for (int i = 0; i \u0026lt; n; ++i) { x = (x+1L*modIevM[i]*modM[i]*a[i])%prodM; } x = (x+prodM)%prodM; return x; } RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$.\n公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv c^d({\\rm mod}\\ n)$. 快速模幂 $r\\equiv t^e({\\rm mod}\\ n)$ 1 2 3 4 5 6 7 8 9 10 11 int fastPowerMod (int t, int ex, int n){ int r = 1; while (ex){ if (ex\u0026amp;1){ r = (1LL*r*t)%modular; } t = (1LL*t*t)%modular; ex \u0026gt;\u0026gt;= 1; } return r; } 二次剩余 $ax^2+bx+c\\equiv 0({\\rm mod}\\ m)$ 总能简化为 $x^2\\equiv d({\\rm mod}\\ q^k)$, $q$ 为素数, $a,b,c,d,m,k\\in\\mathbb{Z}_+$. 仅考虑 $x^2\\equiv a({\\rm mod}\\ q)$, ${\\rm gcd}(a,p)=1$, $a\\in\\mathbb{Z}$ 为模素数 $q$ 的二次剩余.\nEuler: ${\\rm gcd}(a,p)=1$, $p$ 为奇素数, $a\\in\\mathbb{Z}$:\n模 $p$ 的二次剩余恰有 $\\frac{p-1}{2}$ 个. $a$ 为模 $p$ 二次剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$, 此时 $x^2\\equiv a({\\rm mod}\\ p)$ 有二解. $a$ 为模 $p$ 二次非剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv -1({\\rm mod}\\ p)$. 显然 $i^2\\equiv(p-i)^2({\\rm mod}\\ p)$; 若 $j^2\\equiv i^2({\\rm mod}\\ p)$, $1\\leq i\u0026lt;j\u0026lt;\\frac{p}{2}$, 则 $p|j-i$ 或 $p|j+i$, 但 $j+i\u0026lt;p$, 矛盾.\n$a$ 为模 $p$ 二次剩余时, $\\exists x_0\\in\\mathbb{Z}$, ${\\rm gcd}(x_0,p)=1$, $x_0^2\\equiv a({\\rm mod}\\ p)$, 故 $a^{\\frac{p-1}{2}}\\equiv x_0^{p-1}\\equiv 1({\\rm mod}\\ p)$.\n$a$ 为模 $p$ 二次非剩余时, 考虑 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 则 $p|{\\frac{p-1}{2}}-1$ 或 $p|{\\frac{p-1}{2}}+1$, 但 $x^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$ 的全部解恰为全部的二次剩余.\nLegendre: $(\\frac{a}{p})=a^{\\frac{p-1}{2}}\\%p=1\\ {\\rm or}\\ -1\\ {\\rm or}\\ 0$, $p$ 为素数, $a\\in\\mathbb{Z}$.\n$$ (\\frac{-1}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%4=1\\\\ \u0026amp;-1,\\ \u0026amp;p\\%4=3 \\end{cases}$$\n$$ (\\frac{2}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%8=1,7\\\\ \u0026amp;-1,\\ \u0026amp;p\\%8=3,5 \\end{cases}$$\n二次互反: $(\\frac{p}{q})(\\frac{q}{p})=(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$, $p\\ne q$ 为奇素数.\nGuass: 奇素数 $p$, $a\\in\\mathbb{Z}$, ${\\rm gcd}(a,p)=1$, 设 $M_{a,p}={ka\\%p, \\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\ |\\ ka\\%p\u0026gt;\\frac{p}{2}}$, 记 $m(a,p)=|M_{a,p}|$, 则 $(\\frac{a}{p})=(-1)^{m(a,p)}$.\n设 $K={ka\\%p\\ |\\ k=1,2,\u0026hellip;,\\frac{p-1}{2}}$, $b_i\\in M$, $c_j\\in M-K$, $i=1,2,..,m(a,p)$, $j=1,2,\u0026hellip;,\\frac{p-1}{2}-m(a,p)$.\n显然有 $c_j\\ne p-b_i$, $\\forall i,j$; 否则 $p|b_i+c_j$, 即 $\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $p|a(x+y)$, 但 $x+y\u0026lt;p$, 矛盾.\n故 $a^{\\frac{p-1}{2}}(\\frac{p-1}{2})!\\equiv\\prod c_j \\prod (p-b_i)\\equiv (-1)^{m(a,p)}(\\frac{p-1}{2})!({\\rm mod}\\ p)$.\nEisenstein: $a$ 为奇数时, 记$e(a,p)=\\sum\\lfloor\\frac{ka}{p}\\rfloor$, 有 $e(a,p)\\equiv m(a,p)({\\rm mod}\\ 2)$.\n不妨设 $ka=d_kp+r_k$, $0\\leq r_k\\leq p-1$, $d_k,r_k\\in\\mathbb{Z}$, 有 $p\\sum d_k+\\sum r_k=\\sum ka = \\sum c_j+\\sum (p-b_i)$, 故 $\\sum d_k\\equiv m(a,p)({\\rm mod}\\ 2)$; 显然 $e(a,p)=\\sum d_k$.\n$q\\ne p$ 为奇素数时, $\\not\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $xp=qy$, 即 $e(p,q)+e(q,p)=\\frac{p-1}{2}\\frac{q-1}{2}$.\n$a=2$ 时, $\\lfloor\\frac{p}{4}\\rfloor\\leq k\\leq \\lfloor\\frac{p}{2}\\rfloor$, 有 $m=\\lfloor\\frac{p}{2}\\rfloor-\\lfloor\\frac{p}{4}\\rfloor$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int fastLegendre(int a, int p){ int s; int e = 0; if (a == 0 || a == 1){ return a; } else { while (a%2 == 0){ a /= 2; ++e; } if (e%2 == 0 || p%8 == 1 || p%8 == 7){ s = 1; } else { s = -1; } if (p%4 == 3 \u0026amp;\u0026amp; a%4 == 3){ s = -s; } if (a == 1){ return s; } else { return s*fastLegendre(p%a,a); } } } Rabin: 素数 $p\\equiv q\\equiv 3({\\rm mod}\\ 4)$.\n公钥 $n=pq$, 加密 $c\\equiv E_{n}(m)\\equiv m^2({\\rm mod}\\ n)$. 私钥 $(p,q)$, 解密 $m\\equiv D_{p,q}(c)\\equiv \\pm c^{\\frac{p+1}{4}}({\\rm mod}\\ p)\\equiv \\pm c^{\\frac{q+1}{4}}({\\rm mod}\\ q)\\ (2 in 4)$. ","date":"2023-09-05T00:00:00Z","permalink":"https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"密码学数学基础"},{"content":" 基本属性: 信息机密性, 信息真实性, 数据完整性, 行为不可否认性 体制: 对称加密, 非对称加密 分析: 唯密文攻击, 已知明文攻击, 选择明文攻击, 选择密文攻击, 自适应选择明文攻击, 选择密钥攻击 评价: 无条件安全, 计算安全(破解代价超过信息价值;破解时间超过信息时效) 仿射密码 古典密码中单表代换的代表.\n1 2 3 4 5 6 7 8 9 10 11 12 void affineEncrypt(char *plaintext, char *ciphertext, int keyA, int keyB){ long length = strlen(plaintext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;A\u0026#39;)+keyB)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;a\u0026#39;)+keyB)%26+\u0026#39;a\u0026#39;; } else { ciphertext[i] = plaintext[i]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 void affineDecrypt(char *ciphertext, char *plaintext, int keyAReverse, int keyB){ long length = strlen(ciphertext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;A\u0026#39;-keyB))%26+26)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;a\u0026#39;-keyB))%26+26)%26+\u0026#39;a\u0026#39;; } else { plaintext[i] = ciphertext[i]; } } } 可以通过字母频率分析破解.\n1 2 3 4 5 6 7 8 9 10 11 void freqAnalyze(char *ciphertext, long *count){ int num = 0; while (ciphertext[num] != \u0026#39;\\0\u0026#39;){ if (isupper(ciphertext[num])){ count[ciphertext[num]-\u0026#39;A\u0026#39;]++; } else if (islower(ciphertext[num])){ count[ciphertext[num]-\u0026#39;a\u0026#39;]++; } ++num; } } 自同步序列密码 种子密钥通过LFSR(线性反馈移位寄存器)生成伪随机密钥序列 $k=k_0k_1k_2\u0026hellip;$.\n加密 $c_i=E_{k}(m)=m_i\\oplus k_i$, $\\oplus$ 为异或(位加法). 解密 $m_i=D_{k}(m)=c_i\\oplus k_i$. 使用verligo实现LFSR.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 32-bit long module lfsr(32)(clk, reset, lfsr); input clk, reset; output reg [31:0] lfsr; wire d0; xnor(d0, lfsr[31], lfsr[21], lfsr[1], lfsr[0]); always @(posedge clk, posedge reset) begin if(reset) begin lfsr \u0026lt;= 32\u0026#39;h00000001; end else begin lfsr \u0026lt;= {lfsr[30:0], d0}; end end endmodule (本节未完待续)\n$m$ 序列条件 反推LFSR构成 ","date":"2023-09-04T00:00:00Z","permalink":"https://example.com/p/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"对称加密"}]