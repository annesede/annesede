[{"content":"整除 性质: $c|a$, $c|b \\Longrightarrow$ $c|ax+by$, $\\forall x,y\\in\\mathbb{Z}$. 最大公因数: ${\\rm gcd}(a,b)={\\rm sub}_{\\geq 0}{sa+tb|s,t\\in\\mathbb{Z}}$.\n辗转相除求${\\rm gcd}$: $$\\begin{align} \u0026amp;a=q_1b+r_1\\\\ \u0026amp;b=q_2r_1+r_2\\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;r_{n-2}=q_nr_{n-1}+r_n \\end{align}$$ 当 $r_n=0$ 时, 有 $r_{n-1}={\\rm gcd}(a,b)$.\n对序列中被除数与除数从$1$开始编号, 进而有递归: $$\\begin{align} \u0026amp;a_i=(a_i/b_i)b_i+(a_i\\%b_i)\\\\ \u0026amp;a_i=b_{i-1}\\\\ \u0026amp;b_i=a_{i-1}\\%b_{i-1} \\end{align}$$ 并约定 ${\\rm gcd}(a,0)=a$.\n1 2 3 int Euclid(int a, int b){ return b==0? a : Euclid(b,a%b); } Bezout定理: 给定 $a,b\\in\\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\\Longleftrightarrow$ ${\\rm gcd}(a,b)|m$.\n可仅考查 $m={\\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. 在递归中, 显然有 ${\\rm gcd}(a,b)={\\rm gcd}(a_i,b_i)$, 即 $\\exists x_i,y_i\\in\\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$. $$\\begin{align} m\u0026amp;=a_ix_i+b_iy_i\\\\ \u0026amp;=b_{i-1}x_i+(a_{i-1}\\%b_{i-1})y_i\\\\ \u0026amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\\\ \u0026amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\\\ \u0026amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1} \\end{align}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 int extEuclid(int a, int b, int* x, int* y){ if (b==0){ *x = 1; *y = 0; return a; } else { int tempX,tempY; int gcd = extEuclid(b,a%b,\u0026amp;tempX,\u0026amp;tempY); *y = tempX-(a/b)*tempY; *x = tempY; return gcd; } } 而使用CPP元组写法上更优雅些:\n1 2 3 4 5 6 7 8 9 tuple\u0026lt;int,int,int\u0026gt;extEuclidCpp(int a, int b){ if (b==0){ return make_tuple(a,1,0); } else { int x,y,gcd; tie(x,y,gcd) = extEuclidCpp(b,a%b); return make_tuple(gcd,y,x-(a/b)*y); } } 定理: 素数i $p$ 及 $a,b\\in\\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.\n设 $p\\nmid a$ 且 $p\\nmid b$, 则 $\\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.\n唯一分解: $\\forall n\\in\\mathbb{Z}$, $n=\\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\\in\\mathbb{Z}_+$, 形式唯一.\n同余 性质: $\\forall m\\in\\mathbb{Z}_+$, $a\\equiv b({\\rm mod}\\ m) \\Longleftrightarrow m|a-b$.\n$a\\equiv b({\\rm mod}\\ m)$, $c\\equiv d({\\rm mod}\\ m) \\Longrightarrow a+c\\equiv b+d({\\rm mod}\\ m)$, $ac\\equiv bd({\\rm mod}\\ m)$, $a^n\\equiv b^n({\\rm mod}\\ m)$. $ak\\equiv bk({\\rm mod}\\ m) \\Longrightarrow a\\equiv b({\\rm mod}\\ \\frac{m}{{\\rm gcd}(m,k)})$. 模 $m$ 剩余类: $\\mathbb{Z}/m\\mathbb{Z}$. 最小非负完全剩余系: $\\mathbb{Z}_m={0,1\u0026hellip;,m-1}$, 显然 $\\forall x\\neq y\\in\\mathbb{Z}_m$ s.t. $x\\not\\equiv y({\\rm mod}\\ m)$. 既约剩余系: $\\mathbb{Z}_m^*={a\\in\\mathbb{Z}_m|{\\rm gcd}(a,m)=1}$. Euler $\\varphi$ 函数: $$m=\\prod_{i=1}^r p_i^{k_i}, |\\mathbb{Z}_m^*|=\\varphi(m)=\\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\\prod_{p|m}(1-\\frac{1}{p})$$\n当 $m=p$ 为素数时, 有 $\\varphi(p)=p-1$; $\\mathbb{Z}_p^*={1,2,\u0026hellip;,p-1}$ 为循环群, 生成元个数为$\\varphi(p-1)$.\n考察函数性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // O(n), 每个数均只遍历一次 void phiEulerLinerSieve(int n){ int phi[n+1], prime[n+1]; bool isSieved[n+1]; int count = 1; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[count++] = i; phi[i] = i-1; } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ int composite = i*prime[j]; isSieved[composite] = 1; if (i%prime[j] == 0){ phi[composite] = primep[j]*phi[i]; break; } else { phi[composite] = (prime[j]-1)*phi[i]; } } } } 定理: 若 ${\\rm \\gcd}(a,m)=1$, $x$ 遍历 $\\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\\mathbb{Z}_m^*$.\n考虑 ${\\rm gcd}(ax,m)=1$ 及 $ax_i\\not\\equiv ax_j({\\rm mod}\\ m)$, $i\\neq j$.\n逆元: 若 ${\\rm gcd}(a,m)=1$, 则 $\\exists ! x\\in\\mathbb{Z}_m^*$ s.t. $ax\\equiv 1({\\rm mod}\\ m)$. Euler: 若 ${\\rm gcd}(a,m)=1$, 则 $a^{\\varphi(m)}\\equiv 1({\\rm mod}\\ m)$.\n$\\mathbb{Z}_m^*={x_1,\u0026hellip;,x_{\\varphi(m)}}={ax_1,\u0026hellip;,a_{\\varphi(m)}}$, 故 $\\prod x_i\\equiv\\prod ax_i({\\rm mod}\\ m)$, 已知 ${\\rm gcd}(x_i,m)=1$, 得 $m|a^{\\varphi(m)}-1$.\n特别 $m=p$ 为素数时, Fermat: 若 $p\\nmid a$, 则 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 有 $a^{-1}\\equiv a^{p-2}({\\rm mod}\\ p)$. 由扩展Euclid, ${\\rm gcd}(a,m)=1$, $\\exists s,t\\in\\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\\equiv s({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 int inverseExtEuclid(int a, int m){ int s,t; int gcd = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (gcd == 1){ return s; } else { return 0; } } wilson: 素数 $p$ 有 $(p-1)!\\equiv -1({\\rm mod}\\ p)$.\n$\\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; ${2,3,\u0026hellip;,p-2}$ 中两两配对互逆.\n1 2 3 4 5 6 7 bool wilson(int p) { int factMod = 1; for (int i = p-1; i \u0026gt;= 1; --i) { factMod = (factMod*i)%p; } return (factMod+1)%p == 0; } 同余式 同余式 $f(x)\\equiv a_nx^n+\u0026hellip;+a_1x+a_0({\\rm mod}\\ m)$, $a_i\\in\\mathbb{z}$, $m\\in\\mathbb{Z}_+$. 同余方程 $f(x)\\equiv 0({\\rm mod}\\ m)$ 至多有 $m$ 个解(剩余类).\n一次同余 $ax\\equiv b({\\rm mod}\\ m)$, $a,b\\in\\mathbb{Z}$, $m\\in\\mathbb{Z}_+$ 有解 $\\iff {\\rm gcd}(a,m)|b$.\n$ax\\equiv b({\\rm mod}\\ m)$ 在 ${\\rm gcd}(a,m)=1$ 时有唯一解 $x\\equiv a^{-1}b({\\rm mod}\\ m)$. 记 $d={\\rm gcd}(a,m)$, 有 $\\frac{a}{d}x\\equiv \\frac{b}{d}({\\rm mod}\\ \\frac{m}{d})$, 即 $x=\\frac{b}{d}(\\frac{a}{d})^{-1}+k\\frac{m}{d}$, $k\\in\\mathbb{Z}$. 考虑 $k=qd+r$, $q,r\\in\\mathbb{Z}$, $0\\leq r\u0026lt; d$, $x=[\\frac{b}{d}(\\frac{a}{d})^{-1}({\\rm mod}\\frac{m}{d})+r\\frac{m}{d}]({\\rm mod\\ m})$.\n求解步骤:\n扩展Euclid求 $d={\\rm gcd}(a,m)$, 记 $sa+tm=d$; $b%d=0$ 判断有无解; 设 $b\u0026rsquo;=b/d$, $m\u0026rsquo;=m/d$, $s\u0026rsquo;\\equiv s({\\rm mod}\\ m\u0026rsquo;)$; 得 $x\\equiv s\u0026rsquo;b\u0026rsquo;+rm\u0026rsquo;\\ ({\\rm mod}\\ m)$, $r=0,1,\u0026hellip;,d-1$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int linearCongEq (int a, int b, int m, int ansX[]){ a %= m; b %= m; int s,t; int origM = m; int d = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (b%d == 0){ b /= d; m /= d; s %= m; for (int r = 0; r \u0026lt;= d-1; ++r) { ansX[r] = ((s*b+r*m)%(origM)+origM)%origM; } return d; } else { return 0; } } 一次同余组(CRT): $m_{i{1\\leq i \\leq k}}$ 两两互素, 同余组 $x\\equiv a_i({\\rm mod\\ m_i})_{{1\\leq i\\leq k}}$ 有唯一解 $x=\\sum M_i M_i^{-1} a_i \\ ({\\rm mod}\\ m)$. 其中, $m=\\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 long crt (int a[],int m[],int n){ int modSepM[n]; int modIevM[n]; long modM[n]; long prodM = 1; long x = 0; for (int i = 0; i \u0026lt; n; ++i) { prodM *= m[i]*1L; } for (int i = 0; i \u0026lt; n; ++i) { modM[i] = 1L*prodM/m[i]; modSepM[i] = (1L*modM[i])%m[i]; modIevM[i] = inverseExtEuclid(modSepM[i],m[i]); if (!modIevM[i]){ return 0; } } for (int i = 0; i \u0026lt; n; ++i) { x = (x+1L*modIevM[i]*modM[i]*a[i])%prodM; } x = (x+prodM)%prodM; return x; } RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$.\n公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv c^d({\\rm mod}\\ n)$. 快速模幂 $r\\equiv t^e({\\rm mod}\\ n)$ 1 2 3 4 5 6 7 8 9 10 11 int quickPowerMod (int t, int ex, int n){ int r = 1; while (ex){ if (ex\u0026amp;1){ r = (1LL*r*t)%modular; } t = (1LL*t*t)%modular; ex \u0026gt;\u0026gt;= 1; } return r; } ","date":"2023-09-04T00:00:00Z","permalink":"https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"密码学数学基础"}]