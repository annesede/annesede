<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='未整理完'>
<title>密码学</title>

<link rel='canonical' href='https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6/'>

<link rel="stylesheet" href="/scss/style.min.24ef1cc321916467896e8c70c10c0ad7b98c2a8df14298032fb637216e397f50.css"><meta property='og:title' content='密码学'>
<meta property='og:description' content='未整理完'>
<meta property='og:url' content='https://example.com/p/%E5%AF%86%E7%A0%81%E5%AD%A6/'>
<meta property='og:site_name' content='annesede的博客'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='数学' /><meta property='article:tag' content='C' /><meta property='article:tag' content='C&#43;&#43;' /><meta property='article:published_time' content='2023-11-02T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2023-11-03T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="密码学">
<meta name="twitter:description" content="未整理完">
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu753714c8df5506bae6b3b709f3103a1b_67963_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">⭐</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">annesede的博客</a></h1>
            <h2 class="site-description">Some words were just written here to fill the blank.</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/annesede'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#数学基础">数学基础</a>
      <ol>
        <li><a href="#整除">整除</a></li>
        <li><a href="#同余">同余</a></li>
        <li><a href="#同余式">同余式</a></li>
        <li><a href="#二次剩余">二次剩余</a></li>
        <li><a href="#原根">原根</a></li>
        <li><a href="#群">群</a></li>
        <li><a href="#环和域">环和域</a></li>
        <li><a href="#椭圆曲线群">椭圆曲线群</a></li>
        <li><a href="#传统算法">传统算法</a></li>
      </ol>
    </li>
    <li><a href="#古典密码">古典密码</a>
      <ol>
        <li><a href="#仿射密码">仿射密码</a></li>
        <li><a href="#vernam密码">Vernam密码</a></li>
      </ol>
    </li>
    <li><a href="#自同步序列密码">自同步序列密码</a>
      <ol>
        <li><a href="#ad5">AD5</a></li>
        <li><a href="#rc4">RC4</a></li>
        <li><a href="#zuc">ZUC</a></li>
      </ol>
    </li>
    <li><a href="#分组密码">分组密码</a>
      <ol>
        <li><a href="#des">DES</a></li>
        <li><a href="#aes">AES</a></li>
        <li><a href="#sm4">SM4</a></li>
      </ol>
    </li>
    <li><a href="#公钥密码">公钥密码</a>
      <ol>
        <li><a href="#基础">基础</a></li>
        <li><a href="#rsa">RSA</a></li>
        <li><a href="#elgamal型">ElGamal型</a></li>
        <li><a href="#ntru">NTRU</a></li>
      </ol>
    </li>
    <li><a href="#hash函数">Hash函数</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" >
                信息安全
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            未整理完
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2023-11-02</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 29 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p><small>(C11 - GCC8.1.0)</small></p>
<h1 id="导引">导引</h1>
<p>基本属性: 信息机密性, 信息真实性, 数据完整性, 行为不可否认性.</p>
<p>体制: $(M,C,K_1,K_2,E,D)$ 明文空间, 密文空间, 加密密钥空间, 解密密钥空间, 加密空间, 解密空间; 加密变换 $c=E_{k_1}(m)$, 解密变换 $m=D_{k_2}(c)$.</p>
<p>类别: 对称加密, 非对称加密, Hash函数, 密码协议.</p>
<p>分析: 唯密文攻击, 已知明文攻击, 选择明文攻击, 选择密文攻击, 自适应选择明文攻击, 选择密钥攻击.</p>
<p>评价: 无条件安全 $P(M|C)=P(M)$; 可证明安全(破解本质为数学难题); 计算安全(破解代价超过信息价值;破解时间超过信息时效).</p>
<p>攻击: 被动攻击(监听-信息机密性); 主动攻击(伪造-信息真实性,篡改-数据完整性,否认-行为不可否认性).</p>
<h2 id="数学基础">数学基础</h2>
<h3 id="整除">整除</h3>
<p>性质: $c|a$, $c|b \Longrightarrow$ $c|ax+by$, $\forall x,y\in\mathbb{Z}$. <br />
最大公因数: ${\rm gcd}(a,b)=\inf_{\geq 0}\{sa+tb|s,t\in\mathbb{Z}\}$.</p>
<p>辗转相除求${\rm gcd}$:
$$\begin{align}
&amp;a=q_1b+r_1\\
&amp;b=q_2r_1+r_2\\
&amp;&hellip;\\
&amp;r_{n-2}=q_nr_{n-1}+r_n
\end{align}$$
当 $r_n=0$ 时, 有 $r_{n-1}={\rm gcd}(a,b)$.</p>
<p>对序列中被除数与除数从$1$开始编号, 进而有递归:
$$\begin{align}
&amp;a_i=(a_i/b_i)b_i+(a_i\%b_i)\\
&amp;a_i=b_{i-1}\\
&amp;b_i=a_{i-1}\%b_{i-1}
\end{align}$$
并约定 ${\rm gcd}(a,0)=a$.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">gcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Bezout定理: 给定 $a,b\in\mathbb{Z}$, Diophantine方程 $ax+by=m$ 有解 $\Longleftrightarrow$ ${\rm gcd}(a,b)|m$.</p>
<p>可仅考查 $m={\rm gcd}(a,b)$, 不然, 结果只需乘相应倍数. <br />
在递归中, 显然有 ${\rm gcd}(a,b)={\rm gcd}(a_i,b_i)$,  即 $\exists x_i,y_i\in\mathbb{Z}$ s.t. $a_ix_i+b_iy_i=m$.
$$\begin{align}
m&amp;=a_ix_i+b_iy_i\\
&amp;=b_{i-1}x_i+(a_{i-1}\%b_{i-1})y_i\\
&amp;=b_{i-1}x_i+[a_{i-1}-(a_{i-1}/b_{i-1})b_{i-1}]y_i\\
&amp;=y_ia_{i-1}+[x_i-(a_{i-1}/b_{i-1})y_i]b_{i-1}\\
&amp;=x_{i-1}a_{i-1}+y_{i-1}b_{i-1}
\end{align}$$</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">extEuclid</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">y</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">tempX</span><span class="p">,</span><span class="n">tempY</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">gcd</span> <span class="o">=</span> <span class="nf">extEuclid</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tempX</span><span class="p">,</span><span class="o">&amp;</span><span class="n">tempY</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">y</span> <span class="o">=</span> <span class="n">tempX</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">tempY</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">tempY</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">gcd</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>而使用CPP元组写法上更优雅些:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C++" data-lang="C++"><span class="line"><span class="cl"><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="n">extEuclidCpp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">==</span><span class="mi">0</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">make_tuple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">gcd</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">tie</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">gcd</span><span class="p">)</span> <span class="o">=</span> <span class="n">extEuclidCpp</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">%</span><span class="n">b</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nf">make_tuple</span><span class="p">(</span><span class="n">gcd</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="o">-</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>定理: 素数 $p$ 及 $a,b\in\mathbb{Z}$, 若 $p|ab$ 则 $p|a$ 或 $p|b$.</p>
<blockquote>
<p>设 $p\nmid a$ 且 $p\nmid b$, 则 $\exists x,y$ s.t. $xp+ya=1$, 故 $x(ab)+(by)p=b$, 有 $p|b$, 矛盾.</p>
</blockquote>
<p>唯一分解: $\forall n\in\mathbb{Z}$, $n=\prod p_i^{k_i}$, $p_i$ 为不同素数, $k_i\in\mathbb{Z}_+$, 形式唯一.</p>
<h3 id="同余">同余</h3>
<p>性质: $\forall m\in\mathbb{Z}_+$, $a\equiv b({\rm mod}\ m) \Longleftrightarrow m|a-b$.</p>
<ul>
<li>$a\equiv b({\rm mod}\ m)$, $c\equiv d({\rm mod}\ m) \Longrightarrow a+c\equiv b+d({\rm mod}\ m)$, $ac\equiv bd({\rm mod}\ m)$, $a^n\equiv b^n({\rm mod}\ m)$.</li>
<li>$ak\equiv bk({\rm mod}\ m) \Longrightarrow a\equiv b({\rm mod}\ \frac{m}{{\rm gcd}(m,k)})$.</li>
</ul>
<p>模 $m$ 剩余类: $\mathbb{Z}/m\mathbb{Z}$. <br />
最小非负完全剩余系: $\mathbb{Z}_m=\{0,1&hellip;,m-1\}$, 显然 $\forall x\neq y\in\mathbb{Z}_m$ s.t. $x\not\equiv y({\rm mod}\ m)$. <br />
既约剩余系: $\mathbb{Z}_m^*=\{a\in\mathbb{Z}_m|{\rm gcd}(a,m)=1\}$.</p>
<p>Euler $\varphi$ 函数: <br />
$$m=\prod_{i=1}^r p_i^{k_i}, |\mathbb{Z}_m^*|=\varphi(m)=\prod_{i=1}^r p_i^{k_i-1}(p_i-1)=m\prod_{p|m}(1-\frac{1}{p})$$</p>
<p>当 $m=p$ 为素数时, 有 $\varphi(p)=p-1$; $\mathbb{Z}_p^*=\{1,2,&hellip;,p-1\}$ 为循环群, 生成元个数为$\varphi(p-1)$.</p>
<p>考察函数性质:</p>
<ul>
<li>若素数 $p|n$, 则 $\varphi(pn)=p\varphi(n)$;</li>
<li>若素数 $p\nmid n$, 则 $\varphi(pn)=(p-1)\varphi(n)$;</li>
<li>若 ${\rm gcd}(m,n)=1$, 则 $\varphi(m,n)=\varphi(m)\varphi(n)$.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">phi</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">prime</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">isSieved</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// O(n), 每个数均只遍历一次
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">phiEuler</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">phi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isSieved</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">			<span class="n">prime</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">*</span><span class="n">prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">			<span class="kt">int</span> <span class="n">comp</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">prime</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="n">isSieved</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="n">prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">				<span class="n">phi</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">phi</span><span class="p">[</span><span class="n">comp</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>定理: 若 ${\rm \gcd}(a,m)=1$, $x$ 遍历 $\mathbb{Z}_m^*$, 则 $ax$ 也遍历$\mathbb{Z}_m^*$.</p>
<blockquote>
<p>考虑 ${\rm gcd}(ax,m)=1$ 及 $ax_i\not\equiv ax_j({\rm mod}\ m)$, $i\neq j$.</p>
</blockquote>
<p>逆元: 若 ${\rm gcd}(a,m)=1$, 则 $\exists ! x\in\mathbb{Z}_m^*$ s.t. $ax\equiv 1({\rm mod}\ m)$. <br />
Euler: 若 ${\rm gcd}(a,m)=1$, 则 $a^{\varphi(m)}\equiv 1({\rm mod}\ m)$.</p>
<blockquote>
<p>$\mathbb{Z}_m^*=\{x_1,&hellip;,x_{\varphi(m)}\}=\{ax_1,&hellip;,a_{\varphi(m)}\}$, 故 $\prod x_i\equiv\prod ax_i({\rm mod}\ m)$, 已知 ${\rm gcd}(x_i,m)=1$, 得 $m|a^{\varphi(m)}-1$.</p>
</blockquote>
<p>特别 $m=p$ 为素数时, Fermat: 若 $p\nmid a$, 则 $a^{p-1}\equiv 1({\rm mod}\ p)$, 有 $a^{-1}\equiv a^{p-2}({\rm mod}\ p)$. <br />
由扩展Euclid, ${\rm gcd}(a,m)=1$, $\exists s,t\in\mathbb{Z}$ s.t. $as+tm=1$, 即 $a^{-1}\equiv s({\rm mod}\ m)$.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">inverse</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">gcd</span> <span class="o">=</span> <span class="nf">extEuclid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">gcd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>wilson: 素数 $p$ 有 $(p-1)!\equiv -1({\rm mod}\ p)$.</p>
<blockquote>
<p>$\mathbb{Z}_m^*$ 中元素均存在逆, 自逆仅 $1,p-1$; $\{2,3,&hellip;,p-2\}$ 中两两配对互逆.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">wilson</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">factMod</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">        <span class="n">factMod</span> <span class="o">=</span> <span class="p">(</span><span class="n">factMod</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">factMod</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>仿射: ${\rm gcd}(a,26)=1$, 密钥对数量 $26\varphi(26)-1=311$.</p>
<ul>
<li>加密 $c=E_{a,b}(m)=am+b({\rm mod}\ 26)$.</li>
<li>解密 $m=D_{a,b}(c)=a^{-1}(c-b)({\rm mod}\ 26)$.</li>
</ul>
<h3 id="同余式">同余式</h3>
<p>同余式 $f(x)\equiv a_nx^n+&hellip;+a_1x+a_0({\rm mod}\ m)$, $a_i\in\mathbb{z}$, $m\in\mathbb{Z}_+$. <br />
同余方程 $f(x)\equiv 0({\rm mod}\ m)$ 至多有 $m$ 个解(剩余类).</p>
<p>一次同余 $ax\equiv b({\rm mod}\ m)$, $a,b\in\mathbb{Z}$, $m\in\mathbb{Z}_+$ 有解 $\iff {\rm gcd}(a,m)|b$.</p>
<blockquote>
<p>$ax\equiv b({\rm mod}\ m)$ 在 ${\rm gcd}(a,m)=1$ 时有唯一解 $x\equiv a^{-1}b({\rm mod}\ m)$.
记 $d={\rm gcd}(a,m)$, 有 $\frac{a}{d}x\equiv \frac{b}{d}({\rm mod}\ \frac{m}{d})$, 即 $x=\frac{b}{d}(\frac{a}{d})^{-1}+k\frac{m}{d}$, $k\in\mathbb{Z}$.
考虑 $k=qd+r$, $q,r\in\mathbb{Z}$, $0\leq r&lt; d$, $x=[\frac{b}{d}(\frac{a}{d})^{-1}({\rm mod}\frac{m}{d})+r\frac{m}{d}]({\rm mod\ m})$.</p>
</blockquote>
<p>求解步骤:</p>
<ol>
<li>扩展Euclid求 $d={\rm gcd}(a,m)$, 记 $sa+tm=d$;</li>
<li>$b\%d=0$ 判断有无解;</li>
<li>设  $b&rsquo;=b/d$, $m&rsquo;=m/d$, $s&rsquo;\equiv s({\rm mod}\ m&rsquo;)$;</li>
<li>得 $x\equiv s&rsquo;b&rsquo;+rm&rsquo;\ ({\rm mod}\ m)$, $r=0,1,&hellip;,d-1$.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">linearCongEq</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ansX</span><span class="p">[]){</span>  
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">%=</span> <span class="n">m</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="n">b</span> <span class="o">%=</span> <span class="n">m</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">origM</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">extEuclid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="o">&amp;</span><span class="n">t</span><span class="p">);</span>  
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">%</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">        <span class="n">b</span> <span class="o">/=</span> <span class="n">d</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">m</span> <span class="o">/=</span> <span class="n">d</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">%=</span> <span class="n">m</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">r</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">        <span class="n">ansX</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">s</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">r</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">%</span><span class="p">(</span><span class="n">origM</span><span class="p">)</span><span class="o">+</span><span class="n">origM</span><span class="p">)</span><span class="o">%</span><span class="n">origM</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="p">}</span>  
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一次同余组(CRT): $m_{i{1\leq i \leq k}}$ 两两互素, 同余组 $x\equiv a_i({\rm mod\ m_i})_{{1\leq i\leq k}}$ 有唯一解 $x=\sum M_i M_i^{-1} a_i \ ({\rm mod}\ m)$. 其中, $m=\prod m_i$, $M_i=m/m_i$, $M_i^{-1}$ 为模 $m_i$ 上的逆.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">long</span> <span class="nf">crt</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">m</span><span class="p">[],</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">modSepM</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">modIevM</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">modM</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">prodM</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">        <span class="n">prodM</span> <span class="o">*=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">1L</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>  
</span></span><span class="line"><span class="cl">        <span class="n">modM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1L</span><span class="o">*</span><span class="n">prodM</span><span class="o">/</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">        <span class="n">modSepM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1L</span><span class="o">*</span><span class="n">modM</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  
</span></span><span class="line"><span class="cl">        <span class="n">modIevM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">inverse</span><span class="p">(</span><span class="n">modSepM</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>  
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modIevM</span><span class="p">[</span><span class="n">i</span><span class="p">]){</span>  
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">        <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>  
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1L</span><span class="o">*</span><span class="n">modIevM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">modM</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span><span class="n">prodM</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="p">}</span>  
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">prodM</span><span class="p">)</span><span class="o">%</span><span class="n">prodM</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>  
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>RSA: 素数$p,q$, $n=pq$, ${\rm gcd}(e,\varphi(n))=1$, $\varphi(n)=(p-1)(q-1)$.</p>
<ul>
<li>公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\equiv m^e({\rm mod}\ n)$.</li>
<li>私钥$d\equiv e^{-1}({\rm mod}\ \varphi(n))$, 解密 $m=D_{d,n}(m)\equiv c^d({\rm mod}\ n)$.</li>
<li>快速模幂 $r\equiv t^e({\rm mod}\ n)$</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fastPowerMod</span> <span class="p">(</span><span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ex</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">ex</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">ex</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">%</span><span class="n">modular</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">%</span><span class="n">modular</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">ex</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="二次剩余">二次剩余</h3>
<p>$ax^2+bx+c\equiv 0({\rm mod}\ m)$ 总能简化为 $x^2\equiv d({\rm mod}\ q^k)$, $q$ 为素数, $a,b,c,d,m,k\in\mathbb{Z}_+$. <br />
仅考虑 $x^2\equiv a({\rm mod}\ q)$, ${\rm gcd}(a,p)=1$, $a\in\mathbb{Z}$ 为模素数 $q$ 的二次剩余.</p>
<p>Euler: ${\rm gcd}(a,p)=1$, $p$ 为奇素数, $a\in\mathbb{Z}$:</p>
<ul>
<li>模 $p$ 的二次剩余恰有 $\frac{p-1}{2}$ 个.</li>
<li>$a$ 为模 $p$ 二次剩余 $\iff a^{\frac{p-1}{2}}\equiv 1({\rm mod}\ p)$, 此时 $x^2\equiv a({\rm mod}\ p)$ 有二解.</li>
<li>$a$ 为模 $p$ 二次非剩余 $\iff a^{\frac{p-1}{2}}\equiv -1({\rm mod}\ p)$.</li>
</ul>
<blockquote>
<p>显然 $i^2\equiv(p-i)^2({\rm mod}\ p)$; 若 $j^2\equiv i^2({\rm mod}\ p)$, $1\leq i&lt;j&lt;\frac{p}{2}$, 则 $p|j-i$ 或 $p|j+i$, 但 $j+i&lt;p$, 矛盾.</p>
<p>$a$ 为模 $p$ 二次剩余时, $\exists x_0\in\mathbb{Z}$, ${\rm gcd}(x_0,p)=1$, $x_0^2\equiv a({\rm mod}\ p)$, 故 $a^{\frac{p-1}{2}}\equiv x_0^{p-1}\equiv 1({\rm mod}\ p)$.</p>
<p>$a$ 为模 $p$ 二次非剩余时, 考虑 $a^{p-1}\equiv 1({\rm mod}\ p)$, 则 $p|{\frac{p-1}{2}}-1$ 或 $p|{\frac{p-1}{2}}+1$, 但 $x^{\frac{p-1}{2}}\equiv 1({\rm mod}\ p)$ 的全部解恰为全部的二次剩余.</p>
</blockquote>
<p>Legendre: $(\frac{a}{p})=a^{\frac{p-1}{2}}\%p=1\ {\rm or}\ -1\ {\rm or}\ 0$, $p$ 为素数, $a\in\mathbb{Z}$.</p>
<p>$$
(\frac{1}{p}) = 1;\ (\frac{ab}{p})=(\frac{a}{p})(\frac{b}{p}); \ (\frac{a+b}{p})=(\frac{a}{p})+(\frac{b}{p})$$</p>
<p>$$(\frac{a^2}{p})=1,\ {\rm gcd}(a,p)=1$$</p>
<p>$$
(\frac{-1}{p})=\begin{cases}
&amp;1,\ &amp;p\%4=1\\
&amp;-1,\ &amp;p\%4=3
\end{cases}$$</p>
<p>$$
(\frac{2}{p})=\begin{cases}
&amp;1,\ &amp;p\%8=1,7\\
&amp;-1,\ &amp;p\%8=3,5
\end{cases}$$</p>
<p>二次互反: $(\frac{p}{q})(\frac{q}{p})=(-1)^{\frac{p-1}{2}\frac{q-1}{2}}$, $p\ne q$ 为奇素数.</p>
<blockquote>
<p>Guass: 奇素数 $p$, $a\in\mathbb{Z}$, ${\rm gcd}(a,p)=1$, 设 $M_{a,p}=\{ka\%p, \ k=1,2,&hellip;,\frac{p-1}{2}\ |\ ka\%p&gt;\frac{p}{2}\}$, 记 $m(a,p)=|M_{a,p}|$, 则 $(\frac{a}{p})=(-1)^{m(a,p)}$.</p>
<p>设 $K=\{ka\%p\ |\ k=1,2,&hellip;,\frac{p-1}{2}\}$, $b_i\in M$, $c_j\in M-K$, $i=1,2,..,m(a,p)$, $j=1,2,&hellip;,\frac{p-1}{2}-m(a,p)$.</p>
<p>显然有 $c_j\ne p-b_i$, $\forall i,j$; 否则 $p|b_i+c_j$, 即 $\exists x,y\in\mathbb{Z}$, $x,y&lt;\frac{p}{2}$ s.t. $p|a(x+y)$, 但 $x+y&lt;p$, 矛盾.</p>
<p>故 $a^{\frac{p-1}{2}}(\frac{p-1}{2})!\equiv\prod c_j \prod (p-b_i)\equiv (-1)^{m(a,p)}(\frac{p-1}{2})!({\rm mod}\ p)$.</p>
</blockquote>
<blockquote>
<p>Eisenstein: $a$ 为奇数时, 记$e(a,p)=\sum\lfloor\frac{ka}{p}\rfloor$, 有 $e(a,p)\equiv m(a,p)({\rm mod}\ 2)$.</p>
<p>不妨设 $ka=d_kp+r_k$, $0\leq r_k\leq p-1$, $d_k,r_k\in\mathbb{Z}$, 有 $p\sum d_k+\sum r_k=\sum ka = \sum c_j+\sum (p-b_i)$, 故 $\sum d_k\equiv m(a,p)({\rm mod}\ 2)$; 显然 $e(a,p)=\sum d_k$.</p>
</blockquote>
<blockquote>
<p>$q\ne p$ 为奇素数时, $\not\exists x,y\in\mathbb{Z}$, $x,y&lt;\frac{p}{2}$ s.t. $xp=qy$, 即 $e(p,q)+e(q,p)=\frac{p-1}{2}\frac{q-1}{2}$.</p>
</blockquote>
<blockquote>
<p>$a=2$ 时, $\lfloor\frac{p}{4}\rfloor\leq k\leq \lfloor\frac{p}{2}\rfloor$, 有 $m=\lfloor\frac{p}{2}\rfloor-\lfloor\frac{p}{4}\rfloor$.</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fastLegendre</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">a</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">p</span><span class="o">%</span><span class="mi">8</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">p</span><span class="o">%</span><span class="mi">8</span> <span class="o">==</span> <span class="mi">7</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="o">%</span><span class="mi">4</span> <span class="o">==</span> <span class="mi">3</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">s</span> <span class="o">=</span> <span class="o">-</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">s</span><span class="o">*</span><span class="nf">fastLegendre</span><span class="p">(</span><span class="n">p</span><span class="o">%</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Rabin: 素数 $p\equiv q\equiv 3({\rm mod}\ 4)$.</p>
<ul>
<li>公钥 $n=pq$, 加密 $c\equiv E_{n}(m)\equiv m^2({\rm mod}\ n)$.</li>
<li>私钥 $(p,q)$, 解密 $m\equiv D_{p,q}(c)\equiv \pm c^{\frac{p+1}{4}}({\rm mod}\ p)\equiv \pm c^{\frac{q+1}{4}}({\rm mod}\ q)\ (2\ {\rm in}\ 4)$.</li>
</ul>
<h3 id="原根">原根</h3>
<p>原根: $a,m\in\mathbb{Z}$, $m&gt;1$, ${\rm gcd}(a,m)=1$, 记 ${\rm ord}_m(a)=\inf\{x\in\mathbb{Z}_+\ | \ a^x\equiv 1({\rm mod}\ m)\}$ 称为 $a$ 对模 $m$ 的阶; 特别, ${\rm ord}_m(a)=\varphi(m)$ 时称 $a$ 为模 $m$ 的原根.</p>
<p>定理: $a,m\in\mathbb{Z}$, $m&gt;1$, ${\rm gcd}(a,m)=1$, 则 $a^n\equiv 1({rm mod}\ m)\iff {\rm ord}_m(a)|n$. 特别, ${\rm ord}_m(a)|\varphi(m)$.</p>
<p>定理: $g$ 为模 $m$ 原根 $\iff g^{\frac{\varphi(m)}{p_i}}\not\equiv 1({\rm mod}\ m)$, $\forall$ 素数 $p_i|\varphi(m)$.</p>
<blockquote>
<p>必要性: 显然.</p>
<p>充分性: 若 $\exists e&lt;\varphi(m)$ s.t. $g^e\equiv 1({\rm mod}\ m)$; 不妨设 $\frac{\varphi(m)}{e}=kp$, $k\in\mathbb{Z}$, $p$ 为素数; 进而 $g^{\frac{\varphi(m)}{e}\equiv(g^p)^k\equiv 1({\rm mod}\ m)}$, 矛盾.</p>
</blockquote>
<p>定理: $a,m,d\in\mathbb{Z}_+$, ${\rm gcd}(a,m)=1$, ${\rm ord}_m(a^d)=\frac{{\rm ord}_m(a)}{{\rm gcd}({\rm ord}_m(a),d)}$. <br />
推论: 模 $m$ 存在原根时, 有 $\varphi(\varphi(m))$ 个原根; 同时原根为模 $m$ 上本原多项式的全部解. <br />
以下显然:</p>
<ul>
<li>${\rm ord}_m(a)={\rm ord}_m(a^{-1})$.</li>
<li>$b\equiv a({\rm mod}\ m)$, 则 ${\rm ord}_m(b)={\rm ord}_m(a)$.</li>
<li>${\rm gcd}(a,m)=1$, $a^0,a^1,&hellip;,a^{{\rm ord}_m(a)-1}$ 两两模 $m$ 不同余.</li>
<li>特别, $g$ 为模 $m$ 原根时, 恰好有 $\mathbb{Z}_p^*={g^0,g^1,&hellip;,g^{\varphi(g)-1}}$.</li>
<li>$g$ 为模 $m$ 原根时, $x,y\in\mathbb{Z}$, $g^x\equiv g^y({\rm mod}\ m) \iff x\equiv y({\rm mod}\ \varphi(m))$.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">nMod1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">primeFact</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">primeFact</span><span class="p">[</span><span class="n">num</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">        <span class="n">r</span> <span class="o">=</span> <span class="nf">fastPowerMod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="o">/</span><span class="n">primeFact</span><span class="p">[</span><span class="n">num</span><span class="p">],</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">++</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">primeFact</span><span class="p">[</span><span class="n">num</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">minPrimeRoot</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">primeFact</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nf">factPrime</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">primeFact</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">nMod1</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">primeFact</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="n">res</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>D-H协议: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\leq x,y\leq p-1$.</p>
<ul>
<li>公钥 $(p,g)$, 私钥 $x,y$.</li>
<li>握手: $k_{X\to Y}\equiv g^x({\rm mod}\ p)$, $k_{Y\to X}\equiv g^y({\rm mod}\ p)$.</li>
<li>密钥: $k\equiv k_{Y\to X}^x\equiv k_{X\to Y}^y \equiv g^{xy}({\rm mod}\ p)$.</li>
</ul>
<p>ElGamal: 大素数 $p$ 和模 $p$ 原根 $g$, 任选 $2\leq a\leq p-1$, $Y_a\equiv g^a({\rm mod}\ p)$.</p>
<ul>
<li>公钥 $(p,g,Y_a)$, 加密 $u\equiv g^k({\rm mod}\ p)$, $v\equiv mY_a^k({\rm mod}\ p)$, $c=E_{p,g,Y_a,k}(m)=(u,v)$, 任选 $2\leq k\leq p-1$.</li>
<li>私钥 $a$, 解密 $m\equiv D_a(c)\equiv \frac{v}{u^a}({\rm mod}\ p)$.</li>
</ul>
<h3 id="群">群</h3>
<p>有限群: 非空有限集 $G$ 上代数运算满足结合律, 存在单位元(记 $e$), 逆元(记 $a^{-1}$); <br />
记 $|G|={\rm Card}(G)$ 为阶; 定义 $a^{-n}=(a^{-1})^n$, $a^0=e$.</p>
<p>半群: 只满足结合律. <br />
幺半群: 存在单位元的半群. <br />
交换半群: 满足交换律的半群. <br />
交换幺半群: 存在单位元满足交换律的半群. <br />
Abel群: 满足交换律的群. <br />
消去律: 可由结合律和逆元推得.</p>
<p>元素的阶: $|a|=\inf \{n\in\mathbb{N}_+\ |\ a^n = e\}$ 或 $\infty$; <br />
$|a^{-1}|=|a|$, $|a^d|=\frac{|a|}{{\rm gcd}(|a|,d)}$; 若 $n\in\mathbb{Z}$, $a^n=e$ 则 $|a||n$.</p>
<p>子群: 群 $G$ 的非空子集 $H$ 关于 $G$ 的代数运算构成群, 记 $H&lt;G$; 真子群即非平凡子群({e},G); <br />
$H&lt;G$ 则 $e\in H$, $e\in G$, 且 $\forall a\in H$, $a^{-1}\in G$; $H&lt;G \iff \forall a,b\in H$, $ab^{-1}\in H$.</p>
<p>循环群: 群 $G$ 的非空子集 $S$, 生成子群 $\langle S\rangle=\bigcap_{S\subset H&lt;G}H=\{\prod a_i^{l_i}\ |\ a_i\in S, l_i=\pm 1\}$; <br />
特别 $S=\{a\}$ 时, 循环子群 $\langle S\rangle=\langle a\rangle=\{a^n\ |\ n\in\mathbb{Z}\}$; <br />
特别 $G=\langle a\rangle$ 时为循环群 $\iff\exists a\in G$ s.t. $|a|=|G|$; <br />
循环群子群仍为循环群; 无限循环群同构于 $\mathbb{Z}$, $n$ 阶循环群同构于 $\mathbb{Z}_n$.</p>
<blockquote>
<p>不妨设 $H&lt;G=\langle a\rangle$, $H\ne {e}$, $\exists a^k\in H$, $a^{-k}\in H$, 则 $\exists r,t\in\mathbb{Z}_+$, $q\in\mathbb{Z}$ s.t. $a^r\in H$, $n=qr+t$; 进而 $a^n=a^{qr+t}\in H$ 即 $t=0$, 故 $H\subset \langle a^r\rangle$.</p>
</blockquote>
<p>陪集: $H&lt;G$, $\forall a\in G$, $aH$ 为左陪集; <br />
$a\in aH$, $aH=H\iff a\in H$, $aH=bH$ 或 $aH\cap bH=\empty$, $|H|=|aH|$; $G=\bigcup_{g\in G}gH$.</p>
<p>Lagrange: 记 $[G:H]=\frac{|G|}{|H|}$, $|G|=[G:H]|H|$; $|a|||G|$.</p>
<p>正规子群: $H&lt;G$, $\forall a\in G$, $aH=Ha$, 记 $H\lhd G$; $H&lt;G$, $\forall a\in G$, $H\lhd G \iff aHa^{-1}=H \iff aHa^{-1} \subset H \iff aha^{-1}\in H$, $\forall h\in H$.</p>
<p>商群: $H\lhd G$, $G/H=\{aH\ |\ a\in G\}$, $aH\ast bH=(ab)H$.</p>
<p>同态: 保持代数运算不变的映射, 双射时为同构. <br />
群同态: 群 $G_1,G_2$, 映射 $f:G_1\to G_2$, $f(ab)=f(a)f(b)$, $\forall a,b\in G_1$.</p>
<p>同态 Paillier: 素数 $p,q$, $n=pq$, $\lambda = {\rm lcm}(p-1)(q-1)$ 最小公倍数, $g\in\mathbb{Z}_{n^2}^*$ s.t. ${\rm gcd} (\frac{g^\lambda \% n^2 -1}{n},n)=1$.</p>
<ul>
<li>公钥 $(n,g)$, 加密 $c\equiv E_{n,g}(m)\equiv g^m r^n({\rm mod}\ n^2)$, $r\in\mathbb{Z}_n^*$.</li>
<li>私钥 $\lambda$, 解密 $m\equiv D_\lambda(c)\equiv\frac{c^\lambda \%n-1}{g^\lambda \&amp;n-1}({\rm mod}\ n^2)$.</li>
<li>加法同态: $m_1+m_2=D_\lambda[E_{n,g}(m_1)E_{n,g}(m_2)]$.</li>
</ul>
<p>置换群: 非空集合 $X$ 上所有可逆变换(双射)关于复合构成对称群 $S_x$; $S_x$ 子群称为变换群; <br />
特别 $|X|=n$ 时, 记 $S_x = S_n$, $S_n$及其子群称为置换群, 元素 $\sigma$ 称为置换; $|S_n|=n!$.</p>
<p>轮换: $f\in S_n$, $i_1,&hellip;,i_r\in X$, $f(i_1)=i_2,&hellip;,f(i_{r-1})=i_r,f(i_r)=i_1$ 且保持其他元素不变时, $f=(i_1,i_2,&hellip;,i_r)$ 称为 $r$ -轮换; <br />
特别 $r=1$ 时为恒等变换, $r=2$ 时称为对换; <br />
任意置换可唯一表示为不相交的轮换之积; 任意轮换可以表示为对换之积.</p>
<p>Cayley: 任意有限群同构于一置换群.</p>
<h3 id="环和域">环和域</h3>
<p>环: 非空集合 $R$ 上两个代数运算 $(+,\cdot)$, $(R,+)$ 为Abel群, $(R,\cdot)$ 为半群, $\cdot$ 对 $+$ 有双边分配律; <br />
为区别, $+$ 的单位元称为零元(记 $0$), 逆元称为负元(记 $-a$). <br /></p>
<p>单位: $a\in R$, $\exists b\in R$ s.t. $ab=ba=e$, 则称 $a$ 为单位; 环中所有单位构成单位群, 记 $U(R)$; $U(\mathbb{Z}_m)=\mathbb{Z}_m^*$. <br />
零因子: 非零元 $a,b\in R$ s.t. $ab=0$, $a$ 为 $b$ 的左零因子.</p>
<p>交换环: $(R,\cdot)$ 为交换半群. <br />
交换幺环: $(R,\cdot)$ 为交换幺半群. <br />
无零因子环: $(R,\cdot)$ 为无零因子半群. <br />
整环: $(R,\cdot)$ 为无零因子交换幺半群. <br />
域: $(R-\{0\},\cdot)$ 为Abel群.</p>
<p>双边理想: 非空集合 $I\subset R$, $I$ 对 $+$ 封闭, 对 $\cdot$ 吸收, 即 $\forall s\in R$, $sI\subset I$, $Is\subset I$, 记 $I \lhd R$; $d\mathbb{Z}\lhd\mathbb{Z}$.</p>
<p>商环: $I\lhd R$, $R/I &lt; R$; $R/I=\{a+I\ | \ a\in R\}$. <br />
$(a+I)+(b+I)=(a+b)+I$, $(a+I)(b+I)=(ab)+I$.</p>
<blockquote>
<p>映射: 不妨设 $a_1+I=a_2+I$, $b_1+I=b_2+I$, 则有 $(a_1b_1)+I=(a_2b_2)+I$. 考虑 $a_1-a_2\in I$, $b_1-b_2\in I$, 有 $a_1=s+a_2$, $b_1=t+b_2$, $s, t\in I$, 进而 $a_1b_1=a_2b_2+x=a_2b_2+(sb_2+ta_2+st)$, 同时 $x\in I$.</p>
<p>封闭: $\forall x\in I$, $(a+x)(b+x)=ab+(a+b+x)x\in (ab)+I$.</p>
<p>由此可知, 理想的吸收性可确保商环存在.</p>
</blockquote>
<p>生成理想: 非空集合 $S\subset R$, 包含 $S$ 的所有理想的交集; <br />
特别 $S=\{a\}$ 时, 记 $\langle S\rangle=\langle a\rangle$ 为 $a$ 生成的主理想; <br />
特别 $R$ 为交换幺环时, 主理想 $\langle a\rangle=\{ra\ | \ r\in R\}$; <br />
$\mathbb{Z}$ 的所有理想均为主理想.</p>
<blockquote>
<p>任取非平凡理想 $I\lhd \mathbb{Z}$, $\exists$ 最小 $t\in\mathbb{Z}_+$, $\forall m\in I$, $m=qt+r$, $q,r\in I$, $0\leq r&lt;t$, 即 $r=0$, $I=\langle t\rangle$.</p>
</blockquote>
<p>素理想: 交换幺环 $R$, 非平凡 $P\lhd R$, 若 $ab\in P$, 有 $a\in P$ 或 $b\in P$; 特别整环中, 素元 $p$, $\langle p\rangle$ 为素理想. <br />
交换幺环 $R$, $P\lhd R$, $R/P$ 为整环 $\iff P$ 为素理想. <br />
极大理想: 交换幺环 $R$, 非平凡 $M\lhd R$, 无真包含 $M$ 的非平凡理想. <br />
交换幺环 $R$, $M\lhd R$, $R/M$ 为域 $\iff M$ 为极大理想. <br />
极大理想一定为素理想, 反之不然.</p>
<p>Euclid整环(ED): 满足Euclid性的整环, $\forall a,b\in R-\{0\}$, 有映射 $\varepsilon: R-\{0\}\to \mathbb{Z}_+$ s.t. $\varepsilon(a)\leq\varepsilon(ab)$, $\exists r,q\in R$ s.t. $a=bq+r$, $\varepsilon(r)&lt;\varepsilon(b)$ 或 $r=0$; 其上有最大公因数. <br />
主理想整环(PID): 理想均为主理想的整环; 其上素元和不可约元等价, 素理想和极大理想等价; 素元为非零元非单位 $p$ s.t. $a,b\in R$, 若 $p|ab$, 有 $p|a$ 或 $p|b$; 不可约元为非零元非单位 $q$ s.t. $a,b\in R$, 若 $q=ab$, 有 $a$ 或 $b$ 为单位. <br />
唯一析因整环(UFD): 整环 $R$ 中非零元非单位的元素可以唯一表示为有限个不可约元的积.</p>
<p>定理: 所有域都是ED; 所有ED都是PID; 所有PID都是UFD.</p>
<p>特征: ${\rm char}(R)=\inf\{n\in\mathbb{Z}_+\ | \ na=a,\forall a\in R\}$ 或0; ${\rm char}(\mathbb{Z})=0$, ${\rm char}(\mathbb{Z}_m)=m$; <br />
整环特征必为0或素数, 非空有限域特征必为素数, ${\rm char}(F_p)=p$; <br />
$\forall a,b\in F_p$, $(a+b)^p=a^p+b^p$.</p>
<blockquote>
<p>$|e| = \infty$ 时, ${\rm char}(R)=0$.</p>
<p>$|e| = n$ 时, 若 $n$ 为合数, $\exists p|n$，不妨设 $pc=n$, $ne=(pe)(ce)=0$, 则 $pe=0$ 或 $ce=0$, 矛盾. $\forall a\in R$, $na=(ne)a=0$.</p>
</blockquote>
<p>单变量多项式环: 整环 $R$ 上整环 $R[x]=\{a_nx^n+&hellip;+a_1x+a_0\ | \ a_i\in R\}$; <br />
记 $f(x)=a_nx^n+&hellip;+a_1x+a_0$, $a_n\ne 0$ 时, 记 ${\rm deg}f=n$; 特别 ${\rm deg}0=-\infty$. <br />
$f(x),g(x),h(x)\in R[x]$, $f(x)g(x)=h(x)$, 则 ${\rm deg}f+{\rm deg}g={\rm deg}h$. <br />
域 $K$, $f(x)\in K[x]$, ${\rm deg}f&gt;0$, $p(x)$ 为 $f(x)$ 次数最小的因式, 则 $p(x)$ 为 $K[x]$ 上不可约多项式, 且 ${\rm deg}p\leq \frac{1}{2}{\rm deg}f$.</p>
<p>带余除法: $f(x),g(x)\in R[x]$, 则 $\exists q(x),r(x)\in R[x]$ s.t. $f(x)=q(x)g(x)+r(x)$, ${\rm deg}r&lt;{\rm deg}g$. <br />
$f(x)\in R[x]$, $a\in R$, 则 $\exists q(x)$ s.t. $f(x)=(x-a)q(x)+f(a)$. <br />
$f(x)\in R[x]$, $a\in R$, 则 $x-a|f(x)\iff f(a)=0$. <br />
同余: 首一多项式 $m(x)\in R[x]$, $f(x),g(x)\in R[x]$, $m(x)|f(x)-g(x)$, 记 $f(x)\equiv g(x)({\rm mod}\ m(x))$.</p>
<p>Euclid: 域 $K$ 上 $K[x]$ 为ED; 即有Euclid性和最大公因式.  <br />
$f(x),g(x)\in K[x]$, $g(x)|f(x)\iff r(x)=0$. <br />
$f(x)\in K[x]$, $\forall K[x]$ 上不可约多项式 $p(x)$, ${\rm deg}p\leq {\rm deg}f$, s.t. $p(x)\nmid f(x)$, 则 $f(x)$ 为 $K[x]$ 上不可约多项式.</p>
<p>定理: 域 $F$ 上 $F[x]$, $f(x)\in F(x)$, 则 $F[x]/f(x)$ 为域 $\iff f(x)$ 为 $F[x]$ 上不可约多项式. <br />
特别有素数 $p$ 和 $F[x]$ 上不可约多项式 $degr=n$, $F_p[x]/&lt;r(x)&gt;=\{\sum_{i=0}^{n-1}a_0x^i\ |\ a_i\in F_p\}\cong F_{p^n}$, 即有 $|F_p[x]/&lt;r(x)&gt;|=p^n$.</p>
<p>有限域结构: $\forall$ 素数 $p$, $n\in\mathbb{Z}_+$, 存在同构意义下唯一的有限域 $F_{p^n}$ s.t. $|F_{p^n}|=p^n$, ${\rm char}(F_{p^m})=p$.</p>
<p>NTRU: 环 $L=\mathbb{Z}[x]/(x^n-1)$, $n$ 为大素数; 选取大数 $p,q$, 有 ${\rm gcd}(p,q)=1$ 且 $q\ll p$; 选取 $f(x),g(x)\in L$, 有 ${\rm deg}f={\rm deg}g=n-1$. <br />
$f^{-1}_p(x)$ 为 $f(x)$ 系数模 $p$ 逆, $f^{-1}_q(x)$ 为 $f(x)$ 系数模 $q$ 逆; $h(x)\equiv f^{-1}_q(x)({\rm mod}\ q)$.</p>
<ul>
<li>公钥 $(n,p,q,h(x))$, 明文多项式 $m(x)=\sum a_ix_i$ 有 $|a_i|\leq \frac{p-1}{2}$ 及 ${\rm deg}m\leq n$, 随机选取噪音 $r(x)\in L$, 加密 $c(x)\equiv pr(x)h(x)+m(x)({\rm mod}\ q)$.</li>
<li>私钥 $(f(x),f^{-1}_p(x))$, 解密 $d(x)\equiv f(x)c(c)({\rm mod}q)$, $b(x)\equiv d(x)({\rm mod}\ p)$, $m(x)\equiv f^{-1}_p(x)({\rm mod}\ p)$.</li>
</ul>
<h3 id="椭圆曲线群">椭圆曲线群</h3>
<p>定义: 域 $F$, $a,b,c,d,e\in F$, 满足Weierstrass方程 $E=y^2+axy+by=x^3+cx^2+dx+e$ 所有点 $(x,y)$ 和无穷远点 $O$ 的集合.</p>
<p>Hasse定理: 有限域 $GF(p)$ 上椭圆曲线, $n$ 为 $E$ 上点 $(x,y)$, $x,y\in\mathbb{Z}_p$ 的个数, 则 $|n-(p+1)|\leq 2\sqrt p$.</p>
<p>有限域上椭圆曲线: 有限域 $GF(p)$ 上椭圆曲线 $y^2\equiv x^2+ax+b({\rm mod}\ p)$, $a,b,x,y\in GF(P)$, 且满足 $4a^2+27b^2\not\equiv 0({\rm mod}\ p)$ (此时无重根), 记为 $E_p(a,b)$.</p>
<p>构造: $x$ 遍历 $\in\mathbb{Z}_p$, $t_x\equiv x^3+ax+b({\rm mod}\ p)$, $a,b\in GF(p)$; Euler保留所有模 $p$ 二次剩余的 $t_x$, 并求出两根; $t=0$ 时只有一根 $y=0$.</p>
<p>定理: $E_p(a,b)$ 关于点的加法构成Abel群. <br />
无穷远点 $O$ 为单位元, 逆元为关于 $x$ 轴对称点, 横坐标不同的点(相同的只有自身和逆元)相加为连线延长线与曲线交点关于 $x$ 轴的对称点, 相同点相加为该点处切线与曲线交点关于 $x$ 轴的对称点.</p>
<blockquote>
<p>不妨设 $P,Q\in E_p(a,b)$, $P,Q\ne O$, $P=(x_1,y_1)$, $Q=(x_2,y_2)$, $R=P+Q=(x_3,y_3)\ne O$.</p>
<p>则 $x_3=\lambda^2-x_1-x_2$, $y_3=\lambda(x_1-x_3)-y_1$, 其中 $\lambda=\frac{y_2-y_1}{x_2-x_1}\ (P\ne Q);\ \frac{3x^2_2+a}{2y_1}\ (P=Q)$.</p>
</blockquote>
<p>ECDH: 椭圆曲线群 $E_p$, $G\in E_p$, $|G|=q$ 为大素数, 任选 $2\leq a,b\leq q-1$.</p>
<ul>
<li>公钥 $(p,G)$, 私钥 $x,y$.</li>
<li>握手: $k_{A\to B}=aG$, $k_{B\to A}=bG$.</li>
<li>密钥: $k=ak_{B\to A}=bk_{A\to B}=(ab)G$.</li>
</ul>
<p>ECEG: 椭圆曲线群 $E_p$, $G\in E_p$, $|G|=q$ 为大素数, 任选 $2\leq d\leq q-1$, $P=dG$.</p>
<ul>
<li>公钥 $(P,G,E,n)$, 加密 $C_1=rG$, $C_2=M+rP$, $C=E_{E_p,P,G,r}(M)=\{C_1,C_2\}$, 任选 $2\leq r\leq q-1$.</li>
<li>私钥 $d$, 解密 $M=D_{E_p,d}(C)=C_2-dC_1$.</li>
<li>快速倍乘 $P=mG$, $m\in\mathbb{Z}_p$, $G\in\ E_p(a,b)$.</li>
</ul>
<h3 id="传统算法">传统算法</h3>
<p>素数定理: $\pi(x)$ 为 $\leq x$ 的素数个数, 有 $\lim_{x\to\infty}\frac{\pi(x)}{x/\ln x}=1$.</p>
<ul>
<li>Fermat测试: 若 $n$ 为素数, $a\in\mathbb{Z}$, $1\leq a\leq n-1$, 则 $a^{n-1}\equiv 1({\rm mod}\ n)$. 随机测试 $t$ 次, 确为素数可能性大于 $1-\frac{1}{2^t}$.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">fermat</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span><span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">srand</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="nf">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="nf">rand</span><span class="p">()</span><span class="o">%</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span> <span class="o">=</span> <span class="nf">fastPowerMod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Solovay-Stranssen测试: Jacobi符号 $(\frac{a}{m})=\prod(\frac{a}{p_i})^{\alpha_i}$, 其中 $n=\prod(p_i^{\alpha_i})$. 若 $n$ 为素数, $x=(\frac{a}{n})$, $y\equiv a^{\frac{n-1}{2}}({\rm mod}\ n)$, 则 $x\equiv y({\rm mod}\ n)$.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">solovayStrassenX</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">srand</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="nf">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="nf">rand</span><span class="p">()</span><span class="o">%</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span> <span class="o">=</span> <span class="nf">jacobi</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">);</span> <span class="c1">// jacobi同fastLegendre
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">y</span> <span class="o">=</span> <span class="nf">fastPowerMod</span><span class="p">(</span><span class="n">a</span><span class="p">,(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Millar-Rabin测试: Fermat测试时, 不妨设 $a^{n-1}=(a^t)^{2^k}$, $a^t\equiv 1({\rm mod}\ n)$ 则直接满足素性条件, 否则检验 $a^t$ 的 $i=1,&hellip;,k-1$ 次平方, $(a^{t})^{2^i}\equiv -1({\rm mod}\ n)$ 时直接满足素性条件.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">bool</span> <span class="nf">millerRabin</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">t</span><span class="o">%</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">k</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">srand</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="nf">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span> <span class="o">=</span> <span class="nf">rand</span><span class="p">()</span><span class="o">%</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span> <span class="o">=</span> <span class="nf">fastPowerMod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">==</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1LL</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">r</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>大合数分解: 试除法时间复杂度 $O(\sqrt n)$.</p>
<ul>
<li>Pollard-$\rho$ 法: 有限集上随机函数存在碰撞; $n$ 不为素数或某个素数的幂, 寻找小因子.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">rho</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1LL</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1LL</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1LL</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">d</span> <span class="o">=</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Pollard-$p-1$ 法: 素数 $p|n$, $p-1$ 分解中素因子最大次幂 $q|p-1$, $\forall B\geq q$ s.t. $p-1|B$, 即 $2^{B!}\equiv 2^{p-1}\equiv 1({\rm mod}\ p)$, 故有 $p|{\rm gcd}(n,2^{B!}-1)$.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pollard</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">24</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">B</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">a</span> <span class="o">=</span> <span class="nf">fastPowerMod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">((</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>随机平方法: $x,y\in\mathbb{Z}$ s.t. $x^2\equiv y^2({\rm mod}\ n)$, $x\not\equiv\pm y({\rm mod}\ n)$, 若 $n|x^2-y^2$ 且 $n\nmid x-y$ ($n\nmid x+y$), 则素数 $p={\rm gcd}(x+y,n)$ ($p={\rm gcd}(x-y,n)$).</li>
</ul>
<p>离散对数求解: 有限域 $F_p$ 上遍历需要 $O(p)$ 次乘法.</p>
<ul>
<li>
<p>小步大步法(Shank): 群阶为 $n$, $m=\lceil\sqrt n\rceil$, 设 $\log_a b=x=mj+i$, $0\leq i,j\leq m-1$, 即 $b(a^{-i})=(a^m)^j$; 搜索树存储 $1,a^m,&hellip;,(a^m)^{m-1}$, 遍历 $b(a^{-i})$ 并匹配.</p>
</li>
<li>
<p>Pollard-$\rho$ 法: 素数 $p$, $a,b\in\mathbb{Z}_p^*$, 不妨设 $x_i=a^{m_i}b^{n_i}$, 有碰撞 $x_i=x_{2i}$ 时, 有 $\log_a b\equiv (n_{2i}-n_i)^{-1}(m_{2i}-m_i)({\rm mod}\ |a|)$.</p>
</li>
</ul>
<p>$$f(x_{i+1},m_{i+1},n{i_1})=\begin{cases}
(bx,m_i,n_i+1),\ &amp; x_i\in S_1 \\
(x^2,2m_i,2n_i),\ &amp; x_i\in S_2 \\
(ax,m_i+1,n_i),\ &amp; x_i\in S_3
\end{cases},\ S_1\sqcup S_2\sqcup S_3=\mathbb{Z}_p^*$$</p>
<ul>
<li>
<p>指数演算法: 素数 $p$, 原根 $a\in\mathbb{Z}_p^*$, 小素因子基 $B=\{p_1,p_2,&hellip;,p_k\}$, 选取 $k$ 个 $1\leq x\leq p-2$ 均 s.t. $x\equiv \alpha_1\log_a p_1+\alpha_2\log_a p_2+&hellip;+\alpha_k\log_a p_k({\rm mod}\ p-1)$, 可解得 $\log_a p_1,\log_a p_2,&hellip;,\log_a p_k$; 选取 $1\leq s\leq p-2$ s.t. $\log_a b+s\equiv \gamma_1\log_a p_1+\gamma_2\log_a p_2+&hellip;+\gamma_k\log_a p_k({\rm mod}\ p-1)$</p>
</li>
<li>
<p>Pohlig-Hellman算法: 素数 $p$, 原根 $a\in\mathbb{Z}_p^*$, 最小原根 $g$, $a\equiv g^m({\rm mod}\ p)$, $b\equiv g^n({\rm mod}\ p)$, 则 $m\log_a b\equiv n({\rm mod}\ p-1)$ 可由扩展Euclid算法给出.</p>
</li>
</ul>
<p>$p-1=\prod_{i=1}^k p_i^{\alpha_i}$ 中均为小素数, 有 $k$ 个同余式 $m\equiv \sum_{j=0}^{\alpha_i-1} c_{ij}p_i^j({\rm mod}\ p_i^{k_i})$; 由 Fermat 可得 $g^{c_{ij}\frac{p-1}{p_i^{\alpha_i}}}\equiv a^{\frac{p-1}{p_i}^{\alpha_i}}({\rm mod}\ p)$. 遍历并得到 $0\leq c_{ij}\leq p_i^{\alpha_i}-1$; 对 $k$ 个同余式使用CRT即得到 $m$.</p>
<h2 id="古典密码">古典密码</h2>
<p>古典密码主要为置换密码和代换密码.</p>
<p>置换密码: $\sigma$ 为 $M$ 上一个置换(到自身的双射).</p>
<ul>
<li>加密: $(c_i)=E_{k}((m_i))=\sigma_{k_i}((m_i))$.</li>
<li>解密: $(m_i)=D_{k}((c-i))=\sigma_{k_i}^{-1}((c_i))$.</li>
</ul>
<p>代换密码</p>
<ul>
<li>加密: $c_i=E_{k}(m_i)\equiv f(m_i,k)({\rm mod}\ 26)$.</li>
<li>解密: $m_i=E_{k}(c_i)\equiv f^{-1}(c_i,k^{-1})({\rm mod}\ 26)$.</li>
</ul>
<p>单表代换可以直接通过字母频率分析破解.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">freqAnalyze</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cipher</span><span class="p">,</span> <span class="kt">long</span> <span class="o">*</span><span class="n">count</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">num</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">isupper</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">num</span><span class="p">])){</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span><span class="p">[</span><span class="n">cipher</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;A&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">islower</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">num</span><span class="p">])){</span>
</span></span><span class="line"><span class="cl">            <span class="n">count</span><span class="p">[</span><span class="n">cipher</span><span class="p">[</span><span class="n">num</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="o">++</span><span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>粗糙度: ${\rm M.R}=\sum_{i=0}^25(p_i-\frac{1}{26})^2=\sum_{i=0}^25p_i^2-0.0385$. 明文或单表代换时 ${\rm M.R}\approx 0.027$, 更接近 $0$ 则更可能为多表代换.</p>
<p>重合指数: ${\rm IC}=\sum_{i=0}^25p_i^2$. 多表代换时 ${\rm IC}\approx 0.0655$. 相同字母间隔为 $d_1,&hellip;,d_n$, 则密钥可能长度为 ${\rm gcd}(d_1,&hellip;,d_n)$.</p>
<h3 id="仿射密码">仿射密码</h3>
<p>单表代换的代表.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">affineEn</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">plain</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cipher</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyA</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyB</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">length</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">plain</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">isupper</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">])){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">keyA</span><span class="o">*</span><span class="p">(</span><span class="n">plain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;A&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">keyB</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span><span class="o">+</span><span class="sc">&#39;A&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">islower</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">])){</span>
</span></span><span class="line"><span class="cl">            <span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">keyA</span><span class="o">*</span><span class="p">(</span><span class="n">plain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">)</span><span class="o">+</span><span class="n">keyB</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span><span class="o">+</span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">plain</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">affineDe</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cipher</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">plain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyAReverse</span><span class="p">,</span> <span class="kt">int</span> <span class="n">keyB</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">long</span> <span class="n">length</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">cipher</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nf">isupper</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">])){</span>
</span></span><span class="line"><span class="cl">            <span class="n">plain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">keyAReverse</span><span class="o">*</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;A&#39;</span><span class="o">-</span><span class="n">keyB</span><span class="p">))</span><span class="o">%</span><span class="mi">26</span><span class="o">+</span><span class="mi">26</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span><span class="o">+</span><span class="sc">&#39;A&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">islower</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">])){</span>
</span></span><span class="line"><span class="cl">            <span class="n">plain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">keyAReverse</span><span class="o">*</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="o">-</span><span class="n">keyB</span><span class="p">))</span><span class="o">%</span><span class="mi">26</span><span class="o">+</span><span class="mi">26</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span><span class="o">+</span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">plain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cipher</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="vernam密码">Vernam密码</h3>
<p>序列密码的基础.</p>
<h2 id="自同步序列密码">自同步序列密码</h2>
<p>异或$\rm XOR$ ($GF(2)$加法) $\oplus$ 加密: 无条件安全; 可逆.</p>
<p>与同步序列密码相比, 传输产生的错误有界.</p>
<p>种子密钥通过LFSR(线性反馈移位寄存器)生成伪随机密钥序列 $k=k_0k_1k_2&hellip;$.</p>
<ul>
<li>加密 $c_i=E_{k}(m)=m_i\oplus k_i$.</li>
<li>解密 $m_i=D_{k}(m)=c_i\oplus k_i$.</li>
</ul>
<p>LFSR: 状态 $(s_0,s_1,&hellip;,s_{n-1})$, 递推关系式 $s_{n+k}=\bigoplus g_is_i$, 反馈函数 $f(s_0,s_1,&hellip;,s_{n-1})=\sum g_is_i$, 连接多项式(特征多项式) $g(x)=\sum g_ix_i$, $s_i,g_i,x_i\in GF(2)$.</p>
<blockquote>
<p><img src="/img/post-crypto-sym-LFSR.png"
	
	
	
	loading="lazy"
	
		alt="egLFSR"
	
	
> <br />
e.g. $\ g(x)=1+x+x^2+x^5$, $s_{5+i}=s_{i}+s_{1+i}+s_{4+i}$. <br />
$S_0=(1,0,1,1,1)$, $k=101110111011101110111&hellip;$, $T=8$.</p>
</blockquote>
<p>使用verligo实现LFSR.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 32-bit long
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">module</span> <span class="nf">lfsr</span><span class="p">(</span><span class="mi">32</span><span class="p">)(</span><span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">lfsr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">input</span> <span class="n">clk</span><span class="p">,</span> <span class="n">reset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">output</span> <span class="n">reg</span> <span class="p">[</span><span class="mi">31</span><span class="o">:</span><span class="mi">0</span><span class="p">]</span> <span class="n">lfsr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">wire</span> <span class="n">d0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="nf">xnor</span><span class="p">(</span><span class="n">d0</span><span class="p">,</span> <span class="n">lfsr</span><span class="p">[</span><span class="mi">31</span><span class="p">],</span> <span class="n">lfsr</span><span class="p">[</span><span class="mi">21</span><span class="p">],</span> <span class="n">lfsr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">lfsr</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">  <span class="n">always</span> <span class="err">@</span><span class="p">(</span><span class="n">posedge</span> <span class="n">clk</span><span class="p">,</span> <span class="n">posedge</span> <span class="n">reset</span><span class="p">)</span> <span class="n">begin</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">reset</span><span class="p">)</span> <span class="n">begin</span>
</span></span><span class="line"><span class="cl">      <span class="n">lfsr</span> <span class="o">&lt;=</span> <span class="mi">32</span><span class="err">&#39;</span><span class="n">h00000001</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">end</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="n">begin</span>
</span></span><span class="line"><span class="cl">      <span class="n">lfsr</span> <span class="o">&lt;=</span> <span class="p">{</span><span class="n">lfsr</span><span class="p">[</span><span class="mi">30</span><span class="o">:</span><span class="mi">0</span><span class="p">],</span> <span class="n">d0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">end</span>
</span></span><span class="line"><span class="cl">  <span class="n">end</span>
</span></span><span class="line"><span class="cl"><span class="n">endmodule</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>定理: $n$ 次特征多项式为 $GF(2^n)$ 上本原多项式时, 输出 $\max T=2^n-1$ 序列($m$ 序列).</p>
<ol>
<li>将 $x^{2^n-1}-1$ 在 $GF(2^n)$ 上因式分解;</li>
<li>保留次数为 $n$ 且不能在 $GF(2^n)$ 上整除 $x^a-1,n&lt;a&lt;2^n-1$ 的因式.</li>
</ol>
<p>截获长度 $l\geq 2(2^n-1)$ 的明密文对 $(c,m)$, 则 $k=c\oplus m$, 有 $S_i,&hellip;,S_{i+n+1}$ 个状态; <br />
记 $X=(S_i,&hellip;,S_n)$, $Y=(S_{i+1},&hellip;,S_{i+n+1})$, 有 $Y\equiv HX({\rm mod}\ 2)$. <br />
$m$ 序列时, $X$满秩, $H\equiv YX^{-1}({\rm mod}\ 2)$ 为特征多项式的友矩阵.</p>
<p>$$H=\left( \begin{array}{}
0 &amp; 1 &amp; 0 &amp; &hellip; &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; &hellip; &amp; 0 \\
&hellip; \\
0 &amp; 0 &amp; 0 &amp; &hellip; &amp; 1 \\
g_0 &amp; g_1 &amp; g_2 &amp; &hellip; &amp; g_{n-1}
\end{array}\right )$$</p>
<p>可引入非线性运算增加复杂性: 与AND($GF(2)$上乘法) $\otimes$.</p>
<h3 id="ad5">AD5</h3>
<p>欧洲移动通信GSM标准, 手机到基站间的链路语音加密. <br />
由19位, 22位, 23位3个LSR组成; 时钟控制信号来自LSR1第8位, LSR2第10位, LSR3第10位; 若三者相同则均移位, 若两者相同则相同的移位, 不同的不移位; 即每个时钟至少有两个LSR移位.</p>
<p>不同文献的连接多项式不同, 其中一个为:</p>
<p>$$\begin{cases}
g_1(x)=x^{19}+x^{18}+x^{17}+x^{14}+1 \\
g_2(x)=x^{22}+x^{21}+1 \\
g_3(x)=x^{23}+x^{22}+x^{21}+x^8+1
\end{cases}$$</p>
<p>安全问题: 三个LSR长度过短; 种子密钥不同也会产生相同的密钥序列; 以目前计算能力不安全.</p>
<h3 id="rc4">RC4</h3>
<p>基于非线性数据表变换. 密钥流产生分为2个阶段: 输入密钥并初始化排列S表; S表不断置换产生密钥流.</p>
<ol>
<li>初始化: 线性填充256字节S表, 密钥循环填充T表. $i$ 遍历 $0-255$, $j=(j+S[i]+T[i])\%256$, 交换 $S[i]$ 和 $S[j]$.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">uint8</span> <span class="o">*</span><span class="n">S</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">key</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#34;&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Key:&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fgets</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="n">stdin</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">keyLen</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint8</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">keyLen</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span><span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>产生密钥流: $i$ 循环遍历 $0-255$, $j=(j+S[i])\%256$, 交换 $S[i]$ 和 $S[j]$, $t=(S[i]+S[j])\%256$, $k_i=S[t]$.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">rc4EnDe</span><span class="p">(</span><span class="n">uint8</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">result</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint8</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">text</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">%</span><span class="mi">256</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">%</span><span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">^</span><span class="n">S</span><span class="p">[</span><span class="n">t</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>安全问题: 存在弱密钥使得初始化置换后 $S$ 表顺序不变; 存在弱密钥使得密钥流在100万字节内完全重复; 密钥较短的容易被攻击, 但长度超过128位的密钥依然有效.</p>
<h3 id="zuc">ZUC</h3>
<p>LTE-4G国际标准, 包含机密性128-EEA3和完整性128-EIA3, 基于LFSR的非线性组合逻辑结构. <br />
分为三层结构: LSFR, Bit重组, 非线性F函数. <br />
符号约定: $\boxplus$ 为$GF(2^{32})$ 上加法; $|$ 为连接字符串; $_H$ 为高位16位; $_L$ 为低位16位; $&lt; &lt;_o$ 为循环左移.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">uint32</span> <span class="n">a</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">b</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">&amp;</span><span class="mh">0x7fffffff</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">c</span><span class="o">&gt;&gt;</span><span class="mi">31</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exp</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">((</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="n">exp</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">exp</span><span class="p">)))</span><span class="o">&amp;</span><span class="mh">0xfffffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">rot</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mov</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="n">mov</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">31</span><span class="o">-</span><span class="n">mov</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>输入参数: COUNT 计数器 32bit; BEARER 传载层标识 5bit; DIRECTION 传输方向标志 1bit; CK 密钥 128bit; IBS 输入比特流(明文或密文).</p>
</li>
<li>
<p>密钥装入: 128bit扩展为16个31bit, $k=k_0|k_1|&hellip;|k_{15}$, $v=v_0|v_1|&hellip;|v_{15}$; 其中 $iv_0={\rm COUNT}[0]$, $iv_1={\rm COUNT}[1]$, $iv_2={\rm COUNT}[2]$, $iv_3={\rm COUNT}[3]$, $iv_4={\rm BEARER}|{\rm DIRECTION}|00$, $iv_5=iv_6=iv_7=00000000$, $iv_{j+8}=iv_j$, $j=8,9,&hellip;,15$.</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="mi">10</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">+</span><span class="p">((</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="n">iv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="mi">10</span><span class="p">))</span><span class="o">&lt;&lt;</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="o">+</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="o">+</span><span class="mi">10</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>LSFR: 连接多项式为 $GF(2^{31}-1)$ 上本原多项式 $g(x)=x^{16}-2^{15}x^{15}-2^{17}x^{13}-2^{21}x^{10}-2^{20}x^{4}-2^8-1$; 输出 $m$ 序列周期 $T=(2^{31}-1)^{16}-1$; 生成16个31bit LFSR块.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">LFSRInitMode</span><span class="p">(</span><span class="n">uint32</span> <span class="n">u</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="n">LFSR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="mi">21</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span><span class="mi">17</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span><span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">u</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LFSR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LFSR</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">LFSR</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">LFSRWorkMode</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="n">LFSR</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="mi">20</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span><span class="mi">21</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">13</span><span class="p">],</span><span class="mi">17</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">tmp</span> <span class="o">=</span> <span class="nf">mod2ExpMulti</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">15</span><span class="p">],</span><span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">v</span> <span class="o">=</span> <span class="nf">modAdd</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">v</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LFSR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">LFSR</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">LFSR</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Bit重组: $X_0=S[15]_H|S[14]_L$, $X_1=S[11]_L|S[9]_H$ ,$X_2=S[7]_L|S[5]_H$, $X_3=S[2]_L|S[0]_H$.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">bitRecons</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0x7fff8000</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">&amp;</span><span class="mh">0x0000ffff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">LFSR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="mi">15</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>非线性F函数: $W=(X_0\oplus R_1)\boxplus R_2$, $W_1=R_1\boxplus X_1$, $W_2=R_2\boxplus X_2$, $R_1=S(L_1(W_{1L}|W_{2H}))$, $R_2=S(L_2(W_{2L}|W_{1H}))$; 其中 $L_1(a)=a\oplus(a&lt; &lt;_o 2)\oplus(a&lt; &lt;_o 10)\oplus(a&lt; &lt;_o 18)\oplus(a&lt; &lt;_o 24)$, $L_2(a)=a\oplus(a&lt; &lt;_o 8)\oplus(a&lt; &lt;_o 14)\oplus(a&lt; &lt;_o 22)\oplus(a&lt; &lt;_o 30)$; $S$ 盒为 $(S_0,S_1,S_0,S_1)$, 每8bit作为索引, 返回 $S$ 盒中对应的8bit数值.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">F</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">W1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">W2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">^</span><span class="n">R1</span><span class="p">)</span><span class="o">+</span><span class="n">R2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">W1</span> <span class="o">=</span> <span class="n">R1</span><span class="o">+</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">W2</span> <span class="o">=</span> <span class="n">R2</span><span class="o">+</span><span class="n">X</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">R1</span> <span class="o">=</span> <span class="nf">S</span><span class="p">(</span><span class="nf">L1</span><span class="p">((</span><span class="n">W1</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">W2</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl">    <span class="n">R2</span> <span class="o">=</span> <span class="nf">S</span><span class="p">(</span><span class="nf">L2</span><span class="p">((</span><span class="n">W1</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">W2</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">L1</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">18</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">24</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">L2</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">14</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">22</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">30</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">S</span><span class="p">(</span><span class="n">uint32</span> <span class="n">a</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint8</span> <span class="n">x</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="n">y</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S0</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">S1</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="n">y</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>密钥流输出: $K=W\oplus X[3]$, 每个时钟节拍产生32bit密钥流.</p>
</li>
<li>
<p>输出参数: OBS 输出比特流(密文或明文).</p>
</li>
</ul>
<p>ZUC生成密钥流分为5个阶段: $ck$ 和 $iv$ 装载到LFSR; 寄存器 $R_1,R_2$ 置空; 初始化模式运行32次; 工作模式运行1次并舍弃输出; 持续工作模式产生密钥流.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 1. 装载LFSR
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">keyIVInsert</span><span class="p">(</span><span class="n">uint8</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="n">uint8</span> <span class="o">*</span><span class="n">iv</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">LFSR</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">23</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">)</span><span class="o">|</span><span class="n">iv</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 2. 置空寄存器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">uint32</span> <span class="n">R1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">R2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 3. 初始化模式运行32次 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="n">uint8</span> <span class="o">*</span><span class="n">k</span><span class="p">,</span> <span class="n">uint8</span> <span class="o">*</span><span class="n">iv</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">keyIVInsert</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">iv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">R1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">R2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitRecons</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">F</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LFSRInitMode</span><span class="p">(</span><span class="n">W</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="o">*</span><span class="nf">keyStreamGenerate</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">keyLen</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="o">*</span><span class="n">keyStream</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint32</span> <span class="o">*</span><span class="p">)</span><span class="nf">malloc</span><span class="p">(</span><span class="n">keyLen</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">uint32</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 4. 工作模式运行1次并舍弃输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">bitRecons</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">F</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="nf">LFSRWorkMode</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 5. 持续工作模式产生密钥流
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">keyLen</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitRecons</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="nf">F</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">keyStream</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">W</span><span class="o">^</span><span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">LFSRWorkMode</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">keyStream</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>安全问题: 能够抵御多种已知针对序列密码的攻击, 主要威胁是侧信道攻击.</p>
<h2 id="分组密码">分组密码</h2>
<p>本质为单表代换, 复杂多轮非线性, 通过混淆和扩散实现. </pr>
组件: S盒(混淆扩散), P置换(扩散), 轮函数F, 密钥扩展.</p>
<p>结构模型</p>
<ul>
<li>S-P网络: 每轮异或密钥后, S盒分组小块混淆扩散, P置换整体扩散, $N_i=F(N_{i-1}\oplus K_i)$.</li>
<li>Feistel网络: 分为左右两部分, $R_i=F(R_{i-1},K_i)\oplus L_{i-1}$, $L_i=R_{i-1}$, 最后一轮不做对换; 同个算法实现加解密.</li>
</ul>
<p>工作模式:</p>
<ul>
<li>ECB(电子密码本): 分组用相同密钥加密; 相同明文产生相同密文; 可并行.</li>
<li>CBC(密码分组链接): 初始化 $iv$ 得到第一组密文, 第一组密文与第二组明文异或后再加密; TSL及IPSEc协议推荐; 仅解密支持并行.</li>
<li>CFB(密文反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与明文异或后得到密文 $C$, $C$ 高位 $n$ 位填入 $vi$; 流式数据, 错误有界; 仅解密支持并行.</li>
<li>OFB(输出反馈): 初始化 $iv$ 得到密文 $E$, $vi$ 左移 $n$ 位, 密文 $E$ 与高位 $n$ 位填入 $vi$, 密文 $E$ 与明文异或后得到密文 $C$; 流式数据, 错误有界; 不支持并行.</li>
<li>CTR(计数器): 自增算子加密后与明文异或得到密文; 相当于一次一密; 简单快速安全可并行.</li>
</ul>
<h3 id="des">DES</h3>
<p>数据加密标准(Data Encryption Standard), 体现Shannon密码设计思想, 公开密码算法先例, 16轮Feistel网络对合加解密.</p>
<ul>
<li>密钥扩展: 初始密钥(64bit)经PC1表置换得到 $C_i$ 和 $D_i$ (各28bit), 循环左移 $ls_i$ 位, 经PC2表置换得到第 $i$ 轮子密钥 $K_i$ (48bit); 置换表中元素 $pt_{i}$ 意为将待置换中的第 $pt_{i}$ 位置换到第$i$位.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">tablePermute</span><span class="p">(</span><span class="n">bit1</span> <span class="o">*</span><span class="n">permuted</span><span class="p">,</span> <span class="n">bit1</span> <span class="o">*</span><span class="n">origin</span><span class="p">,</span> <span class="n">bit8</span> <span class="o">*</span><span class="n">table</span><span class="p">,</span> <span class="n">bit8</span> <span class="n">size</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">bit1</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">origin</span><span class="p">[</span><span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bitCopy</span><span class="p">(</span><span class="n">permuted</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="n">size</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">keyExp</span><span class="p">(</span><span class="n">bit8</span> <span class="o">*</span><span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">bit1</span> <span class="n">keyPerRound</span><span class="p">[</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="n">bit1</span> <span class="o">*</span><span class="n">keyPrL</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">keyPerRound</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">bit1</span> <span class="o">*</span><span class="n">keyPrR</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">keyPerRound</span><span class="p">[</span><span class="mi">28</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="nf">byteToBit</span><span class="p">(</span><span class="n">keyPerRound</span><span class="p">,</span><span class="n">key</span><span class="p">,</span><span class="mi">8</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">tablePermute</span><span class="p">(</span><span class="n">keyPerRound</span><span class="p">,</span><span class="n">keyPerRound</span><span class="p">,</span><span class="n">PC1</span><span class="p">,</span><span class="mi">56</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitRot</span><span class="p">(</span><span class="n">keyPrL</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="n">LS</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitRot</span><span class="p">(</span><span class="n">keyPrR</span><span class="p">,</span><span class="mi">28</span><span class="p">,</span><span class="n">LS</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">tablePermute</span><span class="p">(</span><span class="n">subKey</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">keyPerRound</span><span class="p">,</span><span class="n">PC2</span><span class="p">,</span><span class="mi">48</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>初始置换与结束逆置换: 明(密)文(64bit)经IP表置换进入加密, 完成加(解)密后经IPR表置换得到密(明)文(64bit).</p>
</li>
<li>
<p>轮函数: 32bit输入经E表置换扩充到48bit, 与子密钥(48bit)异或后, 经S盒压缩回32bit(<strong>混淆</strong>), 再经P表置换得到32bit输出(<strong>扩散</strong>); S盒6位输入 $b_1b_2b_3b_4b_5b_6$, 输出$s_{b_1b_6, b_2b_3b_4b_5}$.</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">SPermute</span><span class="p">(</span><span class="n">bit1</span> <span class="o">*</span><span class="n">permuted</span><span class="p">,</span> <span class="n">bit1</span> <span class="o">*</span><span class="n">origin</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bit1</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">origin</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">bit1</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">permuted</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">row</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">p1</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">col</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">p1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">p1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">p1</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="nf">byteToBit</span><span class="p">(</span><span class="n">permuted</span><span class="p">,</span><span class="o">&amp;</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">],</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">p1</span> <span class="o">+=</span> <span class="mi">6</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">p2</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">F</span><span class="p">(</span><span class="n">bit1</span> <span class="o">*</span><span class="n">output</span><span class="p">,</span> <span class="n">bit1</span> <span class="o">*</span><span class="n">input</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">bit1</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">48</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="nf">tablePermute</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">input</span><span class="p">,</span><span class="n">E</span><span class="p">,</span><span class="mi">48</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">bitXor</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">input</span><span class="p">,</span><span class="mi">48</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">SPermute</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="n">tmp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">tablePermute</span><span class="p">(</span><span class="n">output</span><span class="p">,</span><span class="n">output</span><span class="p">,</span><span class="n">P</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 加密
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">tablePermute</span><span class="p">(</span><span class="n">textBit</span><span class="p">,</span><span class="n">textBit</span><span class="p">,</span><span class="n">IP</span><span class="p">,</span><span class="mi">64</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">15</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitCopy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">textBitR</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">F</span><span class="p">(</span><span class="n">textBitR</span><span class="p">,</span><span class="n">subKey</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitXor</span><span class="p">(</span><span class="n">textBitR</span><span class="p">,</span><span class="n">textBitL</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitCopy</span><span class="p">(</span><span class="n">textBitL</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">tablePermute</span><span class="p">(</span><span class="n">textBit</span><span class="p">,</span><span class="n">textBit</span><span class="p">,</span><span class="n">IPR</span><span class="p">,</span><span class="mi">64</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 解密, 密钥顺序相反
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">tablePermute</span><span class="p">(</span><span class="n">textBit</span><span class="p">,</span><span class="n">textBit</span><span class="p">,</span><span class="n">IP</span><span class="p">,</span><span class="mi">64</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitCopy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">textBitL</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">F</span><span class="p">(</span><span class="n">textBitL</span><span class="p">,</span><span class="n">subKey</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitXor</span><span class="p">(</span><span class="n">textBitL</span><span class="p">,</span><span class="n">textBitR</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">bitCopy</span><span class="p">(</span><span class="n">textBitR</span><span class="p">,</span><span class="n">tmp</span><span class="p">,</span><span class="mi">32</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">tablePermute</span><span class="p">(</span><span class="n">textBit</span><span class="p">,</span><span class="n">textBit</span><span class="p">,</span><span class="n">IPR</span><span class="p">,</span><span class="mi">64</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>S盒是DES中唯一非线性变换, 设计准则: 改变1bit输入至少2bit发生变化; $S(x)$ 和 $S(x\oplus 001100)$ 至少2bit发生变化; $S(x)\neq S(x\oplus 11ef00)$, $e,f\in{0,1}$; 改变5bit输入, 输出的0和1数目大致相等; 足够的非线性度以抵抗线性攻击; 差分性均匀以抵抗差分攻击; 足够的代数次数和项目以抵抗插值攻击和高阶差分攻击.</p>
<p>攻击类型: 穷钥攻击; 侧信道攻击(能量分析, 故障注入分析); 差分攻击; 线性攻击.</p>
<p>安全问题: 密钥太短(有效仅56bit); 存在弱密钥; 互补对称性(异或运算).</p>
<p>3-DES: 112(1和3轮密钥相同)/256bit密钥; 加解密速度慢.</p>
<h3 id="aes">AES</h3>
<p><em>(something wrong in the AES code)</em></p>
<p>高级数据加密标准(Advanced Encryption Standard), 采用10/12/14轮S-P网络非对合加解密(对应128/192/256bit密钥).</p>
<p>$GF(2)$ 上多项式域 $GF(2^8)\cong  GF(2)[x]/(x^8+x^4+x^3+x+1)$ 中元素为 $b_{(8)}=b_7x^7+b_6x^6+b_5x^5+b_4x^4+b_3x^3+b_2x^2+b_1x+b_0$, 乘法需对既约多项式 $m(x)=x^8+x^4+x^3+x+1$ 取模, 乘法逆元可由扩展Euclid算法得到. <br />
考虑 $xb_{(8)}=(b_{(8)}&lt; &lt; 1)\oplus m(x)$, 高次乘法可重复 $x$ 乘实现.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">uint8</span> <span class="nf">modMulti</span><span class="p">(</span><span class="n">uint8</span> <span class="n">x</span><span class="p">,</span> <span class="n">uint8</span> <span class="n">y</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint8</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tmp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&amp;</span><span class="mh">0x01</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">ans</span> <span class="o">^=</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span> <span class="o">=</span> <span class="n">y</span><span class="o">&amp;</span><span class="mh">0x80</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">y</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">y</span> <span class="o">^=</span> <span class="mh">0x1B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>$GF(2^8)$ 上 $degf\leq 3$ 多项式环 $GF(2^8)/[x^4+1]$ 中元素为 $b_{(32)}=B_3x^3+B_2x^2+B_1x+B_0$, 乘法需对 $x^4+1$ 取模.
考虑 $xb_{(32)}=b_{(32)}&gt; &gt;8$, 高次乘法可视为 $GF(2^8)$ 上矩阵乘法.</p>
<ul>
<li>状态矩阵: 128bit明(密)文和密钥按列优先载入4阶方阵, 每列32bit称为&quot;字&quot;, 加(解)密后按列优先输出密(明)文.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">loadState</span><span class="p">(</span><span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span> <span class="n">uint8</span><span class="o">*</span> <span class="n">text</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">state</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">text</span><span class="o">++</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">storeState</span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span> <span class="n">text</span><span class="p">,</span> <span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="o">*</span><span class="p">(</span><span class="n">text</span><span class="o">++</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>密钥扩展: 4字输入, 扩展为44字输出; $w[i]=w[i-1]\oplus w[i-4]$, $i\% 4 \ne 0$; $w[i]=w[i-4]\oplus S(w&rsquo;[i-1])\oplus Rcon[i]$, $i \% 4 = 0$, 即每个字循环左移1字节后进行S盒置换.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">mixRoll</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">sub1</span> <span class="o">=</span> <span class="n">S</span><span class="p">[(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="mi">24</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">24</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">sub2</span> <span class="o">=</span> <span class="n">S</span><span class="p">[(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="mi">16</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">16</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">sub3</span> <span class="o">=</span> <span class="n">S</span><span class="p">[(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="mi">8</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">sub4</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">x</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">sub1</span><span class="o">&amp;</span><span class="mh">0xff000000</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">sub2</span><span class="o">&amp;</span><span class="mh">0xff0000</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">sub3</span><span class="o">&amp;</span><span class="mh">0xff00</span><span class="p">)</span><span class="o">^</span><span class="p">(</span><span class="n">sub4</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">keyExp</span><span class="p">(</span><span class="n">uint8</span><span class="o">*</span> <span class="n">key</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">key</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">^</span> <span class="nf">mixRol1</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">m</span><span class="p">])</span><span class="o">^</span><span class="n">rotConst</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">w</span><span class="p">[</span><span class="mi">5</span><span class="o">+</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="o">+</span><span class="n">m</span><span class="p">]</span><span class="o">^</span><span class="n">w</span><span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="n">m</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">w</span><span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">2</span><span class="o">+</span><span class="n">m</span><span class="p">]</span><span class="o">^</span><span class="n">w</span><span class="p">[</span><span class="mi">5</span><span class="o">+</span><span class="n">m</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">w</span><span class="p">[</span><span class="mi">7</span><span class="o">+</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">m</span><span class="p">]</span><span class="o">^</span><span class="n">w</span><span class="p">[</span><span class="mi">6</span><span class="o">+</span><span class="n">m</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>轮函数: 主要包括(逆)字节代换, (逆)行位移, (逆)列混合, 轮密钥加(即子密钥异或).</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="c1">// 加密: 字节代换, 行位移, 列混合, 轮密钥加, 最后一轮跳过列混合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">loadState</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pPlain</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addRoundKey</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">pW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pW</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">subBytes</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">shiftRows</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mixCols</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">addRoundKey</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">pW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">subBytes</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">shiftRows</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addRoundKey</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">pW</span><span class="o">+</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">storeState</span><span class="p">(</span><span class="n">pCipher</span><span class="p">,</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 解密: 密钥顺序相反, 逆行位移, 逆字节代换, 轮密钥加, 逆列混合, 最后一轮跳过逆列混合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">loadState</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pCipher</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addRoundKey</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">pW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">pW</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nf">shiftRowsInv</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">subBytesInv</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">addRoundKey</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">pW</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">mixColsInv</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">shiftRowsInv</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">subBytesInv</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">addRoundKey</span><span class="p">(</span><span class="n">state</span><span class="p">,</span><span class="n">pW</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">storeState</span><span class="p">(</span><span class="n">pPlain</span><span class="p">,</span><span class="n">state</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>字节代换即取求每个字节在 $GF(2^8)$ 上的逆后进行仿射变换, 可等效为S盒置换; 逆字节代换即逆仿射变换再取逆, 可等效为逆S盒置换.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">subBytes</span><span class="p">(</span><span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">subBytesInv</span><span class="p">(</span><span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">SInv</span><span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>行位移即第 $i=0,1,2,3$ 个字循环右移 $i$ 字节; 逆行位移即第 $i$ 个字循环左移 $i$ 字节.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">rol</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">,</span> <span class="n">uint8</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="n">n</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">n</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">ror</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">,</span> <span class="n">uint8</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">&gt;&gt;</span><span class="n">n</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">x</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">32</span><span class="o">-</span><span class="n">n</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shiftRows</span><span class="p">(</span><span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">rol</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">store</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">shiftRowsInv</span><span class="p">(</span><span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">ror</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mi">8</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="nf">store</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>列混合即按列的字在  $GF(2^8)[x^4+1]$ 上与 $a(x)={\rm 0x03}x^3+{\rm 0x01}x^2+{\rm 0x01}x+{\rm 0x02}$ 相乘; 逆列混合即与 $a^{-1}(x)={\rm 0x0B}x^3+{\rm 0x0D}x^2+{\rm 0x09}x+{\rm 0x0E}$ 相乘; 均可等效为 $GF(2^8)$ 上的矩阵乘法.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mixCols</span><span class="p">(</span><span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint8</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">modMulti</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span> <span class="nf">modMulti</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl">                          <span class="nf">modMulti</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span> <span class="nf">modMulti</span><span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">mixColsInv</span><span class="p">(</span><span class="n">uint8</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint8</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">tmp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">state</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nf">modMulti</span><span class="p">(</span><span class="n">DInv</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span> <span class="nf">modMulti</span><span class="p">(</span><span class="n">DInv</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span>
</span></span><span class="line"><span class="cl">                          <span class="nf">modMulti</span><span class="p">(</span><span class="n">DInv</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="o">^</span> <span class="nf">modMulti</span><span class="p">(</span><span class="n">DInv</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">tmp</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>安全问题: 主要威胁是侧信道攻击.</p>
<h3 id="sm4">SM4</h3>
<p>128bit密钥32轮非平衡Feistel网络. 1字$=$4字节$=$32bit.</p>
<ul>
<li>密钥扩展: 初始密钥 $(MK_0,MK_1,MK_2,MK_3)$, $K_i=MK_i\oplus FK_i$ ,$rk_i = K_{i+4} = K_i\oplus T(K_{i+1}\oplus K_{i+2}\oplus K_{i+3}\oplus CK_i)$; FK_i 为系统参数, CK_i 为固定参数; 以每个字节前4bit作为行, 后4bit作为列, 进行非线性的S盒置换; 再对字进行线性变换 $B\oplus (B &lt; &lt;_o 13)\oplus (B &lt; &lt;_o 23)$.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">TKey</span><span class="p">(</span><span class="n">uint32</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sk</span> <span class="o">=</span> <span class="nf">SPermute</span><span class="p">(</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sk</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">sk</span><span class="p">,</span><span class="mi">23</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">generateRk</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint32</span> <span class="n">K</span><span class="p">[</span><span class="mi">35</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">MK</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">^</span><span class="n">FK</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">K</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="nf">TKey</span><span class="p">(</span><span class="n">K</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="n">K</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="n">K</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="n">CK</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">        <span class="n">rk</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>轮函数: $X_{i+4} = X_i\oplus T&rsquo;(X_{i+1}\oplus X_{i+2}\oplus X_{i+3}\oplus rK_i)$; 进行非线性的S盒置换后, 再对字进行线性变换 $B\oplus (B &lt; &lt;_o 2)\oplus (B &lt; &lt;_o 10)\oplus (B &lt; &lt;_o 18)\oplus (B &lt; &lt;_o 24)$.</p>
</li>
<li>
<p>反序输出: 输入 $(X_1,X_2,X_3,X_4)$, 输出 $(Y_1,Y_2,Y_3,Y_4)=(X_{35},X_{34},X_{33},X_{32})$.</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">uint32</span> <span class="nf">T</span><span class="p">(</span><span class="n">uint32</span> <span class="n">x</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">sx</span> <span class="o">=</span> <span class="nf">SPermute</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sx</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="mi">18</span><span class="p">)</span><span class="o">^</span><span class="nf">rot</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="mi">24</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">F32</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">X</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="nf">T</span><span class="p">(</span><span class="n">X</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="n">X</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="n">X</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">%</span><span class="mi">4</span><span class="p">]</span><span class="o">^</span><span class="n">rk</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="o">-</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>安全问题: 主要威胁是侧信道攻击(故障注入分析).</p>
<h2 id="公钥密码">公钥密码</h2>
<h3 id="基础">基础</h3>
<p>使用对称加密, $n$ 个实体的网络需要 $\frac{(n-1)n}{2}$ 个密钥及同等数量的保密信道, 密钥管理困难. <br />
对称加密也难以解决签名和认证问题: 接收方可以伪造原文; 发送方可以否认行为.</p>
<p>非对称加密基本条件: (1)安全 $k_e\ne k_d$ 且由 $k_e$ 不能得到 $k_d$; (2) 保密: $D(E(m))=m$; (3)E和D高效; (4) 保真: $E(D(m))=m$.</p>
<p>单向陷门函数: $y=f(x)$ 满足: (1)给定 $x$, 计算 $y$ 很容易; (2)给定$y$, 不掌握陷门, 计算 $x=f^{-1}(y)$ 很困难; (3)给定$y$, 掌握陷门, 计算 $xf^{-1}(y)$ 很容易.</p>
<p>数学难题</p>
<ul>
<li>大合数分解难题: 大素数乘积容易 $p\times q=n$, 大合数分解困难 $n=p\times q$.</li>
<li>离散对数难题(DLP): 有限域 $GF(p)$ 上生成元幂乘容易 $a^b=c$, 求对数困难 $\log_a c=b$.</li>
<li>椭圆曲线离散对数难题(ECDLP): 椭圆曲线群 $E_p(a,b)$ 中基点倍乘容易 $dP=Q$, 求倍数困难 $d=\frac{Q}{P}$.</li>
<li>误差还原难题(LWE): 有限域 $GF(p)$ 上矩阵乘法加误差容易 $v=As+e$, 解带噪音的线性方程组困难 $s=A^{-1}(v-e)$.</li>
</ul>
<p>工作方式</p>
<ul>
<li>发送方 $A$: 先用发送方私钥 $k_{Ad}$ 签名 $s=D(m,k_{Ad})$, 再用接收方公钥 $k_{Be}$ 加密 $c=E(s,k_{Be})$.</li>
<li>接收方 $B$: 先用接收方私钥 $k_{Bd}$ 解密 $s=E(c,k_{Bd})$, 再用发送方公钥 $k_{Ae}$ 验证 $m=D(s,k_{Ae})$.</li>
<li>机密性: 公钥加密, 私钥解密.</li>
<li>真实性: 私钥签名, 公钥验证.</li>
</ul>
<h3 id="rsa">RSA</h3>
<p>RSA: 素数$p,q$, $n=pq$, ${\rm gcd}(e,\varphi(n))=1$, $\varphi(n)=(p-1)(q-1)$.</p>
<ul>
<li>公钥 $(e,n)$, 加密 $c=E_{e,n}(m)\equiv m^e({\rm mod}\ n)$.</li>
<li>私钥$d\equiv e^{-1}({\rm mod}\ \varphi(n))$, 解密 $m=D_{d,n}(m)$</li>
</ul>
<blockquote>
<p>证明: $D_{d,n}(E_{e,n}(m))=m$, $E_{e,n}(D_{d,n}(c))=c$.</p>
<p>即证 $m_{ed}\equiv m^{(t\varphi(n))+1} \equiv m({\rm mod}\ n)$.</p>
<p>${\rm gcd}(M,n)=1$ 时, 有Euler定理 $m^{\varphi(m)}\equiv 1({\rm mod}\ n)$.</p>
<p>${\rm gcd}(M,n)\ne 1$ 时, 由于 $m\leq n$, 不妨设 $m = ap$, $a\in\mathbb{Z}$, 有 $m^{\varphi(q)}\equiv 1({\rm mod}\ q)$, 即 $m^t{\varphi(n)}=bq+1$, $b\in\mathbb{Z}$, 故 $m^t{\varphi(n)+1} = abn+M$.</p>
</blockquote>
<ul>
<li>参数选取</li>
</ul>
<p>$p,q$ 足够大, 一般场景使 $n$ 达到1024bit, 重要场景2048bit. <br />
$p,q$ 为强素数, $p-1,p+1,q-1,q+1$ 中均无除 $2$ 外的小因子. <br />
$p,q$ 位数不能相差过大或过小. <br />
私钥 $d\ne e$. <br />
${\rm gcd}(p-1,q-1)$ 尽可能小, 最好为2; 以避免密文迭代攻击. <br />
$e$ 应保证 $m^e\ll n$; 有人建议为素数 $2^{16}+1=65537$, 二进制表示中仅含两位 $1$, 加密速度较快. <br />
$d$ 应较小以保证解密速度, 但确保$d\ll \frac{n}{4}$. <br />
多个用户不得共用同一个模 $n$; 以避免共模攻击.</p>
<ul>
<li>
<p>大素数产生: Miller-Rabin测试.</p>
</li>
<li>
<p>加密优化算法: 快速模幂, Montgomery.</p>
</li>
<li>
<p>解密优化算法: CRT, 快速模幂, Montgomery.</p>
</li>
</ul>
<p>Montgomery: $a\%m=a-k\times\lfloor[\frac{a}{m}]\rfloor$ 除法运算复杂度较高, 将模乘转换为乘法运算. <br />
记 $a&rsquo;\equiv aR({\rm mod}\ m)$, $b&rsquo;\equiv bR({\rm mod}\ m)$, $R=2^k&gt;m$, $m$ 为奇数, 即 ${\rm gcd}(R,m)=1$; 此时 $a&rsquo;R^{-1}=a&rsquo;&gt; &gt;k$, $abR\equiv (a&rsquo;b&rsquo;)R^{-1}({\rm mod}\ m)$, $ab\equiv (abR)^R{-1}({\rm mod}\ m)$. <br />
$\exists q$ s.t. $R|a+qm$, 有 $y=\frac{a+qm}{R}&lt;2m$; 不妨设 $xR-ym=1$, $0&lt;y&lt;R$, $0&lt;x&lt;m$, 有 $q\equiv ay({\rm mod}\ R)$, 其中 $y\equiv -m^{-1}({\rm mod}\ R)$.</p>
<h3 id="elgamal型">ElGamal型</h3>
<h3 id="ntru">NTRU</h3>
<h2 id="hash函数">Hash函数</h2>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E6%95%B0%E5%AD%A6/">数学</a>
        
            <a href="/tags/c/">C</a>
        
            <a href="/tags/c&#43;&#43;/">C&#43;&#43;</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 2023-11-03
        </span>
    </section></footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2023 annesede
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.20.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
